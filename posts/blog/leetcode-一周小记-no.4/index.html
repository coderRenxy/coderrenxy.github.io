<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode 一周小记 No.4 | 小任同学&#39;s Blog</title>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="keywords" content="算法" />
<meta name="description" content="Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 &#43;">
<meta name="author" content="
作者:&nbsp;小任同学">
<link rel="canonical" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7623b46c5149f45c86bb2cab2316266b62404755c0674d3e97963430d13b957e.css" integrity="sha256-diO0bFFJ9FyGuyyrIxYma2JAR1XAZ00&#43;l5Y0MNE7lX4=" rel="preload stylesheet" as="style">
<link rel="preload" href="img/icon-32.png" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://coderrenxy.github.io/icon-512.png">
<link rel="apple-touch-icon" href="https://coderrenxy.github.io/icon-512.png">
<link rel="mask-icon" href="https://coderrenxy.github.io/icon-512.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="LeetCode 一周小记 No.4" />
<meta property="og:description" content="Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 &#43;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-15T05:13:45&#43;08:00" />
<meta property="article:modified_time" content="2022-05-05T23:33:37&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 一周小记 No.4"/>
<meta name="twitter:description" content="Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 &#43;"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://coderrenxy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📋 技术",
      "item": "https://coderrenxy.github.io/posts/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "LeetCode 一周小记 No.4",
      "item": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode 一周小记 No.4",
  "name": "LeetCode 一周小记 No.4",
  "description": "Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +",
  "keywords": [
    "算法"
  ],
  "articleBody": "Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n Tuesday 429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg…..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) …………..\n Wednesday 226.翻转二叉树 递归：确定参数类型、返回值 — 确定终止条件 — 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026\u0026。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n Thursday 110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n Friday 113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n 持续更新…….\n如有错误，敬请斧正！！！\n",
  "wordCount" : "2147",
  "inLanguage": "en",
  "datePublished": "2022-03-15T05:13:45+08:00",
  "dateModified": "2022-05-05T23:33:37+08:00",
  "author":[{
    "@type": "Person",
    "name": "小任同学"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "小任同学's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://coderrenxy.github.io/img/icon-512.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://coderrenxy.github.io/" accesskey="h" title="小任同学&#39;s Blog (Alt + H)">
                <img src="https://coderrenxy.github.io/img/icon-32.png" alt="logo" aria-label="logo"
                    height=" 30px">小任同学&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://coderrenxy.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/search/" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://coderrenxy.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/blog/">📋 技术</a></div>
    <h1 class="post-title">
      LeetCode 一周小记 No.4
    </h1>
    <div class="post-meta">
			<p id="wc" style="font-size: 12px;">本文总阅读量<span id="busuanzi_value_page_pv"></span>次&nbsp;&nbsp;</p>











创建:&nbsp;<span title='2022-03-15 05:13:45 +0800 CST'>2022-03-15</span>&nbsp;|&nbsp;更新:&nbsp;2022-05-05&nbsp;|&nbsp;字数:&nbsp;2147字&nbsp;|&nbsp;时长: 5分钟&nbsp;|&nbsp;
作者:&nbsp;小任同学&nbsp;|&nbsp;<a href="https://github.com/coderRenxy/coderrenxy.github.io/content/posts/blog/LeetCode%20%e4%b8%80%e5%91%a8%e5%b0%8f%e8%ae%b0%20No.4.md" rel="noopener noreferrer" target="_blank">🖍️修改</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                
				<span class="details">文章目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#monday" aria-label="Monday">Monday</a><ul>
                            
                    <li>
                        <a href="#102%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="102.二叉树的层序遍历">102.二叉树的层序遍历</a></li>
                    <li>
                        <a href="#107%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86ii" aria-label="107.二叉树的层次遍历II">107.二叉树的层次遍历II</a></li>
                    <li>
                        <a href="#199%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be" aria-label="199.二叉树的右视图"><strong><strong>199.二叉树的右视图</strong></strong></a></li>
                    <li>
                        <a href="#637%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%b9%b3%e5%9d%87%e5%80%bc" aria-label="637.二叉树的层平均值"><strong><strong>637.二叉树的层平均值</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#tuesday" aria-label="Tuesday">Tuesday</a><ul>
                            
                    <li>
                        <a href="#429n%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="429.N叉树的层序遍历"><strong><strong>429.N叉树的层序遍历</strong></strong></a></li>
                    <li>
                        <a href="#515%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%a0%91%e8%a1%8c%e4%b8%ad%e6%89%be%e6%9c%80%e5%a4%a7%e5%80%bc" aria-label="515.在每个树行中找最大值"><strong><strong>515.在每个树行中找最大值</strong></strong></a></li>
                    <li>
                        <a href="#116%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88" aria-label="116.填充每个节点的下一个右侧节点指针"><strong><strong>116.填充每个节点的下一个右侧节点指针</strong></strong></a></li>
                    <li>
                        <a href="#117%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88ii" aria-label="117.填充每个节点的下一个右侧节点指针II"><strong><strong>117.填充每个节点的下一个右侧节点指针II</strong></strong></a></li>
                    <li>
                        <a href="#104%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6" aria-label="104.二叉树的最大深度"><strong><strong>104.二叉树的最大深度</strong></strong></a></li>
                    <li>
                        <a href="#111%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e6%b7%b1%e5%ba%a6" aria-label="111.二叉树的最小深度"><strong><strong>111.二叉树的最小深度</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#wednesday" aria-label="Wednesday">Wednesday</a><ul>
                            
                    <li>
                        <a href="#226%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="226.翻转二叉树"><strong><strong>226.翻转二叉树</strong></strong></a></li>
                    <li>
                        <a href="#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="101. 对称二叉树"><strong><strong>101. 对称二叉树</strong></strong></a></li>
                    <li>
                        <a href="#100%e7%9b%b8%e5%90%8c%e7%9a%84%e6%a0%91" aria-label="100.相同的树">100.相同的树</a></li>
                    <li>
                        <a href="#572%e5%8f%a6%e4%b8%80%e4%b8%aa%e6%a0%91%e7%9a%84%e5%ad%90%e6%a0%91" aria-label="572.另一个树的子树">572.另一个树的子树</a></li>
                    <li>
                        <a href="#222%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0" aria-label="222.完全二叉树的节点个数"><strong><strong>222.完全二叉树的节点个数</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#thursday" aria-label="Thursday">Thursday</a><ul>
                            
                    <li>
                        <a href="#110%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="110.平衡二叉树"><strong><strong>110.平衡二叉树</strong></strong></a></li>
                    <li>
                        <a href="#257-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%89%80%e6%9c%89%e8%b7%af%e5%be%84" aria-label="257. 二叉树的所有路径"><strong><strong>257. 二叉树的所有路径</strong></strong></a></li>
                    <li>
                        <a href="#404%e5%b7%a6%e5%8f%b6%e5%ad%90%e4%b9%8b%e5%92%8c" aria-label="404.左叶子之和"><strong><strong>404.左叶子之和</strong></strong></a></li>
                    <li>
                        <a href="#513%e6%89%be%e6%a0%91%e5%b7%a6%e4%b8%8b%e8%a7%92%e7%9a%84%e5%80%bc" aria-label="513.找树左下角的值"><strong><strong>513.找树左下角的值</strong></strong></a></li>
                    <li>
                        <a href="#112-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c" aria-label="112. 路径总和"><strong><strong>112. 路径总和</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#friday" aria-label="Friday">Friday</a><ul>
                            
                    <li>
                        <a href="#113-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-ll" aria-label="113. 路径总和 ll"><strong><strong>113. 路径总和 ll</strong></strong></a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="monday">Monday<a hidden class="anchor" aria-hidden="true" href="#monday">#</a></h2>
<h3 id="102二叉树的层序遍历">102.二叉树的层序遍历<a hidden class="anchor" aria-hidden="true" href="#102二叉树的层序遍历">#</a></h3>
<p><strong>递归思路</strong>：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。
是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。</p>
<p>这题二刷肯定思路从0开始，大家都这样，不要放弃！！！</p>
<p><strong>迭代思路(推荐)</strong>：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。</p>
<h3 id="107二叉树的层次遍历ii">107.二叉树的层次遍历II<a hidden class="anchor" aria-hidden="true" href="#107二叉树的层次遍历ii">#</a></h3>
<p>就是用上题的迭代再反转，反转就把装有ArrayList<Integer>的 list 从尾到头的 add 到另一个 result 就行。</p>
<h3 id="199二叉树的右视图"><strong><strong>199.二叉树的右视图</strong></strong><a hidden class="anchor" aria-hidden="true" href="#199二叉树的右视图">#</a></h3>
<p>利用层序迭代遍历留住每层的最后一个元素值。</p>
<h3 id="637二叉树的层平均值"><strong><strong>637.二叉树的层平均值</strong></strong><a hidden class="anchor" aria-hidden="true" href="#637二叉树的层平均值">#</a></h3>
<p>还是层序遍历。</p>
<hr>
<h2 id="tuesday">Tuesday<a hidden class="anchor" aria-hidden="true" href="#tuesday">#</a></h2>
<h3 id="429n叉树的层序遍历"><strong><strong>429.N叉树的层序遍历</strong></strong><a hidden class="anchor" aria-hidden="true" href="#429n叉树的层序遍历">#</a></h3>
<p>主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。</p>
<h3 id="515在每个树行中找最大值"><strong><strong>515.在每个树行中找最大值</strong></strong><a hidden class="anchor" aria-hidden="true" href="#515在每个树行中找最大值">#</a></h3>
<p>类似层序遍历留住最后一个元素。</p>
<h3 id="116填充每个节点的下一个右侧节点指针"><strong><strong>116.填充每个节点的下一个右侧节点指针</strong></strong><a hidden class="anchor" aria-hidden="true" href="#116填充每个节点的下一个右侧节点指针">#</a></h3>
<p><strong>思路</strong>：很简单，自己用层序遍历套娃。</p>
<p><strong>注意</strong>：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：</p>
<p>需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。</p>
<h3 id="117填充每个节点的下一个右侧节点指针ii"><strong><strong>117.填充每个节点的下一个右侧节点指针II</strong></strong><a hidden class="anchor" aria-hidden="true" href="#117填充每个节点的下一个右侧节点指针ii">#</a></h3>
<p>和116的差距就是这里不是完全二叉树，逻辑代码都一样。</p>
<h3 id="104二叉树的最大深度"><strong><strong>104.二叉树的最大深度</strong></strong><a hidden class="anchor" aria-hidden="true" href="#104二叉树的最大深度">#</a></h3>
<p>做了前面的还不会请自行gg&hellip;..</p>
<h3 id="111二叉树的最小深度"><strong><strong>111.二叉树的最小深度</strong></strong><a hidden class="anchor" aria-hidden="true" href="#111二叉树的最小深度">#</a></h3>
<p>有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。</p>
<p><strong>注意</strong>：一定要在第一步判空:     if(root == null)   &hellip;&hellip;&hellip;&hellip;..</p>
<hr>
<h2 id="wednesday">Wednesday<a hidden class="anchor" aria-hidden="true" href="#wednesday">#</a></h2>
<h3 id="226翻转二叉树"><strong><strong>226.翻转二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#226翻转二叉树">#</a></h3>
<p><strong>递归</strong>：确定参数类型、返回值 —&gt; 确定终止条件 —&gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。</p>
<p>层序遍历在内层循环也能处理。</p>
<h3 id="101-对称二叉树"><strong><strong>101. 对称二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#101-对称二叉树">#</a></h3>
<p>不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。</p>
<p><strong>递归</strong>很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。</p>
<p><strong>迭代</strong>：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。</p>
<p>其实还是迭代更具普适性。</p>
<h3 id="100相同的树">100.相同的树<a hidden class="anchor" aria-hidden="true" href="#100相同的树">#</a></h3>
<p><strong>递归</strong>：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 &amp;&amp;。</p>
<p><strong>迭代</strong>：同101。</p>
<h3 id="572另一个树的子树">572.另一个树的子树<a hidden class="anchor" aria-hidden="true" href="#572另一个树的子树">#</a></h3>
<p>据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。</p>
<p><strong>注意</strong>：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！</p>
<h3 id="222完全二叉树的节点个数"><strong><strong>222.完全二叉树的节点个数</strong></strong><a hidden class="anchor" aria-hidden="true" href="#222完全二叉树的节点个数">#</a></h3>
<p>迭代：一个循环粗糙层序遍历。</p>
<p>递归：return 1+左递归+右递归。</p>
<p><strong>注意</strong>：用 offer 要判空“值”，poll 不需要判空“队列”。</p>
<hr>
<h2 id="thursday">Thursday<a hidden class="anchor" aria-hidden="true" href="#thursday">#</a></h2>
<h3 id="110平衡二叉树"><strong><strong>110.平衡二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#110平衡二叉树">#</a></h3>
<p><strong>思路</strong>：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。</p>
<p><strong>注意</strong>：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。</p>
<p><strong>拓展</strong>：bfs 万精油， dfs 前序求深度，后序求高度。</p>
<h3 id="257-二叉树的所有路径"><strong><strong>257. 二叉树的所有路径</strong></strong><a hidden class="anchor" aria-hidden="true" href="#257-二叉树的所有路径">#</a></h3>
<p><strong>思路</strong>：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。</p>
<h3 id="404左叶子之和"><strong><strong>404.左叶子之和</strong></strong><a hidden class="anchor" aria-hidden="true" href="#404左叶子之和">#</a></h3>
<p><strong>思路</strong>：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。</p>
<p><strong>注意</strong>：一定要判断是否为叶子结点，是求<strong>左叶子</strong>结点和，不是左节点和。</p>
<h3 id="513找树左下角的值"><strong><strong>513.找树左下角的值</strong></strong><a hidden class="anchor" aria-hidden="true" href="#513找树左下角的值">#</a></h3>
<p><strong>思路</strong>：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！</p>
<h3 id="112-路径总和"><strong><strong>112. 路径总和</strong></strong><a hidden class="anchor" aria-hidden="true" href="#112-路径总和">#</a></h3>
<p><strong>思路</strong>：主要就是递归+回溯，和257差不多。</p>
<p>注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。</p>
 <hr>
<h2 id="friday">Friday<a hidden class="anchor" aria-hidden="true" href="#friday">#</a></h2>
<h3 id="113-路径总和-ll"><strong><strong>113. 路径总和 ll</strong></strong><a hidden class="anchor" aria-hidden="true" href="#113-路径总和-ll">#</a></h3>
<p><strong>思路</strong>：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。</p>
<p><strong>注意</strong>：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。</p>
<hr>
<p>持续更新&hellip;&hellip;.<br>
如有错误，敬请斧正！！！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://coderrenxy.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/">
    <span class="title">« 上一篇</span>
    <br>
    <span>LeetCode 一周小记 No.5</span>
  </a>
  <a class="next" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.3/">
    <span class="title">下一篇 »</span>
    <br>
    <span>LeetCode 一周小记 No.3</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<script src="https://utteranc.es/client.js"
repo="coderRenxy/coderrenxy.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>

<footer class="footer">
    <span>&copy; 2024 <a href="https://coderrenxy.github.io/">小任同学&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
	<span id="busuanzi_container_site_pv">
    访问量：<span id="busuanzi_value_site_pv"></span>次
</span>
&nbsp;
<span id="busuanzi_container_site_uv">
    您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
</span>
<hr>


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
 <div>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


</body>

</html>

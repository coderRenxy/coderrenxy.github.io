<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode 一周小记 No.5 | 小任同学&#39;s Blog</title>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="keywords" content="算法" />
<meta name="description" content="Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后">
<meta name="author" content="
作者:&nbsp;小任同学">
<link rel="canonical" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7623b46c5149f45c86bb2cab2316266b62404755c0674d3e97963430d13b957e.css" integrity="sha256-diO0bFFJ9FyGuyyrIxYma2JAR1XAZ00&#43;l5Y0MNE7lX4=" rel="preload stylesheet" as="style">
<link rel="preload" href="img/icon-32.png" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://coderrenxy.github.io/icon-512.png">
<link rel="apple-touch-icon" href="https://coderrenxy.github.io/icon-512.png">
<link rel="mask-icon" href="https://coderrenxy.github.io/icon-512.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="LeetCode 一周小记 No.5" />
<meta property="og:description" content="Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-31T05:13:32&#43;08:00" />
<meta property="article:modified_time" content="2022-05-02T23:33:37&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 一周小记 No.5"/>
<meta name="twitter:description" content="Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://coderrenxy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📋 技术",
      "item": "https://coderrenxy.github.io/posts/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "LeetCode 一周小记 No.5",
      "item": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode 一周小记 No.5",
  "name": "LeetCode 一周小记 No.5",
  "description": "Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后",
  "keywords": [
    "算法"
  ],
  "articleBody": "Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 [) 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n Tuesday 654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if … else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left  right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\nWednesday 617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略……\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子…….）、右子树的最左后代是值最接近根节点的结点。\n Thursday 501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List list1 = new ArrayList(); List list2 = new ArrayList(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; ifor(int j=0; jif(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026\u0026 right != null) return root; if(left != null \u0026\u0026 right == null) return left; if(left == null \u0026\u0026 right != null) return right; return null; } }     Friday 235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7 8  class Solution { TreeNode node = null; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val  p.val \u0026\u0026 root.val  q.val) return lowestCommonAncestor(root.left , p, q); if(root.val return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val  target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为  \\ 1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val  root.val) root.right = insertIntoBST(root.right, val); if(val return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026\u0026 root.left == null \u0026\u0026 root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val  key) root.left = deleteNode1(root.left , key); if(root.val if(root.val == key){ if(root.right != null \u0026\u0026 root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026\u0026 root.left == null){ return root.right; }else if(root.right == null \u0026\u0026 root.left != null){ return root.left; }else{ return null; } } return root; } }    持续更新…….\n如有错误，敬请斧正！！！\n",
  "wordCount" : "2739",
  "inLanguage": "en",
  "datePublished": "2022-03-31T05:13:32+08:00",
  "dateModified": "2022-05-02T23:33:37+08:00",
  "author":[{
    "@type": "Person",
    "name": "小任同学"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "小任同学's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://coderrenxy.github.io/img/icon-512.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://coderrenxy.github.io/" accesskey="h" title="小任同学&#39;s Blog (Alt + H)">
                <img src="https://coderrenxy.github.io/img/icon-32.png" alt="logo" aria-label="logo"
                    height=" 30px">小任同学&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://coderrenxy.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/search/" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://coderrenxy.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/blog/">📋 技术</a></div>
    <h1 class="post-title">
      LeetCode 一周小记 No.5
    </h1>
    <div class="post-meta">
			<p id="wc" style="font-size: 12px;">本文总阅读量<span id="busuanzi_value_page_pv"></span>次&nbsp;&nbsp;</p>











创建:&nbsp;<span title='2022-03-31 05:13:32 +0800 CST'>2022-03-31</span>&nbsp;|&nbsp;更新:&nbsp;2022-05-02&nbsp;|&nbsp;字数:&nbsp;2739字&nbsp;|&nbsp;时长: 6分钟&nbsp;|&nbsp;
作者:&nbsp;小任同学&nbsp;|&nbsp;<a href="https://github.com/coderRenxy/coderrenxy.github.io/content/posts/blog/LeetCode%20%e4%b8%80%e5%91%a8%e5%b0%8f%e8%ae%b0%20No.5.md" rel="noopener noreferrer" target="_blank">🖍️修改</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                
				<span class="details">文章目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#monday" aria-label="Monday">Monday</a><ul>
                            
                    <li>
                        <a href="#106%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="106.从中序与后序遍历序列构造二叉树"><strong><strong>106.从中序与后序遍历序列构造二叉树</strong></strong></a></li>
                    <li>
                        <a href="#105%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="105.从前序与中序遍历序列构造二叉树"><strong><strong>105.从前序与中序遍历序列构造二叉树</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#tuesday" aria-label="Tuesday">Tuesday</a><ul>
                            
                    <li>
                        <a href="#654%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="654.最大二叉树"><strong><strong>654.最大二叉树</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#wednesday" aria-label="Wednesday">Wednesday</a><ul>
                            
                    <li>
                        <a href="#617%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="617.合并二叉树"><strong><strong>617.合并二叉树</strong></strong></a></li>
                    <li>
                        <a href="#700%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2" aria-label="700.二叉搜索树中的搜索"><strong><strong>700.二叉搜索树中的搜索</strong></strong></a></li>
                    <li>
                        <a href="#98%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="98.验证二叉搜索树"><strong><strong>98.验证二叉搜索树</strong></strong></a></li>
                    <li>
                        <a href="#530%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e7%bb%9d%e5%af%b9%e5%b7%ae" aria-label="530.二叉搜索树的最小绝对差"><strong><strong>530.二叉搜索树的最小绝对差</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#thursday" aria-label="Thursday">Thursday</a><ul>
                            
                    <li>
                        <a href="#501%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e4%bc%97%e6%95%b0" aria-label="501.二叉搜索树中的众数"><strong><strong>501.二叉搜索树中的众数</strong></strong></a></li>
                    <li>
                        <a href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="236. 二叉树的最近公共祖先"><strong><strong>236. 二叉树的最近公共祖先</strong></strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#friday" aria-label="Friday">Friday</a><ul>
                            
                    <li>
                        <a href="#235-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="235. 二叉搜索树的最近公共祖先"><strong><strong>235. 二叉搜索树的最近公共祖先</strong></strong></a></li>
                    <li>
                        <a href="#701%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c" aria-label="701.二叉搜索树中的插入操作"><strong><strong>701.二叉搜索树中的插入操作</strong></strong></a></li>
                    <li>
                        <a href="#450%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9" aria-label="450.删除二叉搜索树中的节点"><strong><strong>450.删除二叉搜索树中的节点</strong></strong></a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="monday">Monday<a hidden class="anchor" aria-hidden="true" href="#monday">#</a></h2>
<h3 id="106从中序与后序遍历序列构造二叉树"><strong><strong>106.从中序与后序遍历序列构造二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#106从中序与后序遍历序列构造二叉树">#</a></h3>
<p><strong>key1</strong>：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。</p>
<p><strong>key2</strong>：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。</p>
<p><strong>key3：</strong></p>
<ol>
<li>****后序中结点分布应该是：[左子树结点，右子树结点，根结点]；</li>
<li>中序中结点分布应该是：[左子树结点，根结点，右子树结点]；</li>
<li>左右子树的节点分别去左右子树匹配；</li>
</ol>
<p><strong>key4</strong>：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 [) 的话传入的参数应该是0、leng、0、leng。切割处理也不同。</li>
<li>后序要抠掉最后一个结点，因为这个结点 new 出来了。</li>
</ol>
<h3 id="105从前序与中序遍历序列构造二叉树"><strong><strong>105.从前序与中序遍历序列构造二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#105从前序与中序遍历序列构造二叉树">#</a></h3>
<p>同 106 所述，就是抠的是左边界。</p>
<hr>
<h2 id="tuesday">Tuesday<a hidden class="anchor" aria-hidden="true" href="#tuesday">#</a></h2>
<h3 id="654最大二叉树"><strong><strong>654.最大二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#654最大二叉树">#</a></h3>
<p><strong>错误</strong>思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if &hellip; else 把出现次数多的放在 if 中。错在题意理解上。</p>
<p><strong>正确</strong>思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left &gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();</p>
<p>注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。<hr></p>
<h2 id="wednesday">Wednesday<a hidden class="anchor" aria-hidden="true" href="#wednesday">#</a></h2>
<h3 id="617合并二叉树"><strong><strong>617.合并二叉树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#617合并二叉树">#</a></h3>
<p><strong>思路</strong>：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。</p>
<p><strong>注意</strong>：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。</p>
<h3 id="700二叉搜索树中的搜索"><strong><strong>700.二叉搜索树中的搜索</strong></strong><a hidden class="anchor" aria-hidden="true" href="#700二叉搜索树中的搜索">#</a></h3>
<p>略&hellip;&hellip;</p>
<h3 id="98验证二叉搜索树"><strong><strong>98.验证二叉搜索树</strong></strong><a hidden class="anchor" aria-hidden="true" href="#98验证二叉搜索树">#</a></h3>
<p>中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。</p>
<h3 id="530二叉搜索树的最小绝对差"><strong><strong>530.二叉搜索树的最小绝对差</strong></strong><a hidden class="anchor" aria-hidden="true" href="#530二叉搜索树的最小绝对差">#</a></h3>
<p>暴力解法：直接遍历出 list，再递归左右子树去遍历差值。</p>
<p>优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子&hellip;&hellip;.）、右子树的最左后代是值最接近根节点的结点。</p>
<hr>
<h2 id="thursday">Thursday<a hidden class="anchor" aria-hidden="true" href="#thursday">#</a></h2>
<h3 id="501二叉搜索树中的众数"><strong><strong>501.二叉搜索树中的众数</strong></strong><a hidden class="anchor" aria-hidden="true" href="#501二叉搜索树中的众数">#</a></h3>
<p><strong>暴力</strong>解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。</p>
<p>注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。</p>
<p><strong>迭代</strong>法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。</p>
<h3 id="236-二叉树的最近公共祖先"><strong><strong>236. 二叉树的最近公共祖先</strong></strong><a hidden class="anchor" aria-hidden="true" href="#236-二叉树的最近公共祖先">#</a></h3>
<p><strong>暴力</strong>解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
        TreeNode node = root;
        List&lt;TreeNode&gt; list1 = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        List&lt;TreeNode&gt; list2 = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        getPath(list1, root, p);
        getPath(list2, root, q);
        <span style="color:#5f8700">for</span>(<span style="color:#af0000">int</span> i=0; i&lt;list1.size(); i++){
            <span style="color:#5f8700">for</span>(<span style="color:#af0000">int</span> j=0; j&lt;list2.size(); j++){
                <span style="color:#5f8700">if</span>(list1.get(i).val == list2.get(j).val)
                    node = list1.get(i);
            }
        }
        <span style="color:#5f8700">return</span> node;
    }
    <span style="color:#0087ff">public</span> <span style="color:#af0000">boolean</span> <span style="color:#0087ff">getPath</span>(List&lt;TreeNode&gt; list, TreeNode root, TreeNode target){
        <span style="color:#5f8700">if</span>(root.val == target.val){
            list.add(target);
            <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>; 
        }
        <span style="color:#5f8700">if</span>(root.left != <span style="color:#d75f00">null</span>){
            list.add(root);
            <span style="color:#5f8700">if</span>(getPath(list, root.left, target)) <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>;
            list.remove(root);
        }
        <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span>){
            list.add(root);
            <span style="color:#5f8700">if</span>(getPath(list, root.right, target)) <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>;
            list.remove(root);
        }
        <span style="color:#5f8700">return</span> <span style="color:#d75f00">false</span>;
    }
}
</code></pre></td></tr></table>
</div>
</div><p>最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {<span style="color:#4e4e4e">//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。
</span><span style="color:#4e4e4e"></span>        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span> || root == p || root == q)    <span style="color:#5f8700">return</span> root;<span style="color:#4e4e4e">//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）
</span><span style="color:#4e4e4e"></span>        TreeNode left = lowestCommonAncestor(root.left, p, q);<span style="color:#4e4e4e">//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点
</span><span style="color:#4e4e4e"></span>        TreeNode right = lowestCommonAncestor(root.right, p, q);<span style="color:#4e4e4e">//右子树去遍历寻找p、q
</span><span style="color:#4e4e4e"></span>        <span style="color:#4e4e4e">//具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。
</span><span style="color:#4e4e4e"></span>        <span style="color:#5f8700">if</span>(left != <span style="color:#d75f00">null</span> &amp;&amp; right != <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> root;
        <span style="color:#5f8700">if</span>(left != <span style="color:#d75f00">null</span> &amp;&amp; right == <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> left;
        <span style="color:#5f8700">if</span>(left == <span style="color:#d75f00">null</span> &amp;&amp; right != <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> right;
        <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
    }
}
</code></pre></td></tr></table>
</div>
</div> <hr>
<h2 id="friday">Friday<a hidden class="anchor" aria-hidden="true" href="#friday">#</a></h2>
<h3 id="235-二叉搜索树的最近公共祖先"><strong><strong>235. 二叉搜索树的最近公共祖先</strong></strong><a hidden class="anchor" aria-hidden="true" href="#235-二叉搜索树的最近公共祖先">#</a></h3>
<p><strong>key</strong>：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    TreeNode node = <span style="color:#d75f00">null</span>;
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
        <span style="color:#5f8700">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)    <span style="color:#5f8700">return</span> lowestCommonAncestor(root.left , p, q);
        <span style="color:#5f8700">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)    <span style="color:#5f8700">return</span> lowestCommonAncestor(root.right, p, q);
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="701二叉搜索树中的插入操作"><strong><strong>701.二叉搜索树中的插入操作</strong></strong><a hidden class="anchor" aria-hidden="true" href="#701二叉搜索树中的插入操作">#</a></h3>
<p><strong>key</strong>：如果 root.val &gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 &gt; \ &lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">insertIntoBST</span>(TreeNode root, <span style="color:#af0000">int</span> val) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#5f8700">new</span> TreeNode(val);
        <span style="color:#5f8700">if</span>(val &gt; root.val)  root.right = insertIntoBST(root.right, val);
        <span style="color:#5f8700">if</span>(val &lt; root.val)  root.left  = insertIntoBST(root.left , val);
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="450删除二叉搜索树中的节点"><strong><strong>450.删除二叉搜索树中的节点</strong></strong><a hidden class="anchor" aria-hidden="true" href="#450删除二叉搜索树中的节点">#</a></h3>
<p>当找到了删除节点时：</p>
<p><strong>key1</strong>：当删除节点的左右节点都为 null，return null；</p>
<p><strong>key2</strong>：当删除结点都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。</p>
<p><strong>key3</strong>：当 root.left or root.right 为 null，return 不为空的结点。</p>
<p>否则就递归并将返回为左右孩子。</p>
<p><strong>code</strong>：</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">deleteNode</span>(TreeNode root, <span style="color:#af0000">int</span> key) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span> || (root.val == key &amp;&amp; root.left == <span style="color:#d75f00">null</span> &amp;&amp; root.right ==<span style="color:#d75f00">null</span>))   
						<span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>; 
        <span style="color:#5f8700">return</span> deleteNode1(root, key);
    }
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">deleteNode1</span>(TreeNode root, <span style="color:#af0000">int</span> key) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
        <span style="color:#5f8700">if</span>(root.val &gt; key)  root.left  = deleteNode1(root.left , key);
        <span style="color:#5f8700">if</span>(root.val &lt; key)  root.right = deleteNode1(root.right, key);
        <span style="color:#5f8700">if</span>(root.val == key){ 
            <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span> &amp;&amp; root.left != <span style="color:#d75f00">null</span>){
                <span style="color:#4e4e4e">//无论该处是否为null，都将root.right传进来取root.right最左祖孙。
</span><span style="color:#4e4e4e"></span>                TreeNode temp = root.right;<span style="color:#4e4e4e">//6
</span><span style="color:#4e4e4e"></span>                <span style="color:#5f8700">while</span>(temp.left != <span style="color:#d75f00">null</span>)<span style="color:#4e4e4e">//找到最左祖孙。
</span><span style="color:#4e4e4e"></span>                    temp = temp.left;
                temp.left = root.left;
                <span style="color:#5f8700">return</span> root.right;
            }<span style="color:#5f8700">else</span> <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span> &amp;&amp; root.left == <span style="color:#d75f00">null</span>){
                <span style="color:#5f8700">return</span> root.right; 
            }<span style="color:#5f8700">else</span> <span style="color:#5f8700">if</span>(root.right == <span style="color:#d75f00">null</span> &amp;&amp; root.left != <span style="color:#d75f00">null</span>){
                <span style="color:#5f8700">return</span> root.left;
            }<span style="color:#5f8700">else</span>{
                <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
            }
        }
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><hr>
<p>持续更新&hellip;&hellip;.<br>
如有错误，敬请斧正！！！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://coderrenxy.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://coderrenxy.github.io/posts/blog/mybatis/">
    <span class="title">« 上一篇</span>
    <br>
    <span>Mybatis</span>
  </a>
  <a class="next" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/">
    <span class="title">下一篇 »</span>
    <br>
    <span>LeetCode 一周小记 No.4</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<script src="https://utteranc.es/client.js"
repo="coderRenxy/coderrenxy.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>

<footer class="footer">
    <span>&copy; 2025 <a href="https://coderrenxy.github.io/">小任同学&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
	<span id="busuanzi_container_site_pv">
    访问量：<span id="busuanzi_value_site_pv"></span>次
</span>
&nbsp;
<span id="busuanzi_container_site_uv">
    您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
</span>
<hr>


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
 <div>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


</body>

</html>

<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode 二叉树(二) | 小任同学&#39;s Blog</title>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="keywords" content="算法" />
<meta name="description" content="二叉树模块二刷。">
<meta name="author" content="
作者:&nbsp;小任同学">
<link rel="canonical" href="https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7623b46c5149f45c86bb2cab2316266b62404755c0674d3e97963430d13b957e.css" integrity="sha256-diO0bFFJ9FyGuyyrIxYma2JAR1XAZ00&#43;l5Y0MNE7lX4=" rel="preload stylesheet" as="style">
<link rel="preload" href="img/icon-32.png" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://coderrenxy.github.io/img/icon-512.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://coderrenxy.github.io/icon-512.png">
<link rel="apple-touch-icon" href="https://coderrenxy.github.io/icon-512.png">
<link rel="mask-icon" href="https://coderrenxy.github.io/icon-512.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="LeetCode 二叉树(二)" />
<meta property="og:description" content="二叉树模块二刷。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-01T09:29:42&#43;08:00" />
<meta property="article:modified_time" content="2022-09-01T23:58:37&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 二叉树(二)"/>
<meta name="twitter:description" content="二叉树模块二刷。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://coderrenxy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📋 技术",
      "item": "https://coderrenxy.github.io/posts/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "LeetCode 二叉树(二)",
      "item": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode 二叉树(二)",
  "name": "LeetCode 二叉树(二)",
  "description": "二叉树模块二刷。",
  "keywords": [
    "算法"
  ],
  "articleBody": "前置知识填充篇：\n满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。\n完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。\n二叉搜索树：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。\n平衡二叉树（AVL）：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。\n二叉树的存储：\n二叉树可以链式存储，也可以顺序存储。\n链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历：\n 深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。 广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）  144.二叉树的前序遍历 \u0026 145.二叉树的后序遍历 \u0026 94.二叉树的中序遍历 递归做法：三个遍历一个方法代码挪一下位置。\n迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。\n注意：\n 迭代中序是复杂点，不断地往左推，到最左再依次弹出，弹出要注意父节点的 right 有没有，就这条思路。 后序 不是 直接 前序 倒转，而是把 前序 的左右孩子入栈顺序倒转再 反转。 前序：中左右。 后序：左右中。前序调转入栈顺序：中右左，反转：左右中=后序。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution {//中序遍历  public List inorderTraversal(TreeNode root) { List list = new ArrayList(); if(root == null) return list; Stack stack = new Stack(); TreeNode cur = root; while(cur != null || !stack.isEmpty()){ if(cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); list.add(cur.val); cur = cur.right; } } return list; } }   102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。\n是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n二刷思路：用 deep 和 list 的 size 来判断是否需要 new 新的 listSon。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { List list; public List levelOrder(TreeNode root) { list = new ArrayList(); bfs(root,0); return list; } public void bfs(TreeNode root,int deep){ if(root == null) return; deep++; if(list.size() item = new ArrayList(); list.add(item); } list.get(deep-1).add(root.val); bfs(root.left,deep); bfs(root.right,deep); } }   迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n二刷思路：把 root 放进去队列，poll 出来 add(val)，然后放入左右孩子，poll 出来 add(val)。一层孩子 new 一个 list，而结束条件是 !queue.isEmpty() ，控制层层分离的则是 最初操作的 queue.size() 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public List levelOrder(TreeNode root) { List list = new ArrayList(); if(root == null) return list; Queue queue = new LinkedList(); queue.offer(root); TreeNode temp = null; while(!queue.isEmpty()){ List listSon = new ArrayList(); int len = queue.size(); while(len  0){ temp = queue.poll(); listSon.add(temp.val); if(temp.left != null) queue.offer(temp.left); if(temp.right != null) queue.offer(temp.right); len--; } list.add(listSon); } return list; } }   107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n//需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg…..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) …………..\n226.翻转二叉树 递归：确定参数类型、返回值 — 确定终止条件 — 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026\u0026。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n二刷：实在没想到思路，竟然是这样。递归一个求深度方法；\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n二刷：主要就是用左右孩子为空当作依据来操作，先去 List 出来 path ，再去操作字符串，不然append(root.left.val).append(”→”) 这样很难回溯。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 ”左闭右开“ 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n二刷构建树 前序：[root,root.left,root.right]\n中序：[root.left,root,root.right]\n后序：[root.left,root.right,root]\n前序遍历的第一个，后序遍历的最后一个元素就是树的根节点，根据这根节点可以在 中序遍历 中找到 val 相同的节点，也就是这棵树的根节点，这个节点的左边就是左子树的所有节点，右边就是右子树的所有结点。这样我们知道了左右子树各自的节点个数。根据前序数组，root,左子树所有节点，右子树所有节点，可以拿到左子树的所有节点的前序遍历、右子树所有节点的后序遍历，继续递归。后序遍历同理。结束条件是中序 left  right,left == right 时 new这个节点。\n654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if … else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left  right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\n二刷：类似建树，比建树简单多了。\n617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略……\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子…….）、右子树的最左后代是值最接近根节点的结点。\n二刷：左子树最右子节点的递归方法，右子树最左子节点的递归方法。\n501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List list1 = new ArrayList(); List list2 = new ArrayList(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; ifor(int j=0; jif(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026\u0026 right != null) return root; if(left != null \u0026\u0026 right == null) return left; if(left == null \u0026\u0026 right != null) return right; return null; } }   二刷：从root向下找如果找到了p||q就return，否则就向下遍历，递归到了最深处还没找到返回值就是null，把左边找到的值用 left 传递，没找到就是 null 返回，然后做判断，左右孩子都是null就返回null，找到 p、q 任意一个都返回，也就是 left、right 会层层传递，左右孩子都不为空就返回 root。\n235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val  p.val \u0026\u0026 root.val  q.val) return lowestCommonAncestor(root.left , p, q); if(root.val return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val  target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为  \\ 1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val  root.val) root.right = insertIntoBST(root.right, val); if(val return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点左右孩子都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026\u0026 root.left == null \u0026\u0026 root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val  key) root.left = deleteNode1(root.left , key); if(root.val if(root.val == key){ if(root.right != null \u0026\u0026 root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026\u0026 root.left == null){ return root.right; }else if(root.right == null \u0026\u0026 root.left != null){ return root.left; }else{ return null; } } return root; } }   二刷：root.right 节点当作新的 root，root.left 变成 root.right 的最左节点的孩子\n注意：用 root.left = 递归(root.left , key) 的方式，来传递，这样才能把 key 对应的 node 删除并且 让 node 的父节点去链接 noder.right 节点。找右孩子的最左祖孙时可以 while 循环来找。\n669. 修剪二叉搜索树 思路：分别处理不正常结点，正常的节点。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null) return null; //处理不正常的节点  if(root.val return trimBST(root.right, low, high); if(root.val  high) return trimBST(root.left , low, high); //处理正常节点  root.left = trimBST(root.left , low, high); root.right = trimBST(root.right, low, high); return root; } }   108.将有序数组转换为二叉搜索树 思路：分别递归左右区间\n注意：\n 左右开闭一定要统一起来，我都是都闭着。 左右区间去递归一个方法。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public TreeNode sortedArrayToBST(int[] nums) { return method1(nums, 0, nums.length-1); } public TreeNode method1(int[] nums,int left,int right){ if(left  right) return null; if(left == right) return new TreeNode(nums[left]); int mid = left + (right-left)/2; TreeNode root = new TreeNode(nums[mid]); root.left = method1(nums, left, mid-1); root.right = method1(nums, mid+1, right); return root; } }   538.把二叉搜索树转换为累加树 思路：这道题最难的就是看懂题，如果换成数组看就比较好看出来，从右下角的 right 到 root 到 left。相当于就是一个反转了的中序 dfs。\n二刷：最难的是题意，注意，变化后左子树也变成了左孩子大于右孩子，已经不是二叉搜索树了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { dfs(root); return root; } public void dfs(TreeNode root){ if(root == null) return ; dfs(root.right); sum+=root.val; root.val = sum; dfs(root.left); } }   持续更新…….\n如有错误，敬请斧正！！！\n",
  "wordCount" : "6974",
  "inLanguage": "en",
  "datePublished": "2022-09-01T09:29:42+08:00",
  "dateModified": "2022-09-01T23:58:37+08:00",
  "author":[{
    "@type": "Person",
    "name": "小任同学"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "小任同学's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://coderrenxy.github.io/img/icon-512.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://coderrenxy.github.io/" accesskey="h" title="小任同学&#39;s Blog (Alt + H)">
                <img src="https://coderrenxy.github.io/img/icon-32.png" alt="logo" aria-label="logo"
                    height=" 30px">小任同学&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://coderrenxy.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/search/" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://coderrenxy.github.io/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://coderrenxy.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://coderrenxy.github.io/posts/blog/">📋 技术</a></div>
    <h1 class="post-title">
      LeetCode 二叉树(二)
    </h1>
    <div class="post-description">
      二叉树模块二刷。
    </div>
    <div class="post-meta">
			<p id="wc" style="font-size: 12px;">本文总阅读量<span id="busuanzi_value_page_pv"></span>次&nbsp;&nbsp;</p>











创建:&nbsp;<span title='2022-09-01 09:29:42 +0800 CST'>2022-09-01</span>&nbsp;|&nbsp;更新:&nbsp;2022-09-01&nbsp;|&nbsp;字数:&nbsp;6974字&nbsp;|&nbsp;时长: 14分钟&nbsp;|&nbsp;
作者:&nbsp;小任同学&nbsp;|&nbsp;<a href="https://github.com/coderRenxy/coderrenxy.github.io/content/posts/blog/LeetCode%20%e4%ba%8c%e5%8f%89%e6%a0%91%ef%bc%88%e4%ba%8c%ef%bc%89.md" rel="noopener noreferrer" target="_blank">🖍️修改</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                
				<span class="details">文章目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#144%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86--145%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86---94%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="144.二叉树的前序遍历 &amp;amp; 145.二叉树的后序遍历 &amp;amp;  94.二叉树的中序遍历">144.二叉树的前序遍历 &amp; 145.二叉树的后序遍历 &amp;  94.二叉树的中序遍历</a></li>
                    <li>
                        <a href="#102%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="102.二叉树的层序遍历">102.二叉树的层序遍历</a></li>
                    <li>
                        <a href="#107%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86ii" aria-label="107.二叉树的层次遍历II">107.二叉树的层次遍历II</a></li>
                    <li>
                        <a href="#199%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be" aria-label="199.二叉树的右视图">199.二叉树的右视图</a></li>
                    <li>
                        <a href="#637%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%b9%b3%e5%9d%87%e5%80%bc" aria-label="637.二叉树的层平均值">637.二叉树的层平均值</a></li>
                    <li>
                        <a href="#429n%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="429.N叉树的层序遍历">429.N叉树的层序遍历</a></li>
                    <li>
                        <a href="#515%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%a0%91%e8%a1%8c%e4%b8%ad%e6%89%be%e6%9c%80%e5%a4%a7%e5%80%bc" aria-label="515.在每个树行中找最大值">515.在每个树行中找最大值</a></li>
                    <li>
                        <a href="#116%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88" aria-label="116.填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</a></li>
                    <li>
                        <a href="#117%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88ii" aria-label="117.填充每个节点的下一个右侧节点指针II">117.填充每个节点的下一个右侧节点指针II</a></li>
                    <li>
                        <a href="#104%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6" aria-label="104.二叉树的最大深度">104.二叉树的最大深度</a></li>
                    <li>
                        <a href="#111%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e6%b7%b1%e5%ba%a6" aria-label="111.二叉树的最小深度">111.二叉树的最小深度</a></li>
                    <li>
                        <a href="#226%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="226.翻转二叉树">226.翻转二叉树</a></li>
                    <li>
                        <a href="#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="101. 对称二叉树">101. 对称二叉树</a></li>
                    <li>
                        <a href="#100%e7%9b%b8%e5%90%8c%e7%9a%84%e6%a0%91" aria-label="100.相同的树">100.相同的树</a></li>
                    <li>
                        <a href="#572%e5%8f%a6%e4%b8%80%e4%b8%aa%e6%a0%91%e7%9a%84%e5%ad%90%e6%a0%91" aria-label="572.另一个树的子树">572.另一个树的子树</a></li>
                    <li>
                        <a href="#222%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0" aria-label="222.完全二叉树的节点个数">222.完全二叉树的节点个数</a></li>
                    <li>
                        <a href="#110%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="110.平衡二叉树">110.平衡二叉树</a></li>
                    <li>
                        <a href="#257-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%89%80%e6%9c%89%e8%b7%af%e5%be%84" aria-label="257. 二叉树的所有路径">257. 二叉树的所有路径</a></li>
                    <li>
                        <a href="#404%e5%b7%a6%e5%8f%b6%e5%ad%90%e4%b9%8b%e5%92%8c" aria-label="404.左叶子之和">404.左叶子之和</a></li>
                    <li>
                        <a href="#513%e6%89%be%e6%a0%91%e5%b7%a6%e4%b8%8b%e8%a7%92%e7%9a%84%e5%80%bc" aria-label="513.找树左下角的值">513.找树左下角的值</a></li>
                    <li>
                        <a href="#112-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c" aria-label="112. 路径总和">112. 路径总和</a></li>
                    <li>
                        <a href="#113-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-ll" aria-label="113. 路径总和 ll">113. 路径总和 ll</a></li>
                    <li>
                        <a href="#106%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="106.从中序与后序遍历序列构造二叉树">106.从中序与后序遍历序列构造二叉树</a></li>
                    <li>
                        <a href="#105%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="105.从前序与中序遍历序列构造二叉树">105.从前序与中序遍历序列构造二叉树</a></li>
                    <li>
                        <a href="#%e4%ba%8c%e5%88%b7%e6%9e%84%e5%bb%ba%e6%a0%91" aria-label="二刷构建树">二刷构建树</a></li>
                    <li>
                        <a href="#654%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="654.最大二叉树">654.最大二叉树</a></li>
                    <li>
                        <a href="#617%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="617.合并二叉树">617.合并二叉树</a></li>
                    <li>
                        <a href="#700%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2" aria-label="700.二叉搜索树中的搜索">700.二叉搜索树中的搜索</a></li>
                    <li>
                        <a href="#98%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="98.验证二叉搜索树">98.验证二叉搜索树</a></li>
                    <li>
                        <a href="#530%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e7%bb%9d%e5%af%b9%e5%b7%ae" aria-label="530.二叉搜索树的最小绝对差">530.二叉搜索树的最小绝对差</a></li>
                    <li>
                        <a href="#501%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e4%bc%97%e6%95%b0" aria-label="501.二叉搜索树中的众数">501.二叉搜索树中的众数</a></li>
                    <li>
                        <a href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="236. 二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></li>
                    <li>
                        <a href="#235-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="235. 二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</a></li>
                    <li>
                        <a href="#701%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c" aria-label="701.二叉搜索树中的插入操作">701.二叉搜索树中的插入操作</a></li>
                    <li>
                        <a href="#450%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9" aria-label="450.删除二叉搜索树中的节点">450.删除二叉搜索树中的节点</a></li>
                    <li>
                        <a href="#669-%e4%bf%ae%e5%89%aa%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="669. 修剪二叉搜索树">669. 修剪二叉搜索树</a></li>
                    <li>
                        <a href="#108%e5%b0%86%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="108.将有序数组转换为二叉搜索树">108.将有序数组转换为二叉搜索树</a></li>
                    <li>
                        <a href="#538%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91" aria-label="538.把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p><strong>前置知识填充篇</strong>：</p>
<p><strong>满二叉树</strong>：深度为 k 的满二叉树在深度为 k 层也都有左右子树。</p>
<p><strong>完全二叉树</strong>：深度为 k 的完全二叉树除了第 k 层节点<strong>可能</strong>没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。</p>
<p><strong>二叉搜索树</strong>：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。</p>
<p><strong>平衡二叉树（AVL）</strong>：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。</p>
<p><strong>二叉树的存储</strong>：</p>
<p>二叉树可以链式存储，也可以顺序存储。</p>
<p>链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。</p>
<p>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</p>
<p><strong>二叉树的遍历</strong>：</p>
<ol>
<li>深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。</li>
<li>广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）</li>
</ol>
<h3 id="144二叉树的前序遍历--145二叉树的后序遍历---94二叉树的中序遍历">144.二叉树的前序遍历 &amp; 145.二叉树的后序遍历 &amp;  94.二叉树的中序遍历<a hidden class="anchor" aria-hidden="true" href="#144二叉树的前序遍历--145二叉树的后序遍历---94二叉树的中序遍历">#</a></h3>
<p>递归做法：三个遍历一个方法代码挪一下位置。</p>
<p>迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。</p>
<p>注意：</p>
<ol>
<li>迭代中序是复杂点，不断地往左推，到最左再依次弹出，弹出要注意父节点的 right 有没有，就这条思路。</li>
<li>后序 不是 直接 前序 倒转，而是把 前序 的左右孩子入栈顺序倒转再 反转。</li>
<li>前序：中左右。 后序：左右中。前序调转入栈顺序：中右左，反转：左右中=后序。</li>
</ol>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {<span style="color:#4e4e4e">//中序遍历
</span><span style="color:#4e4e4e"></span>    <span style="color:#0087ff">public</span> List&lt;Integer&gt; <span style="color:#0087ff">inorderTraversal</span>(TreeNode root) {
        List&lt;Integer&gt; list = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> list;
        Stack&lt;TreeNode&gt; stack = <span style="color:#5f8700">new</span> Stack&lt;&gt;();
        TreeNode cur = root;
        <span style="color:#5f8700">while</span>(cur != <span style="color:#d75f00">null</span> || !stack.isEmpty()){
            <span style="color:#5f8700">if</span>(cur != <span style="color:#d75f00">null</span>){
                stack.push(cur);
                cur = cur.left; 
            }<span style="color:#5f8700">else</span>{
                cur = stack.pop();
                list.add(cur.val);
                cur = cur.right;
            }
        }
        <span style="color:#5f8700">return</span> list;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="102二叉树的层序遍历">102.二叉树的层序遍历<a hidden class="anchor" aria-hidden="true" href="#102二叉树的层序遍历">#</a></h3>
<p><strong>递归思路</strong>：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。</p>
<p>是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。</p>
<p>这题二刷肯定思路从0开始，大家都这样，不要放弃！！！</p>
<p><strong>二刷</strong>思路：用 deep 和 list 的 size 来判断是否需要 new 新的 listSon。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    List&lt;List&lt;Integer&gt;&gt; list;
    <span style="color:#0087ff">public</span> List&lt;List&lt;Integer&gt;&gt; <span style="color:#0087ff">levelOrder</span>(TreeNode root) {
        list = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        bfs(root,0);
        <span style="color:#5f8700">return</span> list;
    }
    <span style="color:#0087ff">public</span> <span style="color:#af0000">void</span> <span style="color:#0087ff">bfs</span>(TreeNode root,<span style="color:#af0000">int</span> deep){
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>) <span style="color:#5f8700">return</span>;
        deep++;
        <span style="color:#5f8700">if</span>(list.size() &lt; deep){
            List&lt;Integer&gt; item = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
            list.add(item);
        }
        list.get(deep-1).add(root.val);
        bfs(root.left,deep);
        bfs(root.right,deep);
    }
}
</code></pre></td></tr></table>
</div>
</div><p><strong>迭代思路(推荐)</strong>：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。</p>
<p><strong>二刷</strong>思路：把 root 放进去队列，poll 出来 add(val)，然后放入左右孩子，poll 出来 add(val)。一层孩子 new 一个 list，而结束条件是 !queue.isEmpty() ，控制层层分离的则是 最初操作的 queue.size() 。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> List&lt;List&lt;Integer&gt;&gt; <span style="color:#0087ff">levelOrder</span>(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; list = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> list;
        Queue&lt;TreeNode&gt; queue = <span style="color:#5f8700">new</span> LinkedList&lt;&gt;();
        queue.offer(root);
        TreeNode temp = <span style="color:#d75f00">null</span>;
        <span style="color:#5f8700">while</span>(!queue.isEmpty()){
            List&lt;Integer&gt; listSon = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
            <span style="color:#af0000">int</span> len = queue.size();
            <span style="color:#5f8700">while</span>(len &gt; 0){
                temp = queue.poll();
                listSon.add(temp.val);
                <span style="color:#5f8700">if</span>(temp.left != <span style="color:#d75f00">null</span>)   queue.offer(temp.left);
                <span style="color:#5f8700">if</span>(temp.right != <span style="color:#d75f00">null</span>)  queue.offer(temp.right);
                len--;
            }
            list.add(listSon);
        }
        <span style="color:#5f8700">return</span> list;
        }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="107二叉树的层次遍历ii">107.二叉树的层次遍历II<a hidden class="anchor" aria-hidden="true" href="#107二叉树的层次遍历ii">#</a></h3>
<p>就是用上题的迭代再反转，反转就把装有ArrayList<Integer>的 list 从尾到头的 add 到另一个 result 就行。</p>
<h3 id="199二叉树的右视图">199.二叉树的右视图<a hidden class="anchor" aria-hidden="true" href="#199二叉树的右视图">#</a></h3>
<p>利用层序迭代遍历留住每层的最后一个元素值。</p>
<h3 id="637二叉树的层平均值">637.二叉树的层平均值<a hidden class="anchor" aria-hidden="true" href="#637二叉树的层平均值">#</a></h3>
<p>还是层序遍历。</p>
<h3 id="429n叉树的层序遍历">429.N叉树的层序遍历<a hidden class="anchor" aria-hidden="true" href="#429n叉树的层序遍历">#</a></h3>
<p>主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。</p>
<h3 id="515在每个树行中找最大值">515.在每个树行中找最大值<a hidden class="anchor" aria-hidden="true" href="#515在每个树行中找最大值">#</a></h3>
<p>类似层序遍历留住最后一个元素。</p>
<h3 id="116填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针<a hidden class="anchor" aria-hidden="true" href="#116填充每个节点的下一个右侧节点指针">#</a></h3>
<p>思路：很简单，自己用层序遍历套娃。</p>
<p>注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：</p>
<p>//需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。</p>
<h3 id="117填充每个节点的下一个右侧节点指针ii">117.填充每个节点的下一个右侧节点指针II<a hidden class="anchor" aria-hidden="true" href="#117填充每个节点的下一个右侧节点指针ii">#</a></h3>
<p>和116的差距就是这里不是完全二叉树，逻辑代码都一样。</p>
<h3 id="104二叉树的最大深度">104.二叉树的最大深度<a hidden class="anchor" aria-hidden="true" href="#104二叉树的最大深度">#</a></h3>
<p>做了前面的还不会请自行gg&hellip;..</p>
<h3 id="111二叉树的最小深度">111.二叉树的最小深度<a hidden class="anchor" aria-hidden="true" href="#111二叉树的最小深度">#</a></h3>
<p>有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。</p>
<p><strong>注意</strong>：一定要在第一步判空:     if(root == null)   &hellip;&hellip;&hellip;&hellip;..</p>
<h3 id="226翻转二叉树">226.翻转二叉树<a hidden class="anchor" aria-hidden="true" href="#226翻转二叉树">#</a></h3>
<p><strong>递归</strong>：确定参数类型、返回值 —&gt; 确定终止条件 —&gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。</p>
<p>层序遍历在内层循环也能处理。</p>
<h3 id="101-对称二叉树">101. 对称二叉树<a hidden class="anchor" aria-hidden="true" href="#101-对称二叉树">#</a></h3>
<p>不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。</p>
<p><strong>递归</strong>很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。</p>
<p><strong>迭代</strong>：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。</p>
<p>其实还是迭代更具普适性。</p>
<h3 id="100相同的树">100.相同的树<a hidden class="anchor" aria-hidden="true" href="#100相同的树">#</a></h3>
<p><strong>递归</strong>：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 &amp;&amp;。</p>
<p><strong>迭代</strong>：同101。</p>
<h3 id="572另一个树的子树">572.另一个树的子树<a hidden class="anchor" aria-hidden="true" href="#572另一个树的子树">#</a></h3>
<p>据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。</p>
<p><strong>注意</strong>：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！</p>
<h3 id="222完全二叉树的节点个数">222.完全二叉树的节点个数<a hidden class="anchor" aria-hidden="true" href="#222完全二叉树的节点个数">#</a></h3>
<p>迭代：一个循环粗糙层序遍历。</p>
<p>递归：return 1+左递归+右递归。</p>
<p><strong>注意</strong>：用 offer 要判空“值”，poll 不需要判空“队列”。</p>
<h3 id="110平衡二叉树">110.平衡二叉树<a hidden class="anchor" aria-hidden="true" href="#110平衡二叉树">#</a></h3>
<p><strong>思路</strong>：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。</p>
<p><strong>注意</strong>：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。</p>
<p><strong>拓展</strong>：bfs 万精油， dfs 前序求深度，后序求高度。</p>
<p><strong>二刷</strong>：实在没想到思路，竟然是这样。递归一个求深度方法；</p>
<h3 id="257-二叉树的所有路径">257. 二叉树的所有路径<a hidden class="anchor" aria-hidden="true" href="#257-二叉树的所有路径">#</a></h3>
<p><strong>思路</strong>：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。</p>
<p><strong>二刷</strong>：主要就是用左右孩子为空当作依据来操作，先去 List<Integer> 出来 path ，再去操作字符串，不然append(root.left.val).append(”→”) 这样很难回溯。</p>
<h3 id="404左叶子之和">404.左叶子之和<a hidden class="anchor" aria-hidden="true" href="#404左叶子之和">#</a></h3>
<p><strong>思路</strong>：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。</p>
<p><strong>注意</strong>：一定要判断是否为叶子结点，是求<strong>左叶子</strong>结点和，不是左节点和。</p>
<h3 id="513找树左下角的值">513.找树左下角的值<a hidden class="anchor" aria-hidden="true" href="#513找树左下角的值">#</a></h3>
<p><strong>思路</strong>：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！</p>
<h3 id="112-路径总和">112. 路径总和<a hidden class="anchor" aria-hidden="true" href="#112-路径总和">#</a></h3>
<p><strong>思路</strong>：主要就是递归+回溯，和257差不多。</p>
<p>注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。</p>
<h3 id="113-路径总和-ll">113. 路径总和 ll<a hidden class="anchor" aria-hidden="true" href="#113-路径总和-ll">#</a></h3>
<p><strong>思路</strong>：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。</p>
<p><strong>注意</strong>：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。</p>
<h3 id="106从中序与后序遍历序列构造二叉树">106.从中序与后序遍历序列构造二叉树<a hidden class="anchor" aria-hidden="true" href="#106从中序与后序遍历序列构造二叉树">#</a></h3>
<p><strong>key1</strong>：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。</p>
<p><strong>key2</strong>：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。</p>
<p><strong>key3：</strong></p>
<ol>
<li>****后序中结点分布应该是：[左子树结点，右子树结点，根结点]；</li>
<li>中序中结点分布应该是：[左子树结点，根结点，右子树结点]；</li>
<li>左右子树的节点分别去左右子树匹配；</li>
</ol>
<p><strong>key4</strong>：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 ”左闭右开“ 的话传入的参数应该是0、leng、0、leng。切割处理也不同。</li>
<li>后序要抠掉最后一个结点，因为这个结点 new 出来了。</li>
</ol>
<h3 id="105从前序与中序遍历序列构造二叉树">105.从前序与中序遍历序列构造二叉树<a hidden class="anchor" aria-hidden="true" href="#105从前序与中序遍历序列构造二叉树">#</a></h3>
<p>同 106 所述，就是抠的是左边界。</p>
<h3 id="二刷构建树">二刷构建树<a hidden class="anchor" aria-hidden="true" href="#二刷构建树">#</a></h3>
<p>前序：[root,root.left,root.right]</p>
<p>中序：[root.left,root,root.right]</p>
<p>后序：[root.left,root.right,root]</p>
<p>前序遍历的第一个，后序遍历的最后一个元素就是树的根节点，根据这根节点可以在 <strong>中序遍历</strong> 中找到 val 相同的节点，也就是这棵树的根节点，这个节点的左边就是左子树的所有节点，右边就是右子树的所有结点。这样我们知道了左右子树各自的节点个数。根据前序数组，root,左子树所有节点，右子树所有节点，可以拿到左子树的所有节点的前序遍历、右子树所有节点的后序遍历，继续递归。后序遍历同理。结束条件是中序 left &gt; right,left == right 时 new这个节点。</p>
<h3 id="654最大二叉树">654.最大二叉树<a hidden class="anchor" aria-hidden="true" href="#654最大二叉树">#</a></h3>
<p><strong>错误</strong>思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if &hellip; else 把出现次数多的放在 if 中。错在题意理解上。</p>
<p><strong>正确</strong>思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left &gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();</p>
<p>注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。</p>
<p><strong>二刷</strong>：类似建树，比建树简单多了。</p>
<h3 id="617合并二叉树">617.合并二叉树<a hidden class="anchor" aria-hidden="true" href="#617合并二叉树">#</a></h3>
<p><strong>思路</strong>：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。</p>
<p><strong>注意</strong>：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。</p>
<h3 id="700二叉搜索树中的搜索">700.二叉搜索树中的搜索<a hidden class="anchor" aria-hidden="true" href="#700二叉搜索树中的搜索">#</a></h3>
<p>略&hellip;&hellip;</p>
<h3 id="98验证二叉搜索树">98.验证二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#98验证二叉搜索树">#</a></h3>
<p>中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。</p>
<h3 id="530二叉搜索树的最小绝对差">530.二叉搜索树的最小绝对差<a hidden class="anchor" aria-hidden="true" href="#530二叉搜索树的最小绝对差">#</a></h3>
<p>暴力解法：直接遍历出 list，再递归左右子树去遍历差值。</p>
<p>优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子&hellip;&hellip;.）、右子树的最左后代是值最接近根节点的结点。</p>
<p><strong>二刷</strong>：左子树最右子节点的递归方法，右子树最左子节点的递归方法。</p>
<h3 id="501二叉搜索树中的众数">501.二叉搜索树中的众数<a hidden class="anchor" aria-hidden="true" href="#501二叉搜索树中的众数">#</a></h3>
<p><strong>暴力</strong>解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。</p>
<p>注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。</p>
<p><strong>迭代</strong>法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。</p>
<h3 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#236-二叉树的最近公共祖先">#</a></h3>
<p><strong>暴力</strong>解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
        TreeNode node = root;
        List&lt;TreeNode&gt; list1 = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        List&lt;TreeNode&gt; list2 = <span style="color:#5f8700">new</span> ArrayList&lt;&gt;();
        getPath(list1, root, p);
        getPath(list2, root, q);
        <span style="color:#5f8700">for</span>(<span style="color:#af0000">int</span> i=0; i&lt;list1.size(); i++){
            <span style="color:#5f8700">for</span>(<span style="color:#af0000">int</span> j=0; j&lt;list2.size(); j++){
                <span style="color:#5f8700">if</span>(list1.get(i).val == list2.get(j).val)
                    node = list1.get(i);
            }
        }
        <span style="color:#5f8700">return</span> node;
    }
    <span style="color:#0087ff">public</span> <span style="color:#af0000">boolean</span> <span style="color:#0087ff">getPath</span>(List&lt;TreeNode&gt; list, TreeNode root, TreeNode target){
        <span style="color:#5f8700">if</span>(root.val == target.val){
            list.add(target);
            <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>; 
        }
        <span style="color:#5f8700">if</span>(root.left != <span style="color:#d75f00">null</span>){
            list.add(root);
            <span style="color:#5f8700">if</span>(getPath(list, root.left, target)) <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>;
            list.remove(root);
        }
        <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span>){
            list.add(root);
            <span style="color:#5f8700">if</span>(getPath(list, root.right, target)) <span style="color:#5f8700">return</span> <span style="color:#d75f00">true</span>;
            list.remove(root);
        }
        <span style="color:#5f8700">return</span> <span style="color:#d75f00">false</span>;
    }
}
</code></pre></td></tr></table>
</div>
</div><p>最优解法<strong>思路</strong>：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {<span style="color:#4e4e4e">//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。
</span><span style="color:#4e4e4e"></span>        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span> || root == p || root == q)    <span style="color:#5f8700">return</span> root;<span style="color:#4e4e4e">//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）
</span><span style="color:#4e4e4e"></span>        TreeNode left = lowestCommonAncestor(root.left, p, q);<span style="color:#4e4e4e">//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点
</span><span style="color:#4e4e4e"></span>        TreeNode right = lowestCommonAncestor(root.right, p, q);<span style="color:#4e4e4e">//右子树去遍历寻找p、q
</span><span style="color:#4e4e4e"></span>        <span style="color:#4e4e4e">//具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。
</span><span style="color:#4e4e4e"></span>        <span style="color:#5f8700">if</span>(left != <span style="color:#d75f00">null</span> &amp;&amp; right != <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> root;
        <span style="color:#5f8700">if</span>(left != <span style="color:#d75f00">null</span> &amp;&amp; right == <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> left;
        <span style="color:#5f8700">if</span>(left == <span style="color:#d75f00">null</span> &amp;&amp; right != <span style="color:#d75f00">null</span>)   <span style="color:#5f8700">return</span> right;
        <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
    }
}
</code></pre></td></tr></table>
</div>
</div><p><strong>二刷</strong>：从root向下找如果找到了p||q就return，否则就向下遍历，递归到了最深处还没找到返回值就是null，把左边找到的值用 left 传递，没找到就是 null 返回，然后做判断，左右孩子都是null就返回null，找到 p、q 任意一个都返回，也就是 left、right 会层层传递，左右孩子都不为空就返回 root。</p>
<h3 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#235-二叉搜索树的最近公共祖先">#</a></h3>
<p><strong>key</strong>：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
        <span style="color:#5f8700">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)    <span style="color:#5f8700">return</span> lowestCommonAncestor(root.left , p, q);
        <span style="color:#5f8700">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)    <span style="color:#5f8700">return</span> lowestCommonAncestor(root.right, p, q);
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="701二叉搜索树中的插入操作">701.二叉搜索树中的插入操作<a hidden class="anchor" aria-hidden="true" href="#701二叉搜索树中的插入操作">#</a></h3>
<p><strong>key</strong>：如果 root.val &gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 &gt; \ &lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">insertIntoBST</span>(TreeNode root, <span style="color:#af0000">int</span> val) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#5f8700">new</span> TreeNode(val);
        <span style="color:#5f8700">if</span>(val &gt; root.val)  root.right = insertIntoBST(root.right, val);
        <span style="color:#5f8700">if</span>(val &lt; root.val)  root.left  = insertIntoBST(root.left , val);
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="450删除二叉搜索树中的节点">450.删除二叉搜索树中的节点<a hidden class="anchor" aria-hidden="true" href="#450删除二叉搜索树中的节点">#</a></h3>
<p>当找到了删除节点时：</p>
<p><strong>key1</strong>：当删除节点的左右节点都为 null，return null；</p>
<p><strong>key2</strong>：当删除结点左右孩子都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。</p>
<p><strong>key3</strong>：当 root.left or root.right 为 null，return 不为空的结点。</p>
<p>否则就递归并将返回为左右孩子。</p>
<p><strong>code</strong>：</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">deleteNode</span>(TreeNode root, <span style="color:#af0000">int</span> key) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span> || (root.val == key &amp;&amp; root.left == <span style="color:#d75f00">null</span> &amp;&amp; root.right ==<span style="color:#d75f00">null</span>))   
            <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>; 
        <span style="color:#5f8700">return</span> deleteNode1(root, key);
    }
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">deleteNode1</span>(TreeNode root, <span style="color:#af0000">int</span> key) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
        <span style="color:#5f8700">if</span>(root.val &gt; key)  root.left  = deleteNode1(root.left , key);
        <span style="color:#5f8700">if</span>(root.val &lt; key)  root.right = deleteNode1(root.right, key);
        <span style="color:#5f8700">if</span>(root.val == key){ 
            <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span> &amp;&amp; root.left != <span style="color:#d75f00">null</span>){
                <span style="color:#4e4e4e">//无论该处是否为null，都将root.right传进来取root.right最左祖孙。
</span><span style="color:#4e4e4e"></span>                TreeNode temp = root.right;<span style="color:#4e4e4e">//6
</span><span style="color:#4e4e4e"></span>                <span style="color:#5f8700">while</span>(temp.left != <span style="color:#d75f00">null</span>)<span style="color:#4e4e4e">//找到最左祖孙。
</span><span style="color:#4e4e4e"></span>                    temp = temp.left;
                temp.left = root.left;
                <span style="color:#5f8700">return</span> root.right;
            }<span style="color:#5f8700">else</span> <span style="color:#5f8700">if</span>(root.right != <span style="color:#d75f00">null</span> &amp;&amp; root.left == <span style="color:#d75f00">null</span>){
                <span style="color:#5f8700">return</span> root.right; 
            }<span style="color:#5f8700">else</span> <span style="color:#5f8700">if</span>(root.right == <span style="color:#d75f00">null</span> &amp;&amp; root.left != <span style="color:#d75f00">null</span>){
                <span style="color:#5f8700">return</span> root.left;
            }<span style="color:#5f8700">else</span>{
                <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
            }
        }
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><p><strong>二刷</strong>：root.right 节点当作新的 root，root.left 变成 root.right 的最左节点的孩子</p>
<p>注意：用 root.left  = 递归(root.left , key) 的方式，来传递，这样才能把 key 对应的 node 删除并且 让 node 的父节点去链接 noder.right 节点。找右孩子的最左祖孙时可以 while 循环来找。</p>
<h3 id="669-修剪二叉搜索树">669. 修剪二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#669-修剪二叉搜索树">#</a></h3>
<p><strong>思路</strong>：分别处理不正常结点，正常的节点。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">trimBST</span>(TreeNode root, <span style="color:#af0000">int</span> low, <span style="color:#af0000">int</span> high) {
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;
        <span style="color:#4e4e4e">//处理不正常的节点
</span><span style="color:#4e4e4e"></span>        <span style="color:#5f8700">if</span>(root.val &lt; low)   <span style="color:#5f8700">return</span> trimBST(root.right, low, high);
        <span style="color:#5f8700">if</span>(root.val &gt; high)  <span style="color:#5f8700">return</span> trimBST(root.left , low, high);
        <span style="color:#4e4e4e">//处理正常节点
</span><span style="color:#4e4e4e"></span>        root.left  = trimBST(root.left , low, high);
        root.right = trimBST(root.right, low, high);
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="108将有序数组转换为二叉搜索树">108.将有序数组转换为二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#108将有序数组转换为二叉搜索树">#</a></h3>
<p><strong>思路</strong>：分别递归左右区间</p>
<p><strong>注意</strong>：</p>
<ol>
<li>左右开闭一定要统一起来，我都是都闭着。</li>
<li>左右区间去递归一个方法。</li>
</ol>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">sortedArrayToBST</span>(<span style="color:#af0000">int</span>[] nums) {
        <span style="color:#5f8700">return</span> method1(nums, 0, nums.length-1);
    }
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">method1</span>(<span style="color:#af0000">int</span>[] nums,<span style="color:#af0000">int</span> left,<span style="color:#af0000">int</span> right){
        <span style="color:#5f8700">if</span>(left &gt; right)    <span style="color:#5f8700">return</span> <span style="color:#d75f00">null</span>;                   
        <span style="color:#5f8700">if</span>(left == right)   <span style="color:#5f8700">return</span> <span style="color:#5f8700">new</span> TreeNode(nums[left]);
        <span style="color:#af0000">int</span> mid = left + (right-left)/2;
        TreeNode root = <span style="color:#5f8700">new</span> TreeNode(nums[mid]);
        root.left  = method1(nums, left, mid-1);
        root.right = method1(nums, mid+1, right); 
        <span style="color:#5f8700">return</span> root;
    }
}
</code></pre></td></tr></table>
</div>
</div><h3 id="538把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树<a hidden class="anchor" aria-hidden="true" href="#538把二叉搜索树转换为累加树">#</a></h3>
<p><strong>思路</strong>：这道题最难的就是看懂题，如果换成数组看就比较好看出来，从右下角的 right 到 root 到 left。相当于就是一个反转了的中序 dfs。</p>
<p><strong>二刷</strong>：最难的是题意，注意，变化后左子树也变成了左孩子大于右孩子，已经不是二叉搜索树了。</p>
<div class="highlight"><div style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#454545">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#0087ff">class</span> <span style="color:#0087ff">Solution</span> {
    <span style="color:#af0000">int</span> sum = 0;
    <span style="color:#0087ff">public</span> TreeNode <span style="color:#0087ff">convertBST</span>(TreeNode root) {
        dfs(root);
        <span style="color:#5f8700">return</span> root;
    }
    <span style="color:#0087ff">public</span> <span style="color:#af0000">void</span> <span style="color:#0087ff">dfs</span>(TreeNode root){
        <span style="color:#5f8700">if</span>(root == <span style="color:#d75f00">null</span>)    <span style="color:#5f8700">return</span> ;
        dfs(root.right);
        sum+=root.val;
        root.val = sum;
        dfs(root.left);
    }
}
</code></pre></td></tr></table>
</div>
</div><p>持续更新&hellip;&hellip;.<br>
如有错误，敬请斧正！！！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://coderrenxy.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://coderrenxy.github.io/posts/life/september.no1-weekly-summary/">
    <span class="title">« 上一篇</span>
    <br>
    <span>September.No1 Weekly Summary</span>
  </a>
  <a class="next" href="https://coderrenxy.github.io/posts/blog/leetcode-%E6%A0%88%E9%98%9F%E5%88%97%E4%BA%8C/">
    <span class="title">下一篇 »</span>
    <br>
    <span>LeetCode 栈、队列(二)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<script src="https://utteranc.es/client.js"
repo="coderRenxy/coderrenxy.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>

<footer class="footer">
    <span>&copy; 2025 <a href="https://coderrenxy.github.io/">小任同学&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
	<span id="busuanzi_container_site_pv">
    访问量：<span id="busuanzi_value_site_pv"></span>次
</span>
&nbsp;
<span id="busuanzi_container_site_uv">
    您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
</span>
<hr>


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
 <div>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


</body>

</html>

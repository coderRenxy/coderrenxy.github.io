[{"content":"\r\r/* 手机适配 */\r@media screen and (max-width: 500px) {\r.search{\rpadding-right: 25px;\r}\r.search input{\rwidth: 100%;\r}\r.search button{\rdisplay: none;\r}\r}\r/* 电脑适配 */\r@media screen and (min-width: 500px) {\r.search{\rwidth: 500px;\r}\r.search input{\rwidth: 444px;\r}\r}\r/* 通用样式 */\r.search{\rmargin: auto;\r}\r.search input{\routline: none;\rborder: 2px solid #c05b4d;\rheight: 32px;\rpadding: 10px;\r}\r.search button{\routline: none;\rborder: 0px;\rheight: 56px;\rwidth:56px;\rposition:absolute;\rbackground-color:#c05b4d ;\r}\r.search .icon{\rwidth: 28px;\rheight: 28px;\r}\r\r\r\r\r\r\r\r\r搜索中，请稍后 ...\r\r// enter\rwindow.onload = function() {\rdocument.onkeydown = function(ev) {\rvar event = ev || event\rif (event.keyCode == 13) {\rsearch()\r}\r}\r}\r// search\rfunction search() {\rkey = document.getElementById(\"search-key\").value;\rif (key === \"\") {\rreturn;\r}\rdocument.getElementById(\"search-key\").value = \"\";\r// tip\rdocument.getElementById(\"search-tip\").innerText = \"搜索中，请稍后 ...\";\rdocument.getElementById(\"search-tip\").style.display = \"block\";\r// clear\rvar el = document.getElementById('result');\rvar childs = el.childNodes;\rfor (var i = childs.length - 1; i = 0; i--) {\rel.removeChild(childs[i]);\r}\r// xml\rxmltext = new XMLHttpRequest;\rxmltext.open(\"GET\", \"/index.xml\", false);\rxmltext.send();\rresp = xmltext.responseXML;\ritems = resp.getElementsByTagName(\"item\");\r// search\rvar i = 0;\rhaveResult = false;\rwhile (i -1) {\rhaveResult = true;\rtitle = items[i].getElementsByTagName(\"title\")[0].innerHTML;\rlink = items[i].getElementsByTagName(\"link\")[0].innerHTML;\rtime = items[i].getElementsByTagName(\"pubDate\")[0].innerHTML;\rmark = items[i].getElementsByTagName(\"description\")[0].innerHTML;\raddItem(title, link, time, mark)\r}\ri++;\r}\rif (!haveResult) {\rdocument.getElementById(\"search-tip\").innerText = \"搜索完毕，未发现结果 ...\";\rdocument.getElementById(\"search-tip\").style.display = \"block\";\r}\r}\r// add\rfunction addItem(title, link, time, mark) {\rdocument.getElementById(\"search-tip\").style.display = \"none\";\rtmpl = \"\" +\r\"\" +\r\"\" + title + \"\" +\r\"\" +\r\" \" + time + \"\" +\r\"\" +\r\" \" +\r\"\" +\r\"\" + mark + \"\" +\r\"\" +\r\"阅读更多\" +\r\"\" +\r\" \" +\r\"\"\rdiv = document.createElement(\"div\")\rdiv.innerHTML = tmpl;\rdocument.getElementById('result').appendChild(div)\r}\r","permalink":"https://coderrenxy.github.io/search/","summary":"/* 手机适配 */ @media screen and (max-width: 500px) { .search{ padding-right: 25px; } .search input{ width: 100%; } .search button{ display: none; } } /* 电脑适配 */ @media screen and (min-width: 500px) { .search{ width: 500px; } .search input{ width: 444px; } } /* 通用样式 */ .search{ margin: auto; } .search input{ outline: none; border: 2px solid #c05b4d; height: 32px; padding:","title":"🔍搜索"},{"content":"找实习历程 从23年2月份开始找实习，刚开始挺难的，面试都约不到，后面越挫越勇，坚持到了6月，陆续拿到不少offer，面过的基本都过了，但8月跳槽了一次。 例如\n 爱的番茄-高竞文化，oc。 喜马拉雅oc。 小米面完技术，等了1周，排序挂。面试全垒打了，2算法全A了，但是hr打电话说基础不牢？（好吧，一打开牛客，全是985、211选手在同部门排序，不挂我挂谁） 腾讯云智2面，全程听不清面试官声音，那边很吵。G了 神州信息、亚信科技等一众小厂 or 外包offer。 七牛云oc。氛围很好，可以线上办公，同事全大佬。 得到oc。神仙公司，大家中午一起踢毽子，打篮球，每个人非常和善。  秋招历程 没约到几个面试，拿到了疯狂游戏（3面+用他们app做游戏考核）我这个岗位第一次招人，三个月转正，有钱但是hr\u0026hellip;\u0026hellip;朋友去过，氛围压抑。拒绝了。\n秋招该找的问题我都找了，简历改了又改，又是两页纸，又是为了一页删掉项目经历，个人评价，荣誉那一堆。\n过年期间刷了一些算法题，leetcode 之前刷了 200，常见这些刷了 3 遍以上。\n但是 hard 没管，单调栈，图论，基本计算器类题型。这些本以为性价比低的，在补习了。\nhot100 里面刷过的重刷，没刷过的刷。另外看看技术博客，拓展知识边界。\n我的过往经历 说一些简历上没有的吧hhh\n培训机构高中物理老师、数学老师、生物家教老师、班主任。\n年年电子厂暑假工赚1w 自费学费，最狠一次白天搬货，晚上跑外卖。\n班长、学生会部长、优秀学生、优秀毕业生。 三次小生意投资：一次亏本，2次投报比1：2 。\n我的期望 其实我blog放到git page而不是csdn就是为了小众，看我博客最多的可能是我的面试官。\n我的愿景很诚恳，我只想好好写几年代码，沉淀下来。\n我的下周计划  把失败发布的记录拉出来。 把需求上线，并学习记录整个发布上线的流程（应该跟 灰度、日常环境 差不多）。 继续看代码，并排查《保存流水线 的接口很慢的问题》。 迎接下一个需求，熟悉那块代码。  小爱好  享受做饭：正宗辣椒炒肉（复刻费大厨）、麻辣香锅、椒盐虾、可乐鸡翅、香菇鸡块、煎牛排 这些是我最拿手的。 运动：在学校每天5km、精通各种球类运动、桌面足球发烧友。 音乐：陈奕迅粤语歌基本都会，张敬轩的也是。关于这两个歌手的歌曲解析，可以聊一整本书。 聊天、发呆、思考：E人，非常善于沟通、社交。尤其喜欢跟不同阶层，不同年龄的人聊天，代入他们的生活。  ","permalink":"https://coderrenxy.github.io/posts/blog/23%E5%B9%B4%E6%80%BB%E7%BB%93/","summary":"找实习历程 从23年2月份开始找实习，刚开始挺难的，面试都约不到，后面越挫越勇，坚持到了6月，陆续拿到不少offer，面过的基本都过了，但8月","title":"春招前总结"},{"content":"一、组件基础 1. React 事件机制 1  \u0026lt;div onClick={this.handleClick.bind(this)}\u0026gt;点我\u0026lt;/div\u0026gt;   React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。\n除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopPropgation()方法。\nJSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n实现合成事件的目的如下：\n 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力； 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。  2. React的事件和普通的HTML事件有什么不同？ 区别：\n 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰； 对于事件函数处理语法，原生事件为字符串，react 事件为函数； react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。  合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：\n 兼容所有浏览器，更好的跨平台； 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。 方便 react 统一管理和事务机制。  事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n3. React 组件中怎么做事件代理？它的原理是什么？ React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。\n在React底层，主要对合成事件做了两件事：\n **事件委派：**React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。 **自动绑定：**React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。  4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代 这三者是目前react解决代码复用的主要方式：\n 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。 render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。 通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。  （1）HOC\n官方解释∶\n 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n 简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // hoc的定义 function withSubscription(WrappedComponent, selectData) { return class extends React.Component { constructor(props) { super(props); this.state = { data: selectData(DataSource, props) }; } // 一些通用的逻辑处理 render() { // ... 并使用新数据渲染被包装的组件! return \u0026lt;WrappedComponent data={this.state.data} {...this.props} /\u0026gt;; } }; // 使用 const BlogPostWithSubscription = withSubscription(BlogPost, (DataSource, props) =\u0026gt; DataSource.getBlogPost(props.id));   HOC的优缺点∶\n 优点∶ 逻辑复用、不影响被包裹组件的内部逻辑。 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖  **（2）**Render props\n官方解释∶\n \u0026ldquo;render prop\u0026quot;是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术\n 具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，\u0026ldquo;render\u0026quot;的命名可以是任何其他有效的标识符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // DataProvider组件内部的渲染逻辑如下 class DataProvider extends React.Components { state = { name: \u0026#39;Tom\u0026#39; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;共享数据组件自己内部的渲染逻辑\u0026lt;/p\u0026gt; { this.props.render(this.state) } \u0026lt;/div\u0026gt; ); } } // 调用方式 \u0026lt;DataProvider render={data =\u0026gt; ( \u0026lt;h1\u0026gt;Hello {data.name}\u0026lt;/h1\u0026gt; )}/\u0026gt;   由此可以看到，render props的优缺点也很明显∶\n 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅  **（3）**Hooks\n官方解释∶\n Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。\n 1 2 3 4 5 6 7 8 9 10 11 12 13  // 自定义一个获取订阅数据的hook function useSubscription() { const data = DataSource.getComments(); return [data]; } // function CommentList(props) { const {data} = props; const [subData] = useSubscription(); ... } // 使用 \u0026lt;CommentList data=\u0026#39;hello\u0026#39; /\u0026gt;   以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶\n 使用直观； 解决hoc的prop 重名问题； 解决render props 因共享数据 而出现嵌套地狱的问题； 能在return之外使用数据的问题。  需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n总结∶\nHoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。\n5. 对React-Fiber的理解，它解决了什么问题？ React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。\n为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。\n所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:\n 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验； 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。  **核心思想：**Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。\n6. React.Component 和 React.PureComponent 的区别 PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。\n在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。\n不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。\n使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。\n7. Component, Element, Instance 之间有什么区别和联系？  **元素：**一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。 **组件：**一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。 **实例：**一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。  函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。\n8. React.createClass和extends Component的区别有哪些？ React.createClass和extends Component的bai区别主要在于：\n（1）语法区别\n createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。 createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。  （2）propType 和 getDefaultProps\n React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props. React.Component：通过设置两个属性propTypes和defaultProps  （3）状态的区别\n React.createClass：通过getInitialState()方法返回一个包含初始值的对象 React.Component：通过constructor设置初始状态  （4）this区别\n React.createClass：会正确绑定this React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。  （5）Mixins\n React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。 如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。  9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景 官方解释∶\n 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n 高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // hoc的定义 function withSubscription(WrappedComponent, selectData) { return class extends React.Component { constructor(props) { super(props); this.state = { data: selectData(DataSource, props) }; } // 一些通用的逻辑处理 render() { // ... 并使用新数据渲染被包装的组件! return \u0026lt;WrappedComponent data={this.state.data} {...this.props} /\u0026gt;; } }; // 使用 const BlogPostWithSubscription = withSubscription(BlogPost, (DataSource, props) =\u0026gt; DataSource.getBlogPost(props.id));   1）HOC的优缺点\n 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖  2）适用场景\n 代码复用，逻辑抽象 渲染劫持 State 抽象和更改 Props 更改  3）具体应用例子\n **权限控制：**利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // HOC.js function withAdminAuth(WrappedComponent) { return class extends React.Component { state = { isAdmin: false, } async UNSAFE_componentWillMount() { const currentRole = await getCurrentUserRole(); this.setState({ isAdmin: currentRole === \u0026#39;Admin\u0026#39;, }); } render() { if (this.state.isAdmin) { return \u0026lt;WrappedComponent {...this.props} /\u0026gt;; } else { return (\u0026lt;div\u0026gt;您没有权限查看该页面，请联系管理员！\u0026lt;/div\u0026gt;); } } }; } // pages/page-a.js class PageA extends React.Component { constructor(props) { super(props); // something here...  } UNSAFE_componentWillMount() { // fetching data  } render() { // render page with data  } } export default withAdminAuth(PageA); // pages/page-b.js class PageB extends React.Component { constructor(props) { super(props); // something here...  } UNSAFE_componentWillMount() { // fetching data  } render() { // render page with data  } } export default withAdminAuth(PageB);    **组件渲染性能追踪：**借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Home extends React.Component { render() { return (\u0026lt;h1\u0026gt;Hello World.\u0026lt;/h1\u0026gt;); } } function withTiming(WrappedComponent) { return class extends WrappedComponent { constructor(props) { super(props); this.start = 0; this.end = 0; } UNSAFE_componentWillMount() { super.componentWillMount \u0026amp;\u0026amp; super.componentWillMount(); this.start = Date.now(); } componentDidMount() { super.componentDidMount \u0026amp;\u0026amp; super.componentDidMount(); this.end = Date.now(); console.log(`${WrappedComponent.name}组件渲染时间为 ${this.end - this.start}ms`); } render() { return super.render(); } }; } export default withTiming(Home);   注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。\n 页面复用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const withFetching = fetching =\u0026gt; WrappedComponent =\u0026gt; { return class extends React.Component { state = { data: [], } async UNSAFE_componentWillMount() { const data = await fetching(); this.setState({ data, }); } render() { return \u0026lt;WrappedComponent data={this.state.data} {...this.props} /\u0026gt;; } } } // pages/page-a.js export default withFetching(fetching(\u0026#39;science-fiction\u0026#39;))(MovieList); // pages/page-b.js export default withFetching(fetching(\u0026#39;action\u0026#39;))(MovieList); // pages/page-other.js export default withFetching(fetching(\u0026#39;some-other-type\u0026#39;))(MovieList);   10. 对componentWillReceiveProps 的理解 该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。\n**使用好处：**在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。\n11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？ （1）哪些方法会触发 react 重新渲染?\n setState（）方法被调用  setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class App extends React.Component { state = { a: 1 }; render() { console.log(\u0026#34;render\u0026#34;); return ( \u0026lt;React.Fragement\u0026gt; \u0026lt;p\u0026gt;{this.state.a}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; { this.setState({ a: 1 }); // 这里并没有改变 a 的值  }} \u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; this.setState(null)}\u0026gt;setState null\u0026lt;/button\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/React.Fragement\u0026gt; ); } }    父组件重新渲染  只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render\n（2）重新渲染 render 会做些什么?\n 会对新旧 VNode 进行对比，也就是我们所说的Diff算法。 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面 遍历差异对象，根据差异的类型，根据对应对规则更新VNode  React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.\n（3）forceUpdate\n12. React如何判断什么时候重新渲染组件？ 组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。\n当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。\n13. React声明组件有哪几种方法，有什么不同？ React 声明组件的三种方式：\n 函数式定义的无状态组件 ES5原生方式React.createClass定义的组件 ES6形式的extends React.Component定义的组件  （1）无状态函数式组件\n它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作\n组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法\n（2）ES5 原生方式 React.createClass // RFC\nReact.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。\n（3）E6继承形式 React.Component // RCC\n目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。\n无状态组件相对于于后者的区别：\n与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。\nReact.createClass与React.Component区别：\n① 函数this自绑定\n React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。 React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。  ② 组件属性类型propTypes及其默认props属性defaultProps配置不同\n React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的 React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。  ③ 组件初始状态state的配置不同\n React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态； React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。  14. 对有状态组件和无状态组件的理解及使用场景 （1）有状态组件\n特点：\n 是类组件 有继承 可以使用this 可以使用react的生命周期 使用较多，容易频繁触发生命周期钩子函数，影响性能 内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。  使用场景：\n 需要使用到状态的。 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）  总结：\n类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n（2）无状态组件\n特点：\n 不依赖自身的状态state 可以是类组件或者函数组件。 可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定） 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件 组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。  使用场景：\n 组件不需要管理 state，纯展示  优点：\n 简化代码、专注于 render 组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用 视图和数据的解耦分离  缺点：\n 无法使用 ref 无生命周期方法 无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染  总结：\n组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 \u0026lt;Button/\u0026gt;、 \u0026lt;Input /\u0026gt; 等组件。\n15. 对React中Fragment的理解，它的使用场景是什么？ 在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：\n React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import React, { Component, Fragment } from \u0026#39;react\u0026#39; // 一般形式 render() { return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } // 也可以写成以下形式 render() { return ( \u0026lt;\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/\u0026gt; ); }   16. React如何获取组件对应的DOM元素？ 可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:\n 字符串格式：字符串格式，这是React16版本之前用得最多的，例如：\u0026lt;p ref=\u0026quot;info\u0026quot;\u0026gt;span\u0026lt;/p\u0026gt; 函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：\u0026lt;p ref={ele =\u0026gt; this.info = ele}\u0026gt;\u0026lt;/p\u0026gt; createRef方法：React 16提供的一个API，使用React.createRef()来实现 函数组件:　useRef　  17. React中可以在render访问refs吗？为什么？ 1 2 3 4 5 6  \u0026lt;\u0026gt; \u0026lt;span id=\u0026#34;name\u0026#34; ref={this.spanRef}\u0026gt;{this.state.title}\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;{ this.spanRef.current ? \u0026#39;有值\u0026#39; : \u0026#39;无值\u0026#39; }\u0026lt;/span\u0026gt; \u0026lt;/\u0026gt;   不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：\n18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景 React 官方对 Portals 的定义：\n Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案\n Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。\nPortals语法如下：\n1  ReactDOM.createPortal(child, container);    第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等; 第二个参数 container 是一个 DOM 元素。  一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：\n1 2 3 4 5 6 7 8 9  import DemoComponent from \u0026#39;./DemoComponent\u0026#39;; render() { // DemoComponent元素会被挂载在id为parent的div的元素上  return ( \u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;DemoComponent /\u0026gt; \u0026lt;/div\u0026gt; ); }   然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。\n1 2 3 4 5 6 7 8  import DemoComponent from \u0026#39;./DemoComponent\u0026#39;; render() { // react会将DemoComponent组件直接挂载在真实的 dom 节点 domNode 上，生命周期还和16版本之前相同。  return ReactDOM.createPortal( \u0026lt;DemoComponent /\u0026gt;, domNode, ); }   19. 在React中如何避免不必要的render？ React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：\n shouldComponentUpdate 和 PureComponent  在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n 利用高阶组件  在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能\n 使用 React.memo  React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。\n20. 对 React-Intl 的理解，它的工作原理？ React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。\nReact-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。\n在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。\n21. 对 React context 的理解 在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。\nContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\nJS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。\n假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。\n22. 为什么React并不推荐优先考虑使用Context？  Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context 对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。 context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注  23. React中什么是受控组件和非控组件？ （1）受控组件\n在使用表单来收集用户输入时，例如 \u0026lt;input\u0026gt;\u0026lt;select\u0026gt;\u0026lt;textearea\u0026gt; 等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。\n受控组件更新state的流程：\n 可以通过初始state中设置表单的默认值 每当表单的值发生变化时，调用onChange事件处理器 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state 一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新  受控组件缺陷：\n表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。\n（2）非受控组件\n如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。\nReact官方的解释：\n 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。\n因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。\n 例如，下面的代码在非受控组件中接收单个属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class NameForm extends React.Component { constructor(props) { super(props); this.handleSubmit = this.handleSubmit.bind(this); } handleSubmit(event) { alert(\u0026#39;A name was submitted: \u0026#39; + this.input.value); event.preventDefault(); } render() { return ( \u0026lt;form onSubmit={this.handleSubmit}\u0026gt; \u0026lt;label\u0026gt; Name: \u0026lt;input type=\u0026#34;text\u0026#34; ref={(input) =\u0026gt; this.input = input} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; ); } }   **总结：**页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。\n24. React中refs的作用是什么？有哪些应用场景？ Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：\n 处理焦点、文本选择或者媒体的控制 触发必要的动画 集成第三方 DOM 库  Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：\n1 2 3 4 5 6 7 8 9  class MyComponent extends React.Component { constructor(props) { super(props) this.myRef = React.createRef() } render() { return \u0026lt;div ref={this.myRef} /\u0026gt; } }   由于函数组件没有实例，因此不能在函数组件上直接使用 ref：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function MyFunctionalComponent() { return \u0026lt;input /\u0026gt;; } class Parent extends React.Component { constructor(props) { super(props); this.textInput = React.createRef(); } render() { // 这将不会工作！  return ( \u0026lt;MyFunctionalComponent ref={this.textInput} /\u0026gt; ); } }   但可以通过闭合的帮助在函数组件内部进行使用 Refs：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function CustomTextInput(props) { // 这里必须声明 textInput，这样 ref 回调才可以引用它  let textInput = null; function handleClick() { textInput.focus(); } return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={(input) =\u0026gt; { textInput = input; }} /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Focus the text input\u0026#34; onClick={handleClick} /\u0026gt; \u0026lt;/div\u0026gt; ); }   注意：\n  不应该过度的使用 Refs\n  ref 的返回值取决于节点的类型：\n   当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。 当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。    当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。\n  25. React中除了在构造函数中绑定this，还有别的方式吗？  在构造函数中绑定this  1 2 3 4 5 6 7  constructor(props){ super(props); this.state={ msg:\u0026#39;hello world\u0026#39;, } this.getMsg = this.getMsg.bind(this) }    函数定义的时候使用箭头函数  1 2 3 4 5 6 7 8 9  constructor(props){ super(props); this.state={ msg:\u0026#39;hello world\u0026#39;, } render(){ \u0026lt;button onClcik={()=\u0026gt;{alert(this.state.msg)}}\u0026gt;点我\u0026lt;/button\u0026gt; } }    函数调用是使用bind绑定this  1  \u0026lt;button onClick={this.getMsg.bind(this)}\u0026gt;点我\u0026lt;/button\u0026gt;   26. React组件的构造函数有什么作用？它是必须的吗？ 构造函数主要用于两个目的：\n 通过将对象分配给this.state来初始化本地状态 将事件处理程序方法绑定到实例上  所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class LikeButton extends React.Component { constructor() { super(); this.state = { liked: false }; this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState({liked: !this.state.liked}); } render() { const text = this.state.liked ? \u0026#39;liked\u0026#39; : \u0026#39;haven\\\u0026#39;t liked\u0026#39;; return ( \u0026lt;div onClick={this.handleClick}\u0026gt; You {text} this. Click to toggle. \u0026lt;/div\u0026gt; ); } } ReactDOM.render( \u0026lt;LikeButton /\u0026gt;, document.getElementById(\u0026#39;example\u0026#39;) );   构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。\n注意：\n constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用 JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件  27. React.forwardRef是什么？它有什么作用？ React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：\n 转发 refs 到 DOM 组件 在高阶组件中转发 refs  28. 类组件与函数组件有什么异同？ 相同点：\n组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。\n我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。\n不同点：\n 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。 从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。  二、数据管理 1. React setState 调用的原理 具体的执行过程如下（源码级解析）：\n 首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；  1 2 3 4 5 6  ReactComponent.prototype.setState = function (partialState, callback) { this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, \u0026#39;setState\u0026#39;); } };    enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；  1 2 3 4 5 6 7 8 9  enqueueSetState: function (publicInstance, partialState) { // 根据 this 拿到对应的组件实例  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, \u0026#39;setState\u0026#39;); // 这个 queue 对应的就是一个组件实例的 state 数组  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // enqueueUpdate 用来处理当前的组件实例  enqueueUpdate(internalInstance); }    在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  function enqueueUpdate(component) { ensureInjected(); // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段  if (!batchingStrategy.isBatchingUpdates) { // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件  batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”  dirtyComponents.push(component); if (component._updateBatchNumber == null) { component._updateBatchNumber = updateBatchNumber + 1; } }   注意：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n2. React setState 调用之后发生了什么？是同步还是异步？ （1）React中setState后发生了什么\n在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。\n在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\n如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。\n（2）setState 是同步还是异步的\n假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。\nsetState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。\n **异步：**在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。 **同步：**在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。  一般认为，做异步设计是为了性能优化、减少渲染次数：\n setState设计为异步，可以显著的提升性能。如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新； 如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；  3. React中的setState批量更新的过程是什么？ 调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。\n1 2 3 4 5 6 7 8 9 10  this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count+1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count+1的任务，count+1的任务] }); ↓ 合并 state，[count+1的任务] ↓ 执行 count+1的任务   需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。\n4. React中有使用过getDefaultProps吗？它有什么作用？ 通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：\n1 2 3 4 5 6 7 8 9 10  var ShowTitle = React.createClass({ getDefaultProps:function(){ return{ title : \u0026#34;React\u0026#34; } }, render : function(){ return \u0026lt;h1\u0026gt;{this.props.title}\u0026lt;/h1\u0026gt; } });   5. React中setState的第二个参数作用是什么？ setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：\n1 2 3 4 5  this.setState({ key1: newState1, key2: newState2, ... }, callback) // 第二个参数是 state 更新完成后的回调函数   6. React中的setState和replaceState的区别是什么？ **（1）**setState()\nsetState()用于设置状态对象，其语法如下：\n1  setState(object nextState[, function callback])    nextState，将要设置的新状态，该状态会和当前的state合并 callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。  合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\n**（2）**replaceState()\nreplaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：\n1  replaceState(object nextState[, function callback])    nextState，将要设置的新状态，该状态会替换当前的state。 callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。  **总结：**setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。\n7. 在React中组件的this.state和setState有什么区别？ this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。\n8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程 通过connect和mapStateToProps将state注入到组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { connect } from \u0026#39;react-redux\u0026#39; import { setVisibilityFilter } from \u0026#39;@/reducers/Todo/actions\u0026#39; import Link from \u0026#39;@/containers/Todo/components/Link\u0026#39; const mapStateToProps = (state, ownProps) =\u0026gt; ({ active: ownProps.filter === state.visibilityFilter }) const mapDispatchToProps = (dispatch, ownProps) =\u0026gt; ({ setFilter: () =\u0026gt; { dispatch(setVisibilityFilter(ownProps.filter)) } }) export default connect( mapStateToProps, mapDispatchToProps )(Link)   上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶\n state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。 ownProps 组件通过props传入的参数。  reducer 到组件经历的过程：\n reducer对action对象处理，更新组件状态，并将新的状态值返回store。 通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。  高阶组件实现源码∶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  import React from \u0026#39;react\u0026#39; import PropTypes from \u0026#39;prop-types\u0026#39; // 高阶组件 contect export const connect = (mapStateToProps, mapDispatchToProps) =\u0026gt; (WrappedComponent) =\u0026gt; { class Connect extends React.Component { // 通过对context调用获取store  static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { allProps: {} } } // 第一遍需初始化所有组件初始状态  componentWillMount() { const store = this.context.store this._updateProps() store.subscribe(() =\u0026gt; this._updateProps()); // 加入_updateProps()至store里的监听事件列表  } // 执行action后更新props，使组件可以更新至最新状态（类似于setState）  _updateProps() { const store = this.context.store; let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : {} // 防止 mapStateToProps 没有传入  let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : { dispatch: store.dispatch } // 防止 mapDispatchToProps 没有传入  this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props } }) } render() { return \u0026lt;WrappedComponent {...this.state.allProps} /\u0026gt; } } return Connect }   9. React组件的state和props有什么区别？ （1）props\nprops是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。\n（2）state\nstate的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。\n（3）区别\n props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。 props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。  10. React中的props为什么是只读的？ this.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。\n提到函数式编程就要提一个概念：纯函数。它有几个特点：\n 给定相同的输入，总是返回相同的输出。 过程没有副作用。 不依赖外部状态。  this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用\n11. 在React中组件的props改变时更新组件的有哪些方法？ 在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。\n**（1）**componentWillReceiveProps（已废弃）\n在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。\n这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n**（2）**getDerivedStateFromProps（16.3引入）\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n1 2 3 4 5 6 7 8 9 10 11  static getDerivedStateFromProps(nextProps, prevState) { const {type} = nextProps; // 当传入的type发生变化的时候，更新state if (type !== prevState.type) { return { type, }; } // 否则，对于state不进行任何操作 return null; }   12. React中怎么检验props？验证props的目的是什么？ React为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。\n1 2 3 4 5 6 7 8 9 10 11 12 13  import PropTypes from \u0026#39;prop-types\u0026#39;; class Greeting extends React.Component { render() { return ( \u0026lt;h1\u0026gt;Hello, {this.props.name}\u0026lt;/h1\u0026gt; ); } } Greeting.propTypes = { name: PropTypes.string };   当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。\n三、生命周期 1. React的生命周期有哪些？ React 通常将组件生命周期分为三个阶段：\n 装载阶段（Mount），组件第一次在DOM树中被渲染的过程； 更新过程（Update），组件状态发生变化，重新更新渲染的过程； 卸载过程（Unmount），组件从DOM树中被移除的过程；  1）组件挂载阶段 挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：\n constructor getDerivedStateFromProps render componentDidMount  （1）constructor 组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。\n如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数Constructor。\nconstructor中通常只做两件事：\n 初始化组件的 state 给事件处理方法绑定 this  1 2 3 4 5 6  constructor(props) { super(props); // 不要在构造函数中调用 setState，可以直接给 state 设置初始值 this.state = { counter: 0 } this.handleClick = this.handleClick.bind(this) }   （2）getDerivedStateFromProps 1  static getDerivedStateFromProps(props, state)   这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。\n该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 当 props.counter 变化时，赋值给 state class App extends React.Component { constructor(props) { super(props) this.state = { counter: 0 } } static getDerivedStateFromProps(props, state) { if (props.counter !== state.counter) { return { counter: props.counter } } return null } handleClick = () =\u0026gt; { this.setState({ counter: this.state.counter + 1 }) } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 onClick={this.handleClick}\u0026gt;Hello, world!{this.state.counter}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } }   现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 这里只列出需要变化的地方 class App extends React.Component { constructor(props) { super(props) this.state = { // 增加一个 preCounter 来记录之前的 props 传来的值 preCounter: 0, counter: 0 } } static getDerivedStateFromProps(props, state) { // 跟 state.preCounter 进行比较 if (props.counter !== state.preCounter) { return { counter: props.counter, preCounter: props.counter } } return null } handleClick = () =\u0026gt; { this.setState({ counter: this.state.counter + 1 }) } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 onClick={this.handleClick}\u0026gt;Hello, world!{this.state.counter}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } }   （3）render render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：\n React 元素：这里包括原生的 DOM 以及 React 组件； 数组和 Fragment（片段）：可以返回多个元素； Portals（插槽）：可以将子元素渲染到不同的 DOM 子树种； 字符串和数字：被渲染成 DOM 中的 text 节点； 布尔值或 null：不渲染任何内容。  （4）componentDidMount() componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：\n 执行依赖于DOM的操作； 发送网络请求；（官方建议） 添加订阅消息（会在componentWillUnmount取消订阅）；  如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。\n在组件装载之后，将计数数字变为1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class App extends React.Component { constructor(props) { super(props) this.state = { counter: 0 } } componentDidMount () { this.setState({ counter: 1 }) } render () { return ( \u0026lt;div className=\u0026#34;counter\u0026#34;\u0026gt; counter值: { this.state.counter } \u0026lt;/div\u0026gt; ) } }   2）组件更新阶段 当组件的 props 改变了，或组件内部调用了 setState/forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：\n getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate  （1）shouldComponentUpdate 1  shouldComponentUpdate(nextProps, nextState)   在说这个生命周期函数之前，来看两个问题：\n setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：  1  this.setState({number: this.state.number})    如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？  第一个问题答案是 会 ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。\n那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldComponentUpdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。\n**注意：**添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。\n（2）getSnapshotBeforeUpdate 1  getSnapshotBeforeUpdate(prevProps, prevState)   这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。\n（3）componentDidUpdate componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：\n 当组件更新后，对 DOM 进行操作； 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。  1  componentDidUpdate(prevProps, prevState, snapshot){}   该方法有三个参数：\n prevProps: 更新前的props prevState: 更新前的state snapshot: getSnapshotBeforeUpdate()生命周期的返回值  3）组件卸载阶段 卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：\n 清除 timer，取消网络请求或清除 取消在 componentDidMount() 中创建的订阅等；  这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。\n4）错误处理阶段 componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶\n error：抛出的错误。 info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息  React常见的生命周期如下：\nReact常见生命周期的过程大致如下：\n 挂载阶段，首先执行constructor构造方法，来创建组件 创建完成之后，就会执行render方法，该方法会返回需要渲染的内容 随后，React会将需要渲染的内容挂载到DOM树上 挂载完成之后就会执行****componentDidMount生命周期函数 如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数 render函数重新执行之后，就会重新进行DOM树的挂载 挂载完成之后就会执行****componentDidUpdate生命周期函数 当移除组件时，就会执行****componentWillUnmount生命周期函数  React主要生命周期总结：\n getDefaultProps：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props； getInitialState：用于初始化组件的 state 值； componentWillMount：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 React16 直接废弃了这个生命周期，足见其鸡肋程度了； render：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可； componentDidMount：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。  2. React 废弃了哪些生命周期？为什么？ 被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手\n1) componentWillMount\n首先这个函数的功能完全可以使用componentDidMount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willMount 中订阅事件，但在服务端这并不会执行 willUnMount事件，也就是说服务端会导致内存泄漏所以componentWilIMount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentWilMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API\n2) componentWillReceiveProps\n在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWilReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React引入了第一个新的生命周期：getDerivedStateFromProps。它有以下的优点∶\n getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码 开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况 基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。  3) componentWillUpdate\n与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调 。 但不论是 componentWilReceiveProps 还 是 componentWilUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类 似， componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate 就可以解决这个问题。\n另外一种情况则是需要获取DOM元素状态，但是由于在fber中，render可打断，可能在wilMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getSnapshotBeforeUpdate(prevProps, prevState)\n4) getSnapshotBeforeUpdate(prevProps, prevState)\n返回的值作为componentDidUpdate的第三个参数。与willMount不同的是，getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class ScrollingList extends React.Component { constructor(props) { super(props); this.listRef = React.createRef(); } getSnapshotBeforeUpdate(prevProps, prevState) { // 我们是否在 list 中添加新的 items ？ // 捕获滚动位置以便我们稍后调整滚动位置。 if (prevProps.list.length \u0026lt; this.props.list.length) { const list = this.listRef.current; return list.scrollHeight - list.scrollTop; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items， // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。 //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值） if (snapshot !== null) { const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; } } render() { return ( \u0026lt;div ref={this.listRef}\u0026gt;{/* ...contents... */}\u0026lt;/div\u0026gt; ); } }   3. React 16.X 中 props 改变后在哪个生命周期中处理 在getDerivedStateFromProps中进行处理。\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n1 2 3 4 5 6 7 8 9 10 11  static getDerivedStateFromProps(nextProps, prevState) { const {type} = nextProps; // 当传入的type发生变化的时候，更新state if (type !== prevState.type) { return { type, }; } // 否则，对于state不进行任何操作 return null; }   4. React 性能优化在哪个生命周期？它优化的原理是什么？ react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。\n使用方法如下：\n1 2 3 4 5 6  shouldComponentUpdate(nexrProps) { if (this.props.num === nexrProps.num) { return false } return true; }   shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。\n需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。\n面对这个问题，可以使用如下方法进行解决：\n（1）使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：\n1 2 3 4 5  const o2 = Object.assign({},this.state.obj) o2.student.count = \u0026#39;00000\u0026#39;; this.setState({ obj: o2, })   （2）使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。\n1 2 3 4 5  const o2 = JSON.parse(JSON.stringify(this.state.obj)) o2.student.count = \u0026#39;00000\u0026#39;; this.setState({ obj: o2, })   5. state 和 props 触发更新的生命周期分别有什么区别？ state 更新流程：\n这个过程当中涉及的函数：\n shouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；   注意：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()\n  componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate 是 React16 废弃的三个生命周期之一。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事； componentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。  props 更新流程：\n相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：\n componentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。该生命周期是 React16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。  6. React中发起网络请求应该在哪个生命周期中进行？为什么？ 对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。\n如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。\n**react的生命周期：**constructor() -\u0026gt; componentWillMount() -\u0026gt; render() -\u0026gt; componentDidMount()\n上面这些方法的调用是有次序的，由上而下依次调用。\n constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。 componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。 componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。  总结：\n 跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。 在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。 react16.0以后，componentWillMount可能会被执行多次。  7. React 16中新生命周期有哪些 关于 React16 开始应用的新生命周期：\n可以看出，React16 自上而下地对生命周期做了另一种维度的解读：\n Render 阶段：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的； Pre-commit阶段：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了； Commit 阶段：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。  与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：\n  挂载过程：\n   constructor getDerivedStateFromProps render componentDidMount    更新过程：\n   getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate    卸载过程：\n   componentWillUnmount    四、组件通信 React组件间通信常见的几种情况:\n 父组件向子组件通信 子组件向父组件通信 跨级组件通信 非嵌套关系的组件通信  1. 父子组件的通信方式？ 父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。\n1 2 3 4 5 6 7 8  // 子组件: Child const Child = props =\u0026gt;{ return \u0026lt;p\u0026gt;{props.name}\u0026lt;/p\u0026gt; } // 父组件 Parent const Parent = ()=\u0026gt;{ return \u0026lt;Child name=\u0026#34;react\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; }   子组件向父组件通信：: props+回调的方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 子组件: Child const Child = props =\u0026gt;{ const cb = msg =\u0026gt;{ return ()=\u0026gt;{ props.callback(msg) } } return ( \u0026lt;button onClick={cb(\u0026#34;你好!\u0026#34;)}\u0026gt;你好\u0026lt;/button\u0026gt; ) } // 父组件 Parent class Parent extends Component { callback(msg){ console.log(msg) } render(){ return \u0026lt;Child callback={this.callback.bind(this)}\u0026gt;\u0026lt;/Child\u0026gt; } }   2. 跨级组件的通信方式？ 父组件向子组件的子组件通信，向更深层子组件通信：\n 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。 使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // context方式实现跨级组件通信 // Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据 const BatteryContext = createContext(); // 子组件的子组件 class GrandChild extends Component { render(){ return ( \u0026lt;BatteryContext.Consumer\u0026gt; { color =\u0026gt; \u0026lt;h1 style={{\u0026#34;color\u0026#34;:color}}\u0026gt;我是红色的:{color}\u0026lt;/h1\u0026gt; } \u0026lt;/BatteryContext.Consumer\u0026gt; ) } } // 子组件 const Child = () =\u0026gt;{ return ( \u0026lt;GrandChild/\u0026gt; ) } // 父组件 class Parent extends Component { state = { color:\u0026#34;red\u0026#34; } render(){ const {color} = this.state return ( \u0026lt;BatteryContext.Provider value={color}\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/BatteryContext.Provider\u0026gt; ) } }   3. 非嵌套关系组件的通信方式？ 即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。\n 可以使用自定义事件通信（发布订阅模式） 可以通过redux等进行全局状态管理 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。  4. 如何解决 props 层级过深的问题  使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props； 使用Redux等状态库。  5. 组件通信的方式有哪些  ⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯 ⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中 兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信 跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信 全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态  五、路由 1. React-Router的实现原理是什么？ 客户端路由实现的思想：\n  基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化\n   改变 hash 可以直接通过 location.hash=xxx    基于 H5 history 路由：\n   改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API 监听 url 的变化可以通过自定义事件触发实现    react-router 实现的思想：\n 基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知 通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render  2. 如何配置 React-Router 实现路由切换 （1）使用  组件\n路由匹配是通过比较  的 path 属性和当前地址的 pathname 来实现的。当一个  匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的  将始终被匹配。\n1 2 3 4  // when location = { pathname: \u0026#39;/about\u0026#39; } \u0026lt;Route path=\u0026#39;/about\u0026#39; component={About}/\u0026gt; // renders \u0026lt;About/\u0026gt; \u0026lt;Route path=\u0026#39;/contact\u0026#39; component={Contact}/\u0026gt; // renders null \u0026lt;Route component={Always}/\u0026gt; // renders \u0026lt;Always/\u0026gt;   （2）结合使用  组件和  组件\n 用于将  分组。\n1 2 3 4 5  \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; component={Home} /\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34; component={About} /\u0026gt; \u0026lt;Route path=\u0026#34;/contact\u0026#34; component={Contact} /\u0026gt; \u0026lt;/Switch\u0026gt;    不是分组  所必须的，但他通常很有用。 一个  会遍历其所有的子 元素，并仅渲染与当前地址匹配的第一个元素。\n（3）使用 、 、 组件\n 组件来在你的应用程序中创建链接。无论你在何处渲染一个  ，都会在应用程序的 HTML 中渲染锚（）。\r1 2  \u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; // \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Home\u0026lt;/a\u0026gt;    是一种特殊类型的  当它的 to属性与当前地址匹配时，可以将其定义为\u0026quot;活跃的\u0026rdquo;。\n1 2 3 4 5  // location = { pathname: \u0026#39;/react\u0026#39; } \u0026lt;NavLink to=\u0026#34;/react\u0026#34; activeClassName=\u0026#34;hurray\u0026#34;\u0026gt; React \u0026lt;/NavLink\u0026gt; // \u0026lt;a href=\u0026#39;/react\u0026#39; className=\u0026#39;hurray\u0026#39;\u0026gt;React\u0026lt;/a\u0026gt;   当我们想强制导航时，可以渲染一个，当一个渲染时，它将使用它的to属性进行定向。\n3. React-Router怎么设置重定向？ 使用组件实现路由的重定向：\n1 2 3 4  \u0026lt;Switch\u0026gt; \u0026lt;Redirect from=\u0026#39;/users/:id\u0026#39; to=\u0026#39;/users/profile/:id\u0026#39;/\u0026gt; \u0026lt;Route path=\u0026#39;/users/profile/:id\u0026#39; component={Profile}/\u0026gt; \u0026lt;/Switch\u0026gt;   当请求 /users/:id 被重定向去 '/users/profile/:id'：\n 属性 from: string：需要匹配的将要被重定向路径。 属性 to: string：重定向的 URL 字符串 属性 to: object：重定向的 location 对象 属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。  4. react-router 里的 Link 标签和 a 标签的区别 从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶\n是react-router 里实现路由跳转的链接，一般配合 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转， 的“跳转”行为只会触发相匹配的对应的页面内容更新，而不会刷新整个页面。\r做了3件事情:\r 有onclick那就执行onclick click的时候阻止a标签默认事件 根据跳转href(即是to)，用history (web前端路由两种方式之一，history \u0026amp; hash)跳转，此时只是链接变了，并没有刷新页面而标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。  a标签默认事件禁掉之后做了什么才实现了跳转?\n1 2 3 4 5 6  let domArr = document.getElementsByTagName(\u0026#39;a\u0026#39;) [...domArr].forEach(item=\u0026gt;{ item.addEventListener(\u0026#39;click\u0026#39;,function () { location.href = this.href }) })   5. React-Router如何获取URL的参数和历史对象？ （1）获取URL的参数\n get传值  路由配置还是普通的配置，如：'admin'，传参方式如：'admin?id='1111''。通过this.props.location.search获取url获取到一个字符串'?id='1111'\n可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。\n 动态路由传值  路由需要配置成动态路由：如path='/admin/:id'，传参方式，如'admin/111'。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取\n 通过query或state传值  传参方式如：在Link组件的to属性中可以传递对象{pathname:'/admin',query:'111',state:'111'};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。\n（2）获取历史对象\n 如果React \u0026gt;= 16.8 时可以使用 React Router中提供的Hooks  1 2  import { useHistory } from \u0026#34;react-router-dom\u0026#34;; let history = useHistory();   2.使用this.props.history获取历史对象\n1  let history = this.props.history;   6. React-Router 4怎样在路由变化时重新渲染同一个组件？ 当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class NewsList extends Component { componentDidMount () { this.fetchData(this.props.location); } fetchData(location) { const type = location.pathname.replace(\u0026#39;/\u0026#39;, \u0026#39;\u0026#39;) || \u0026#39;top\u0026#39; this.props.dispatch(fetchListData(type)) } componentWillReceiveProps(nextProps) { if (nextProps.location.pathname != this.props.location.pathname) { this.fetchData(nextProps.location); } } render () { ... } }   利用生命周期componentWillReceiveProps，进行重新render的预处理操作。\n7. React-Router的路由有几种模式？ React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：\n BrowserRouter 创建的 URL 格式：http://xxx.com/path HashRouter 创建的 URL 格式：http://xxx.com/#/path  （1）BrowserRouter\n它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的：\n1 2 3 4 5 6  \u0026lt;BrowserRouter basename={string} forceRefresh={bool} getUserConfirmation={func} keyLength={number} /\u0026gt;   其中的属性如下：\n basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；  1 2 3  \u0026lt;BrowserRouter basename=\u0026#34;/calendar\u0026#34;\u0026gt; \u0026lt;Link to=\u0026#34;/today\u0026#34; /\u0026gt; \u0026lt;/BrowserRouter\u0026gt;   等同于\n1  \u0026lt;a href=\u0026#34;/calendar/today\u0026#34; /\u0026gt;    forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能； getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；  1 2 3 4 5 6  // 这是默认的确认函数 const getConfirmation = (message, callback) =\u0026gt; { const allowTransition = window.confirm(message); callback(allowTransition); } \u0026lt;BrowserRouter getUserConfirmation={getConfirmation} /\u0026gt;    需要配合\u0026lt;Prompt\u0026gt; 一起使用。\n  KeyLength 用来设置 Location.Key 的长度。  （2）HashRouter\n使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：\n1 2 3 4 5  \u0026lt;HashRouter basename={string} getUserConfirmation={func} hashType={string} /\u0026gt;   其中的参数如下：\n  basename, getUserConfirmation 和 BrowserRouter 功能一样；\n  hashType window.location.hash 使用的 hash 类型，有如下几种：\n   slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops； noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops； hashbang - Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。    8. React-Router 4的Switch有什么用？ Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 \u0026lt;Route\u0026gt; 或 \u0026lt;Redirect\u0026gt;，它里面不能放其他元素。\n假如不加 \u0026lt;Switch\u0026gt; ：\n1 2 3 4  import { Route } from \u0026#39;react-router-dom\u0026#39; \u0026lt;Route path=\u0026#34;/\u0026#34; component={Home}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/login\u0026#34; component={Login}\u0026gt;\u0026lt;/Route\u0026gt;   Route 组件的 path 属性用于匹配路径，因为需要匹配 / 到 Home，匹配 /login 到 Login，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “/login” 时，\u0026lt;Route path=\u0026quot;/\u0026quot; /\u0026gt;和\u0026lt;Route path=\u0026quot;/login\u0026quot; /\u0026gt; 都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 \u0026lt;Switch\u0026gt; 来做到只显示一个匹配组件：\n1 2 3 4 5 6  import { Switch, Route} from \u0026#39;react-router-dom\u0026#39; \u0026lt;Switch\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; component={Home}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/login\u0026#34; component={Login}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt;   此时，再访问 “/login” 路径时，却只显示了 Home 组件。这是就用到了exact属性，它的作用就是精确匹配路径，经常与\u0026lt;Switch\u0026gt; 联合使用。只有当 URL 和该 \u0026lt;Route\u0026gt; 的 path 属性完全一致的情况下才能匹配上：\n1 2 3 4 5 6  import { Switch, Route} from \u0026#39;react-router-dom\u0026#39; \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; component={Home}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route exact path=\u0026#34;/login\u0026#34; component={Login}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt;   六、Redux 1. 对 Redux 的理解，主要解决什么问题 React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。\n在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。\nRedux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。\n主要解决的问题：\n单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。\n2. Redux 原理及工作流程 （1）原理\nRedux源码主要分为以下几个模块文件\n compose.js 提供从右到左进行函数式编程 createStore.js 提供作为生成唯一store的函数 combineReducers.js 提供合并多个reducer的函数，保证store的唯一性 bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作 applyMiddleware.js 这个方法通过中间件来增强dispatch的功能  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  const actionTypes = { ADD: \u0026#39;ADD\u0026#39;, CHANGEINFO: \u0026#39;CHANGEINFO\u0026#39;, } const initState = { info: \u0026#39;初始化\u0026#39;, } export default function initReducer(state=initState, action) { switch(action.type) { case actionTypes.CHANGEINFO: return { ...state, info: action.preload.info || \u0026#39;\u0026#39;, } default: return { ...state }; } } export default function createStore(reducer, initialState, middleFunc) { if (initialState \u0026amp;\u0026amp; typeof initialState === \u0026#39;function\u0026#39;) { middleFunc = initialState; initialState = undefined; } let currentState = initialState; const listeners = []; if (middleFunc \u0026amp;\u0026amp; typeof middleFunc === \u0026#39;function\u0026#39;) { // 封装dispatch return middleFunc(createStore)(reducer, initialState); } const getState = () =\u0026gt; { return currentState; } const dispatch = (action) =\u0026gt; { currentState = reducer(currentState, action); listeners.forEach(listener =\u0026gt; { listener(); }) } const subscribe = (listener) =\u0026gt; { listeners.push(listener); } return { getState, dispatch, subscribe } }   （2）工作流程\n const store= createStore（fn）生成数据; action: {type: Symble(\u0026lsquo;action01), payload:\u0026lsquo;payload\u0026rsquo; }定义行为; dispatch发起action：store.dispatch(doSomething(\u0026lsquo;action001\u0026rsquo;)); reducer：处理action，返回新的state;  通俗点解释：\n 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State State—旦有变化，Store就会调用监听函数，来更新View  以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。\n3. Redux 中异步的请求怎么处理 可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。\n（1）使用react-thunk中间件\nredux-thunk优点**:**\n 体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码 使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单  redux-thunk缺陷**:**\n 样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的 耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理 功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装  使用步骤：\n 配置中间件，在store的创建中配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14  import {createStore, applyMiddleware, compose} from \u0026#39;redux\u0026#39;; import reducer from \u0026#39;./reducer\u0026#39;; import thunk from \u0026#39;redux-thunk\u0026#39; // 设置调试工具 const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; // 设置中间件 const enhancer = composeEnhancers( applyMiddleware(thunk) ); const store = createStore(reducer, enhancer); export default store;    添加一个返回函数的actionCreator，将异步请求逻辑放在里面  1 2 3 4 5 6 7 8 9 10 11 12 13  /** 发送get请求，并生成相应action，更新store的函数 @param url {string} 请求地址 @param func {function} 真正需要生成的action对应的actionCreator @return {function} */ // dispatch为自动接收的store.dispatch函数 export const getHttpAction = (url, func) =\u0026gt; (dispatch) =\u0026gt; { axios.get(url).then(function(res){ const action = func(res.data) dispatch(action) }) }    生成action，并发送action  1 2 3 4 5  componentDidMount(){ var action = getHttpAction(\u0026#39;/getData\u0026#39;, getInitTodoItemAction) // 发送函数类型的action时，该action的函数体会自动执行 store.dispatch(action) }   （2）使用redux-saga中间件\nredux-saga优点**:**\n 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中 action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理 功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤ 灵活: redux-saga可以将多个Saga可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步flow 易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等  redux-saga缺陷**:**\n 额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想 体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右 功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码 ts⽀持不友好: yield⽆法返回TS类型  redux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：\n 配置中间件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import {createStore, applyMiddleware, compose} from \u0026#39;redux\u0026#39;; import reducer from \u0026#39;./reducer\u0026#39;; import createSagaMiddleware from \u0026#39;redux-saga\u0026#39; import TodoListSaga from \u0026#39;./sagas\u0026#39; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; const sagaMiddleware = createSagaMiddleware() const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware) ); const store = createStore(reducer, enhancer); sagaMiddleware.run(TodoListSaga) export default store;    将异步请求放在sagas.js中  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import {takeEvery, put} from \u0026#39;redux-saga/effects\u0026#39; import {initTodoList} from \u0026#39;./actionCreator\u0026#39; import {GET_INIT_ITEM} from \u0026#39;./actionTypes\u0026#39; import axios from \u0026#39;axios\u0026#39; function* func(){ try{ // 可以获取异步返回数据 const res = yield axios.get(\u0026#39;/getData\u0026#39;) const action = initTodoList(res.data) // 将action发送到reducer yield put(action) }catch(e){ console.log(\u0026#39;网络请求失败\u0026#39;) } } function* mySaga(){ // 自动捕获GET_INIT_ITEM类型的action，并执行func yield takeEvery(GET_INIT_ITEM, func) } export default mySaga    发送action  1 2 3 4  componentDidMount(){ const action = getInitTodoItemAction() store.dispatch(action) }   4. Redux 怎么实现属性传递，介绍下原理 react-redux 数据传输∶ view\u0026ndash;\u0026gt;action\u0026ndash;\u0026gt;reducer\u0026ndash;\u0026gt;store\u0026ndash;\u0026gt;view。看下点击事件的数据是如何通过redux传到view上：\n view 上的AddClick 事件通过mapDispatchToProps 把数据传到action \u0026mdash;\u0026gt; click:()=\u0026gt;dispatch(ADD) action 的ADD 传到reducer上 reducer传到store上 const store = createStore(reducer); store再通过 mapStateToProps 映射穿到view上text:State.text  代码示例∶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import { createStore } from \u0026#39;redux\u0026#39;; import { Provider, connect } from \u0026#39;react-redux\u0026#39;; class App extends React.Component{ render(){ let { text, click, clickR } = this.props; return( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;数据:已有人{text}\u0026lt;/div\u0026gt; \u0026lt;div onClick={click}\u0026gt;加人\u0026lt;/div\u0026gt; \u0026lt;div onClick={clickR}\u0026gt;减人\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } } const initialState = { text:5 } const reducer = function(state,action){ switch(action.type){ case \u0026#39;ADD\u0026#39;: return {text:state.text+1} case \u0026#39;REMOVE\u0026#39;: return {text:state.text-1} default: return initialState; } } let ADD = { type:\u0026#39;ADD\u0026#39; } let Remove = { type:\u0026#39;REMOVE\u0026#39; } const store = createStore(reducer); let mapStateToProps = function (state){ return{ text:state.text } } let mapDispatchToProps = function(dispatch){ return{ click:()=\u0026gt;dispatch(ADD), clickR:()=\u0026gt;dispatch(Remove) } } const App1 = connect(mapStateToProps,mapDispatchToProps)(App); ReactDOM.render( \u0026lt;Provider store = {store}\u0026gt; \u0026lt;App1\u0026gt;\u0026lt;/App1\u0026gt; \u0026lt;/Provider\u0026gt;,document.getElementById(\u0026#39;root\u0026#39;) )   5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？ Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→\u0026gt; action -\u0026gt; reducer -\u0026gt; store 的数据流加上中间件后变成了 view -\u0026gt; action -\u0026gt; middleware -\u0026gt; reducer -\u0026gt; store ，在这一环节可以做一些\u0026quot;副作用\u0026quot;的操作，如异步请求、打印日志等。\napplyMiddleware源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export default function applyMiddleware(...middlewares) { return createStore =\u0026gt; (...args) =\u0026gt; { // 利用传入的createStore和reducer和创建一个store const store = createStore(...args) let dispatch = () =\u0026gt; { throw new Error() } const middlewareAPI = { getState: store.getState, dispatch: (...args) =\u0026gt; dispatch(...args) } // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍 const chain = middlewares.map(middleware =\u0026gt; middleware(middlewareAPI)) // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch } } }   从applyMiddleware中可以看出∶\n redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。 柯里化函数两端一个是 middewares，一个是store.dispatch  6. Redux 请求中间件如何处理并发 使用redux-Saga\nredux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：\n takeEvery  可以让多个 saga 任务并行被 fork 执行。\n1 2 3 4 5 6 7 8 9 10 11  import { fork, take } from \u0026#34;redux-saga/effects\u0026#34; const takeEvery = (pattern, saga, ...args) =\u0026gt; fork(function*() { while (true) { const action = yield take(pattern) yield fork(saga, ...args.concat(action)) } })    takeLatest  takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。\n在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { cancel, fork, take } from \u0026#34;redux-saga/effects\u0026#34; const takeLatest = (pattern, saga, ...args) =\u0026gt; fork(function*() { let lastTask while (true) { const action = yield take(pattern) if (lastTask) { yield cancel(lastTask) // 如果任务已经结束，则 cancel 为空操作 } lastTask = yield fork(saga, ...args.concat(action)) } })   7. Redux 状态管理器和变量挂载到 window 中有什么区别 两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。\n随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。\n如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。\n8. mobox 和 redux 有什么区别？ （1）共同点\n 为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态; 某一状态只有一个可信数据来源（通常命名为store，指状态容器）; 操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）; 支持将store与React组件连接，如react-redux，mobx- react;  （2）区别\nRedux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶\n Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶  ​ o type∶ action 类型;\n​ o payload∶ 负载数据;\n Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态; Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶  ​ o 维护应用状态并支持访问状态(getState());\n​ o 支持监听action的分发，更新状态(dispatch(action));\n​ o 支持订阅store的变更(subscribe(listener));\n 异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;  Mobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶\n Action∶定义改变状态的动作函数，包括如何变更状态; Store∶ 集中管理模块状态（State）和动作(action) Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据  对比总结：\n redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中 redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作 redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改 mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用 mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易  9. Redux 和 Vuex 有什么区别，它们的共同思想 （1）Redux 和 Vuex区别\n Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可 Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可 Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-\u0026gt;store改变（vue检测到数据变化自动渲染）  通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n（2）共同思想\n 单—的数据源 变化可以预测  本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。\n10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理? redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })=\u0026gt; next =\u0026gt; action。\n11. Redux中的connect有什么作用 connect负责连接React和Redux\n（1）获取state\nconnect 通过 context获取 Provider 中的 store，通过 store.getState() 获取整个store tree 上所有state\n（2）包装原组件\n将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent\n（3）监听store tree变化\nconnect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发Connect及其子组件的重新渲染\n七、Hooks 1. 对 React Hook 的理解，它的实现原理是什么 React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组****件两种组件形式的思考和侧重。\n**（1）类组件：**所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class DemoClass extends React.Component { state = { text: \u0026#34;\u0026#34; }; componentDidMount() { //... } changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; render() { return ( \u0026lt;div className=\u0026#34;demoClass\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{this.state.text}\u0026lt;/p\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt;修改\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } }   可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。\n当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。\n（2）函数组件：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：\n1 2 3 4 5 6 7 8  function DemoFunction(props) { const { text } = props return ( \u0026lt;div className=\u0026#34;demoFunction\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`函数组件接收的内容：[${text}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。\n通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：\n 类组件需要继承 class，函数组件不需要； 类组件可以访问生命周期方法，函数组件不能； 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以； 类组件中可以定义并维护 state（状态），而函数组件不可以；  除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，类组件的能力边界明显强于函数组件。\n实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念：\nReact 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。**函数组件就真正地将数据和渲染绑定到了一起。**函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。\n为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。\nReact-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。\n函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。\n如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。\n2. 为什么 useState 要使用数组而不是对象 useState 的用法：\n1  const [count, setCount] = useState(0)   可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？\n这里用到了解构赋值，所以先来看一下ES6 的解构赋值：\n数组的解构赋值 1 2 3 4 5  const foo = [1, 2, 3]; const [one, two, three] = foo; console.log(one); // 1 console.log(two); // 2 console.log(three); // 3   对象的解构赋值 1 2 3 4 5 6 7  const user = { id: 888, name: \u0026#34;xiaoxin\u0026#34; }; const { id, name } = user; console.log(id); // 888 console.log(name); // \u0026#34;xiaoxin\u0026#34;   看完这两个例子，答案应该就出来了：\n 如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净 如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值  下面来看看如果 useState 返回对象的情况：\n1 2 3 4  // 第一次使用 const { state, setState } = useState(false); // 第二次使用 const { state: counter, setState: setCounter } = useState(0)   这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。\n总结：useState 返回的是 array 而不是 object 的原因就是为了降低使用的复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。\n3. React Hooks 解决了哪些问题？ React Hooks 主要解决了以下问题：\n（1）在组件之间复用状态逻辑很难\nReact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。\n可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\n（2）复杂组件变得难以理解\n在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n（3）难以理解的 class\n除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术\n4. React Hook 的使用限制有哪些？ React Hooks 的限制主要有两条：\n 不要在循环、条件或嵌套函数中调用 Hook； 在 React 的函数组件中调用 Hook。  那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。\n 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。 人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。  这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。\n那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。\n这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。\n5. useEffect 与 useLayoutEffect 的区别 （1）共同点\n **运用效果：**useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。 **使用方式：**useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。  （2）不同点\n **使用场景：**useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。 **使用效果：**useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。  在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。\n6. React Hooks在平时开发中需要注意的问题和原因 （1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook\n这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。\n（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑\n使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  function Indicatorfilter() { let [num,setNums] = useState([0,1,2,3]) const test = () =\u0026gt; { // 这里坑是直接采用push去更新num // setNums(num)是无法更新num的 // 必须使用num = [...num ,1] num.push(1) // num = [...num ,1] setNums(num) } return ( \u0026lt;div className=\u0026#39;filter\u0026#39;\u0026gt; \u0026lt;div onClick={test}\u0026gt;测试\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {num.map((item,index) =\u0026gt; ( \u0026lt;div key={index}\u0026gt;{item}\u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } class Indicatorfilter extends React.Component\u0026lt;any,any\u0026gt;{ constructor(props:any){ super(props) this.state = { nums:[1,2,3] } this.test = this.test.bind(this) } test(){ // class采用同样的方式是没有问题的 this.state.nums.push(1) this.setState({ nums: this.state.nums }) } render(){ let {nums} = this.state return( \u0026lt;div\u0026gt; \u0026lt;div onClick={this.test}\u0026gt;测试\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {nums.map((item:any,index:number) =\u0026gt; ( \u0026lt;div key={index}\u0026gt;{item}\u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } }   （3）useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect\nTableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const TableDeail = ({ columns, }:TableData) =\u0026gt; { const [tabColumn, setTabColumn] = useState(columns) } // 正确的做法是通过useEffect改变这个值 const TableDeail = ({ columns, }:TableData) =\u0026gt; { const [tabColumn, setTabColumn] = useState(columns) useEffect(() =\u0026gt;{setTabColumn(columns)},[columns]) }   （4）善用useCallback\n父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。\n（5）不要滥用useContext\n可以使用基于 useContext 封装的状态管理工具。\n7. React Hooks 和生命周期的关系？ 函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。\n但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。\n即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。\n下面是具体的 class 与 Hooks 的生命周期对应关系：\n constructor：函数组件不需要构造函数，可以通过调用 **useState** **来初始化 state**。如果计算的代价比较昂贵，也可以传一个函数给 useState。  1  const [num, UpdateNum] = useState(0)    getDerivedStateFromProps：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。  1 2 3 4 5 6 7 8 9 10  function ScrollView({row}) { let [isScrollingDown, setIsScrollingDown] = useState(false); let [prevRow, setPrevRow] = useState(null); if (row !== prevRow) { // Row 自上次渲染以来发生过改变。更新 isScrollingDown。 setIsScrollingDown(prevRow !== null \u0026amp;\u0026amp; row \u0026gt; prevRow); setPrevRow(row); } return `Scrolling down: ${isScrollingDown}`; }   React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。\n shouldComponentUpdate：可以用 **React.memo** 包裹一个组件来对它的 props 进行浅比较  1 2 3  const Button = React.memo((props) =\u0026gt; { // 具体的组件 });   注意：**React.memo** **等效于** ``**PureComponent**，它只浅比较 props。这里也可以使用 useMemo 优化每一个节点。\n render：这是函数组件体本身。 componentDidMount, componentDidUpdate： useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。  1 2 3 4 5 6 7 8 9 10 11 12  // componentDidMount useEffect(()=\u0026gt;{ // 需要在 componentDidMount 执行的内容 }, []) useEffect(() =\u0026gt; { // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容 document.title = `You clicked ${count} times`; return () =\u0026gt; { // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新） // 以及 componentWillUnmount 执行的内容 } // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关 }, [count]); // 仅在 count 更改时更新   请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便\n componentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数  1 2 3 4 5 6 7  // componentDidMount/componentWillUnmount useEffect(()=\u0026gt;{ // 需要在 componentDidMount 执行的内容 return function cleanup() { // 需要在 componentWillUnmount 执行的内容 } }, [])    componentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。     class 组件 Hooks 组件     constructor useState   getDerivedStateFromProps useState 里面 update 函数   shouldComponentUpdate useMemo   render 函数本身   componentDidMount useEffect   componentDidUpdate useEffect   componentWillUnmount useEffect 里面返回的函数   componentDidCatch 无   getDerivedStateFromError 无    八、虚拟DOM 1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？ 从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n为什么要用 Virtual DOM：\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n 真实DOM∶ 生成HTML字符串＋ 重建所有的DOM元素 Virtual DOM∶ 生成vNode＋ DOMDiff＋必要的DOM更新  Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。\n（2）跨平台\nVirtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n2. React diff 算法的原理是什么？ 实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。\n具体的流程如下：\n 真实的 DOM 首先会映射为虚拟 DOM； 当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等； 根据 patch 去更新真实的 DOM，反馈到用户的界面上。  一个简单的例子：\n1 2 3 4 5 6 7 8 9  import React from \u0026#39;react\u0026#39; export default class ExampleComponent extends React.Component { render() { if(this.props.isVisible) { return \u0026lt;div className=\u0026#34;visible\u0026#34;\u0026gt;visbile\u0026lt;/div\u0026gt;; } return \u0026lt;div className=\u0026#34;hidden\u0026#34;\u0026gt;hidden\u0026lt;/div\u0026gt;; } }   这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。\n1  \u0026lt;div class=\u0026#34;visible\u0026#34;\u0026gt;visbile\u0026lt;/div\u0026gt;   当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。这样一个生成补丁、更新差异的过程统称为 diff 算法。\ndiff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：\n策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）\n这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。\n策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。****（基于组件进行对比）\n在组件比对的过程中：\n 如果组件是同一类型则进行树比对； 如果不是则直接放入补丁中。  只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。\n策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。****（基于节点进行对比）\n元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。\n3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的 Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。\n在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。\n注意事项：\n key值一定要和具体的元素—一对应； 尽量不要用数组的index去作为key； 不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。  4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么 虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。\n在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n5. React 与 Vue 的 diff 算法有何不同？ diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。\nReact 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。\n 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。  以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。\nVue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。\n九、其他 1. React组件命名推荐的方式是哪个？ 通过引用而不是使用来命名组件displayName。\n使用displayName命名组件：\n1 2 3 4  export default React.createClass({ displayName: \u0026#39;TodoApp\u0026#39;, // ... })   React推荐的方法：\n1 2 3  export default class TodoApp extends React.Component { // ... }   2. react 最新版本解决了什么问题，增加了哪些东西 React 16.x的三大新特性 Time Slicing、Suspense、 hooks\n Time Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能 **Suspense （解决网络IO问题）**和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式 提供了一个内置函数componentDidCatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。  （1）React16.8\n加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：\n 在组件间复用状态逻辑很难 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。 class组件的this指向问题 难以记忆的生命周期  hooks很好的解决了上述问题，hooks提供了很多方法\n useState 返回有状态值，以及更新这个状态值的函数 useEffect 接受包含命令式，可能有副作用代码的函数。 useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值， useReducer useState 的替代方案。接受类型为 （state，action）=\u0026gt; newState的reducer，并返回与dispatch方法配对的当前状态。 useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。 useImperativeMethods 自定义使用ref时公开给父组件的实例值 useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发 useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染  （2）React16.9\n 重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出 废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。 废弃\u0026quot;Factory\u0026quot;组件。 工厂组件会导致 React 变大且变慢。 act（）也支持异步函数，并且你可以在调用它时使用 await。 使用 \u0026lt;React.ProfiLer\u0026gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便  （3）React16.13.0\n 支持在渲染期间调用setState，但仅适用于同一组件 可检测冲突的样式规则并记录警告 废弃 unstable_createPortal，使用CreatePortal 将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。  3. react 实现一个全局的 dialog 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  import React, { Component } from \u0026#39;react\u0026#39;; import { is, fromJS } from \u0026#39;immutable\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import ReactCSSTransitionGroup from \u0026#39;react-addons-css-transition-group\u0026#39;; import \u0026#39;./dialog.css\u0026#39;; let defaultState = { alertStatus:false, alertTip:\u0026#34;提示\u0026#34;, closeDialog:function(){}, childs:\u0026#39;\u0026#39; } class Dialog extends Component{ state = { ...defaultState }; // css动画组件设置为目标组件 FirstChild = props =\u0026gt; { const childrenArray = React.Children.toArray(props.children); return childrenArray[0] || null; } //打开弹窗 open =(options)=\u0026gt;{ options = options || {}; options.alertStatus = true; var props = options.props || {}; var childs = this.renderChildren(props,options.childrens) || \u0026#39;\u0026#39;; console.log(childs); this.setState({ ...defaultState, ...options, childs }) } //关闭弹窗 close(){ this.state.closeDialog(); this.setState({ ...defaultState }) } renderChildren(props,childrens) { //遍历所有子组件 var childs = []; childrens = childrens || []; var ps = { ...props, //给子组件绑定props _close:this.close //给子组件也绑定一个关闭弹窗的事件 }; childrens.forEach((currentItem,index) =\u0026gt; { childs.push(React.createElement( currentItem, { ...ps, key:index } )); }) return childs; } shouldComponentUpdate(nextProps, nextState){ return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState)) } render(){ return ( \u0026lt;ReactCSSTransitionGroup component={this.FirstChild} transitionName=\u0026#39;hide\u0026#39; transitionEnterTimeout={300} transitionLeaveTimeout={300}\u0026gt; \u0026lt;div className=\u0026#34;dialog-con\u0026#34; style={this.state.alertStatus? {display:\u0026#39;block\u0026#39;}:{display:\u0026#39;none\u0026#39;}}\u0026gt; {this.state.childs} \u0026lt;/div\u0026gt; \u0026lt;/ReactCSSTransitionGroup\u0026gt; ); } } let div = document.createElement(\u0026#39;div\u0026#39;); let props = { }; document.body.appendChild(div); let Box = ReactD   子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //子类jsx import React, { Component } from \u0026#39;react\u0026#39;; class Child extends Component { constructor(props){ super(props); this.state = {date: new Date()}; } showValue=()=\u0026gt;{ this.props.showValue \u0026amp;\u0026amp; this.props.showValue() } render() { return ( \u0026lt;div className=\u0026#34;Child\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;content\u0026#34;\u0026gt; Child \u0026lt;button onClick={this.showValue}\u0026gt;调用父的方法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } } export default Child;   css：\n1 2 3 4 5 6 7 8  .dialog-con{ position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.3); }   4. React 数据持久化有什么实践吗？ 封装数据持久化组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  】let storage={ // 增加 set(key, value){ localStorage.setItem(key, JSON.stringify(value)); }, // 获取 get(key){ return JSON.parse(localStorage.getItem(key)); }, // 删除 remove(key){ localStorage.removeItem(key); } }; export default Storage;   在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。\n但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是redux-persist。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：\n（1）首先要安装redux-persist：\n1  npm i redux-persist   （2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import {createStore} from \u0026#39;redux\u0026#39; import reducers from \u0026#39;../reducers/index\u0026#39; import {persistStore, persistReducer} from \u0026#39;redux-persist\u0026#39;; import storage from \u0026#39;redux-persist/lib/storage\u0026#39;; import autoMergeLevel2 from \u0026#39;redux-persist/lib/stateReconciler/autoMergeLevel2\u0026#39;; const persistConfig = { key: \u0026#39;root\u0026#39;, storage: storage, stateReconciler: autoMergeLevel2 // 查看 \u0026#39;Merge Process\u0026#39; 部分的具体情况 }; const myPersistReducer = persistReducer(persistConfig, reducers) const store = createStore(myPersistReducer) export const persistor = persistStore(store) export default store   （3）在index.js中，将PersistGate标签作为网页内容的父标签：\n1 2 3 4 5 6 7 8 9 10 11  import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import {Provider} from \u0026#39;react-redux\u0026#39; import store from \u0026#39;./redux/store/store\u0026#39; import {persistor} from \u0026#39;./redux/store/store\u0026#39; import {PersistGate} from \u0026#39;redux-persist/lib/integration/react\u0026#39;; ReactDOM.render(\u0026lt;Provider store={store}\u0026gt; \u0026lt;PersistGate loading={null} persistor={persistor}\u0026gt; {/*网页内容*/} \u0026lt;/PersistGate\u0026gt; \u0026lt;/Provider\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;));   这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。\n5. 对 React 和 Vue 的理解，它们的异同 相似之处：\n 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。 都使用了Virtual DOM（虚拟DOM）提高重绘性能 都有props的概念，允许组件间的数据传递 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性  不同之处：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入\u0026quot;Virtual DOM\u0026rdquo;，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。  3）组件化\nReact与Vue最大的不同是模板的编写。\n Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。 React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。  具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。\n4）监听数据变化的实现原理不同\n Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。  5）高阶组件\nreact可以通过高阶组件（Higher Order Components\u0026ndash; HOC）来扩展，而vue需要通过mixins来扩展。\n原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具\n React ==\u0026gt; Create React APP Vue ==\u0026gt; vue-cli  7）跨平台\n React ==\u0026gt; React Native Vue ==\u0026gt; Weex  6. 可以使用TypeScript写React应用吗？怎么操作？ （1）如果还未创建 Create React App 项目\n 直接创建一个具有 typescript 的 Create React App 项目：  1  npx create-react-app demo --typescript   （2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中\n 通过命令将 typescript 引入项目：  1  npm install --save typescript @types/node @types/react @types/react-dom @types/jest    将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src/index.js 重命名为 src/index.tsx ）  7. React 设计思路，它的理念是什么？ （1）编写简单直观的代码\nReact最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。\n（2）简化可复用的组件\nReact框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶\n  可组合：简单组件可以组合为复杂的组件\n  可重用：每个组件都是独立的，可以被多个组件使用\n  可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护\n  可测试：因为组件的独立性，测试组件就变得方便很多。\n  （3) Virtual DOM\n真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。\n（4）函数式编程\nReact 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。\n（5）一次学习，随处编写\n无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。\nReact 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成\n8. React中props.children和React.Children的区别 在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来。如下：\n1 2 3 4 5 6 7  function ParentComponent(props){ return ( \u0026lt;div\u0026gt; {props.children} \u0026lt;/div\u0026gt; ) }   如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。\n比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。\n首先是子组件：\n1 2 3 4 5 6 7 8 9  //子组件 function RadioOption(props) { return ( \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value={props.value} name={props.name} /\u0026gt; {props.label} \u0026lt;/label\u0026gt; ) }   然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //父组件用,props是指父组件的props function renderChildren(props) { //遍历所有子组件 return React.Children.map(props.children, child =\u0026gt; { if (child.type === RadioOption) return React.cloneElement(child, { //把父组件的props.name赋值给每个子组件 name: props.name }) else return child }) } //父组件 function RadioGroup(props) { return ( \u0026lt;div\u0026gt; {renderChildren(props)} \u0026lt;/div\u0026gt; ) } function App() { return ( \u0026lt;RadioGroup name=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;RadioOption label=\u0026#34;选项一\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;RadioOption label=\u0026#34;选项二\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;RadioOption label=\u0026#34;选项三\u0026#34; value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; ) } export default App;   以上，React.Children.map让我们对父组件的所有子组件又更灵活的控制。\n9. React的状态提升是什么？使用场景有哪些？ React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。\n概括来说就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。\n一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  class Father extends React.Component { constructor(props) { super(props) this.state = { Value1: \u0026#39;\u0026#39;, Value2: \u0026#39;\u0026#39; } } value1Change(aa) { this.setState({ Value1: aa }) } value2Change(bb) { this.setState({ Value2: bb }) } render() { return ( \u0026lt;div style={{ padding: \u0026#34;100px\u0026#34; }}\u0026gt; \u0026lt;Child1 value1={this.state.Value1} onvalue1Change={this.value1Change.bind(this)} /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;Child2 value2={this.state.Value1} /\u0026gt; \u0026lt;/div\u0026gt; ) } } class Child1 extends React.Component { constructor(props) { super(props) } changeValue(e) { this.props.onvalue1Change(e.target.value) } render() { return ( \u0026lt;input value={this.props.Value1} onChange={this.changeValue.bind(this)} /\u0026gt; ) } } class Child2 extends React.Component { constructor(props) { super(props) } render() { return ( \u0026lt;input value={this.props.value2} /\u0026gt; ) } } ReactDOM.render( \u0026lt;Father /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) )   10. React中constructor和getInitialState的区别? 两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。\ngetInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，\n1 2 3 4 5 6 7 8  var APP = React.creatClass ({ getInitialState() { return { userName: \u0026#39;hi\u0026#39;, userId: 0 }; } })   React在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：\n1 2 3 4 5 6  Class App extends React.Component{ constructor(props){ super(props); this.state={}; } }   11. React的严格模式如何使用，有什么用处？ StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。\n可以为应用程序的任何部分启用严格模式。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React from \u0026#39;react\u0026#39;; function ExampleApplication() { return ( \u0026lt;div\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;React.StrictMode\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ComponentOne /\u0026gt; \u0026lt;ComponentTwo /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/React.StrictMode\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; ); }   在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\nStrictMode 目前有助于：\n 识别不安全的生命周期 关于使用过时字符串 ref API 的警告 关于使用废弃的 findDOMNode 方法的警告 检测意外的副作用 检测过时的 context API  12. 在React中遍历的方法有哪些？ （1）遍历数组：map \u0026amp;\u0026amp; forEach\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import React from \u0026#39;react\u0026#39;; class App extends React.Component { render() { let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; return ( \u0026lt;ul\u0026gt; { arr.map((item, index) =\u0026gt; { return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; ) } } class App extends React.Component { render() { let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; return ( \u0026lt;ul\u0026gt; { arr.forEach((item, index) =\u0026gt; { return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; ) } }   （2）遍历对象：map \u0026amp;\u0026amp; for in\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  class App extends React.Component { render() { let obj = { a: 1, b: 2, c: 3 } return ( \u0026lt;ul\u0026gt; { (() =\u0026gt; { let domArr = []; for(const key in obj) { if(obj.hasOwnProperty(key)) { const value = obj[key] domArr.push(\u0026lt;li key={key}\u0026gt;{value}\u0026lt;/li\u0026gt;) } } return domArr; })() } \u0026lt;/ul\u0026gt; ) } } // Object.entries() 把对象转换成数组 class App extends React.Component { render() { let obj = { a: 1, b: 2, c: 3 } return ( \u0026lt;ul\u0026gt; { Object.entries(obj).map(([key, value], index) =\u0026gt; { // item是一个数组，把item解构，写法是[key, value] return \u0026lt;li key={key}\u0026gt;{value}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; ) } }   13. 在React中页面重新加载时怎样保留数据？ 这个问题就设计到了**数据持久化，**主要的实现方式有以下几种：\n **Redux：**将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据； **data.js：**使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取； **sessionStorge：**在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据 **history API：**History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。  14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？  react：包含react所必须的核心代码 react-dom：react渲染在不同平台所需要的核心代码 babel：将jsx转换成React代码的工具  15. React必须使用JSX吗？ React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。\n每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。\n例如，用 JSX 编写的代码：\n1 2 3 4 5 6 7 8 9  class Hello extends React.Component { render() { return \u0026lt;div\u0026gt;Hello {this.props.toWhat}\u0026lt;/div\u0026gt;; } } ReactDOM.render( \u0026lt;Hello toWhat=\u0026#34;World\u0026#34; /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) );   可以编写为不使用 JSX 的代码：\n1 2 3 4 5 6 7 8 9  class Hello extends React.Component { render() { return React.createElement(\u0026#39;div\u0026#39;, null, `Hello ${this.props.toWhat}`); } } ReactDOM.render( React.createElement(Hello, {toWhat: \u0026#39;World\u0026#39;}, null), document.getElementById(\u0026#39;root\u0026#39;) );   16. 为什么使用jsx的组件中没有看到使用react却需要引入react？ 本质上来说JSX是React.createElement(component, props, ...children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。\n17. 在React中怎么使用async/await？ async/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。\n18. React.Children.map和js的map有什么区别？ JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。\n19. 对React SSR的理解 服务端渲染是数据与模版组成的html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记\u0026quot;混合\u0026quot;为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;\nSSR的优势：\n 对SEO友好 所有的模版、图片等资源都存在服务器端 一个html返回所有数据 减少HTTP请求 响应快、用户体验好、首屏渲染快  1）更利于SEO\n不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。\n2）更利于首屏渲染\n首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。\nSSR的局限：\n1）服务端压力较大\n本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;\n2）开发条件受限\n在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;\n3）学习成本相对较高\n除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。\n时间耗时比较：\n1）数据请求\n由服务端请求首屏数据，而不是客户端请求首屏数据，这是\u0026quot;快\u0026quot;的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差\n 客户端数据请求   服务端数据请求  2）html渲染\n服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。\n 非ssr html渲染   ssr html渲染  20. 为什么 React 要用 JSX？ JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。\n其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Hello extends React.Component { render() { return React.createElement( \u0026#39;div\u0026#39;, null, `Hello ${this.props.toWhat}` ); } } ReactDOM.render( React.createElement(Hello, {toWhat: \u0026#39;World\u0026#39;}, null), document.getElementById(\u0026#39;root\u0026#39;) );   而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：\n1 2 3 4 5 6 7 8 9  class Hello extends React.Component { render() { return \u0026lt;div\u0026gt;Hello {this.props.toWhat}\u0026lt;/div\u0026gt;; } } ReactDOM.render( \u0026lt;Hello toWhat=\u0026#34;World\u0026#34; /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) );   通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。\n因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而XML 在树结构的描述上天生具有可读性强的优势。\n但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。\n总结：\nJSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。\nReact 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。\n21. HOC相比 mixins 有什么优点？ HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：\n 隐含了一些依赖，比如我在组件中写了某个 state 并且在 mixin 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 mixin 中查找依赖 多个 mixin 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。 雪球效应，虽然我一个组件还是使用着同一个 mixin，但是一个 mixin 会被多个组件使用，可能会存在需求使得 mixin 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本  HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。\n22. React 中的高阶组件运用了什么设计模式？ 使用了装饰模式，高阶组件的运用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function withWindowWidth(BaseComponent) { class DerivedClass extends React.Component { state = { windowWidth: window.innerWidth, } onResize = () =\u0026gt; { this.setState({ windowWidth: window.innerWidth, }) } componentDidMount() { window.addEventListener(\u0026#39;resize\u0026#39;, this.onResize) } componentWillUnmount() { window.removeEventListener(\u0026#39;resize\u0026#39;, this.onResize); } render() { return \u0026lt;BaseComponent {...this.props} {...this.state}/\u0026gt; } } return DerivedClass; } const MyComponent = (props) =\u0026gt; { return \u0026lt;div\u0026gt;Window width is: {props.windowWidth}\u0026lt;/div\u0026gt; }; export default withWindowWidth(MyComponent);   装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：\n1 2 3  @testable class MyTestableClass { }   ","permalink":"https://coderrenxy.github.io/posts/read/react%E7%AF%87/","summary":"一、组件基础 1. React 事件机制 1 \u0026lt;div onClick={this.handleClick.bind(this)}\u0026gt;点我\u0026lt;/div\u0026gt; R","title":"React"},{"content":"这一周工作 第一天拿到需求，前一天因为学校考试和只睡了1h，一直在赶火车，甚至来公司都是带着行李，第一天状态很差，看代码还没库，完全蒙蔽。 好在导师及时疏解，把库给我，把我没有理解的需求重讲了一遍，然后我也录音周末看代码+听录音。\n经过了8天，需求算是尘埃落定了。当然整个过程多亏了导师的鼎力支持。\n我的反思 这一周有许多值得反思的，例如：对代码触觉不灵敏，写代码少+粗心，导致初版上灰度就出现好几次线上问题。\n判空、mapper实体字段写成表字段名，一系列 nt 事情在我的操作中接二连三。\n还有很多开发常识反应不灵敏、git 操作不熟悉、linux 命令不熟悉 、排查代码问题的思路不够清晰。\n我的周末计划  整理这周笔记，犯过的错，走过的误区，有疑点的开发知识翻阅资料。 安装 mac 的环境，拿到mac卧槽太爽了！！！ 熟悉云效流水线的代码，不然等需求过来临时看是地狱体验。 如果还有时间 or 不想看代码：git找文章甚至自建项目熟悉一下，熟悉 linux 命令。要用的时候不会真的很尴尬，总不能句句都去 gpt 吧？  我的下周计划  把失败发布的记录拉出来。 把需求上线，并学习记录整个发布上线的流程（应该跟 灰度、日常环境 差不多）。 继续看代码，并排查《保存流水线 的接口很慢的问题》。 迎接下一个需求，熟悉那块代码。  我的长期计划 由于后续开发基本都是云效，所有云效代码必须全部熟悉，首当其冲是流水线，我需要接触的 90%+ 代码都在这。\n持续产出，熟悉完代码后续学 docker、k8s 之类的云原生，体系很大，做好长线打算。\n产出尽量向正式工靠拢，跟着神级导师冲，起码四个月后在早会能听得懂大家的每句话，半年后有自己的想法。\n争取转正，早日上岸，脱离秋招苦海。\n","permalink":"https://coderrenxy.github.io/posts/life/%E5%AE%9E%E4%B9%A0%E5%91%A8%E8%AE%B01/","summary":"这一周工作 第一天拿到需求，前一天因为学校考试和只睡了1h，一直在赶火车，甚至来公司都是带着行李，第一天状态很差，看代码还没库，完全蒙蔽。 好在","title":"实习周记1"},{"content":"一、CSS 基础 1. CSS 选择器及其优先级    选择器 格式 优先级权重     id 选择器 #id 100   类选择器 #classname 10   属性选择器 a[ref=“eee”] 10   伪类选择器 li:last-child 10   标签选择器 div 1   伪元素选择器 li::after 1   相邻兄弟选择器 h1+p 0   子选择器 ul\u0026gt;li 0   后代选择器 li a 0   通配符选择器 * 0    对于选择器的优先级：\n 标签选择器、伪元素选择器：1 类选择器、伪类选择器、属性选择器：10 id 选择器：100 内联样式：1000  注意事项：\n !important 声明的样式的优先级最高； 如果优先级相同，则最后出现的样式生效； 继承得到的样式的优先级最低； 通用选择器（*）、子选择器（\u0026gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ； 样式表的来源不同时，优先级顺序为：内联样式 \u0026gt; 内部样式 \u0026gt; 外部样式 \u0026gt; 浏览器用户自定义样式 \u0026gt; 浏览器默认样式。  2. CSS 中可继承与不可继承属性有哪些\u0026mdash;了解即可 一、无继承性的属性\n display：规定元素应该生成的框的类型 文本属性：   vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 unicode-bidi：设置文本的方向   盒子模型的属性：width、height、margin、border、padding 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 生成内容属性：content、counter-reset、counter-increment 轮廓样式属性：outline-style、outline-width、outline-color、outline 页面样式属性：size、page-break-before、page-break-after 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during  二、有继承性的属性\n 字体系列属性   font-family：字体系列 font-weight：字体的粗细 font-size：字体的大小 font-style：字体的风格   文本系列属性   text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：单词之间的间距 letter-spacing：中文或者字母之间的间距 text-transform：控制文本大小写（就是 uppercase、lowercase、capitalize 这三个） color：文本颜色   元素可见性   visibility：控制元素显示隐藏   列表布局属性   list-style：列表风格，包括 list-style-type、list-style-image 等   光标属性   cursor：光标显示为何种形态  3. display 的属性值及其作用    属性值 作用     none 元素不显示，并且会从文档流中移除。   block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。   inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。   inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。   list-item 像块类型元素一样显示，并添加样式列表标记。   table 此元素会作为块级表格来显示。   inherit 规定应该从父元素继承 display 属性的值。    4. display 的 block、inline 和 inline-block 的区别 （1）**block：**会独占一行，多个元素会另起一行，可以设置 width、height、margin 和 padding 属性；\n（2）**inline：**元素不会独占一行，设置 width、height 属性无效。但可以设置水平方向的 margin 和 padding 属性，不能设置垂直方向的 padding 和 margin；\n（3）**inline-block：**将对象设置为 inline 对象，但对象的内容作为 block 对象呈现，之后的内联对象会被排列在同一行内。\n对于行内元素和块级元素，其特点如下：\n（1）行内元素\n 设置宽高无效； 可以设置水平方向的 margin 和 padding 属性，不能设置垂直方向的 padding 和 margin； 不会自动换行；  （2）块级元素\n 可以设置宽高； 设置 margin 和 padding 都有效； 可以自动换行； 多个块状，默认排列从上到下。  5. 隐藏元素的方法有哪些  display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。 visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。 opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。 position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。 z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。 clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。  6. link 和@import 的区别 两者都是外部引用 CSS 的方式，它们的区别如下：\n link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。 link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。 link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。 link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。  7. transition 和 animation 的区别\u0026mdash;了解即可  transition 是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于 flash 的补间动画，设置一个开始关键帧，一个结束关键帧。 animation 是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于 flash 的补间动画，但是它可以设置多个关键帧（用@keyframe 定义）完成动画。  8. display:none 与 visibility:hidden 的区别 这两个属性都是让元素隐藏，不可见。两者区别如下：\n（1）在渲染树中\n display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间； visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。  （2）是否是继承属性\n display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示； visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；  （3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；\n（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。\n9. 伪元素和伪类 的区别和作用？  伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：  1 2 3 4  p::before {content:\u0026#34;第一章：\u0026#34;;} p::after {content:\u0026#34;Hot!\u0026#34;;} p::first-line {background:red;} p::first-letter {font-size:30px;}    伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：  1 2  a:hover {color: #FF00FF} p:first-child {color: red}   **总结：**伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。\n10. 对 requestAnimationframe 的理解 实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的 API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。\nMDN 对该方法的描述：\n window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n 语法： window.requestAnimationFrame(callback); 其中，callback 是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入 DOMHighResTimeStamp 参数，它表示 requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。\n**取消动画：**使用 cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame 默认返回的 id，只需要传入这个 id 就可以取消动画了。\n优势：\n CPU 节能：使用 SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费 CPU 资源。而 RequestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的 RequestAnimationFrame 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。 函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每 16.7ms 刷新一次，多次绘制并不会在屏幕上体现出来。 减少 DOM 操作：requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。  setTimeout 执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：\n settimeout 任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚； settimeout 的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。  11. 对盒模型的理解 CSS3 中的盒模型有以下两种：标准盒子模型、IE 盒子模型\n盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。\n标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同：\n 标准盒模型的 width 和 height 属性的范围只包含了 content， IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。  可以通过修改元素的 box-sizing 属性来改变元素的盒模型：\n box-sizing: content-box表示标准盒模型（默认值） box-sizing: border-box表示 IE 盒模型（怪异盒模型）  12. 为什么有时候⽤translate来改变位置⽽不是定位？ translate 是 transform 属性的⼀个值。改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform 使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此 translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽ translate 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。\n13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ 浏览器会把 inline 内联元素间的空白字符（空格、换行、Tab 等）渲染成一个空格。为了美观，通常是一个\u0026lt;li\u0026gt;放在一行，这导致\u0026lt;li\u0026gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n解决办法：\n（1）为\u0026lt;li\u0026gt;设置 float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\n（2）将所有\u0026lt;li\u0026gt;写在同一行。不足：代码不美观。\n（3）将\u0026lt;ul\u0026gt;内的字符尺寸直接设为 0，即 font-size:0。不足：\u0026lt;ul\u0026gt;中的其他字符尺寸也被设为 0，需要额外重新设定其他字符尺寸，且在 Safari 浏览器依然会出现空白间隔。\n（4）消除\u0026lt;ul\u0026gt;的字符间隔 letter-spacing:-8px，不足：这也设置了\u0026lt;li\u0026gt;内的字符间隔，因此需要将\u0026lt;li\u0026gt;内的字符间隔设为默认 letter-spacing:normal。\n14. CSS3 中有哪些新特性  新增各种 CSS 选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadoweflect） 文字特效 （text-shadow） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 增加了旋转,缩放,定位,倾斜,动画,多背景  15. 替换元素的概念及计算规则\u0026mdash;不需要看 通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。\n替换元素除了内容可替换这一特性以外，还有以下特性：\n 内容的外观不受页面上的 CSS 的影响：用专业的话讲就是在样式表现在 CSS 作用域之外。如何更改替换元素本身的外观需要类似 appearance 属性，或者浏览器自身暴露的一些样式接口。 有自己的尺寸：在 Web 中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是 300 像素 ×150 像素，如 在很多 CSS 属性上有自己的一套表现规则：比较具有代表性的就是 vertical-align 属性，对于替换元素和非替换元素，vertical-align 属性值的解释是不一样的。比方说 vertical-align 的默认值的 baseline，很简单的属性值，基线之意，被定义为字符 x 的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。 所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的 display 值却是不一样的，有的是 inline，有的是 inline-block。  替换元素的尺寸从内而外分为三类：\n 固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。 HTML 尺寸： 只能通过 HTML 原生属性改变，这些 HTML 原生属性包括的 width 和 height 属性、的 size 属性。 CSS 尺寸： 特指可以通过 CSS 的 width 和 height 或者 max-width/min-width 和 max-height/min-height 设置的尺寸，对应盒尺寸中的 content box。  这三层结构的计算规则具体如下：\n（1）如果没有 CSS 尺寸和 HTML 尺寸，则使用固有尺寸作为最终的宽高。\n（2）如果没有 CSS 尺寸，则使用 HTML 尺寸作为最终的宽高。\n（3）如果有 CSS 尺寸，则最终尺寸由 CSS 属性决定。\n（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。\n（5）如果上面的条件都不符合，则最终宽度表现为 300 像素，高度为 150 像素。\n（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。\n16. 常见的图片格式及使用场景 （1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。\n（2）GIF是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格式适用于对色彩要求不高同时需要文件体积较小的场景。\n（3）JPEG是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF 更大。\n（4）PNG-8是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。\n（5）PNG-24是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。\n（6）SVG是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。SVG 图片在放大时，不会失真，所以它适合用来绘制 Logo、Icon 等。\n（7）WebP是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。\n 在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小 26%； 在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%； WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22%的格外文件大小。  17. 对 CSSSprites 的理解\u0026mdash;了解即可 CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background-repeat，background-position 属性的组合进行背景定位。\n优点：\n 利用CSS Sprites能很好地减少网页的 http 请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点； CSS Sprites能减少图片的字节，把 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的字节总和。  缺点：\n 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂； CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。 维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。  18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x 这种图片？ 以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px \u0026amp; 896px，也就是说当赋予一个 DIV 元素宽度为 414px，这个 DIV 就会填满手机的宽度；\n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3 个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。\n对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。\n当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。\n还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:\n1 2 3 4  my-image { background: (low.png); } @media only screen and (min-device-pixel-ratio: 1.5) { #my-image { background: (high.png); } }   19. margin 和 padding 的使用场景  需要在 border 外侧添加空白，且空白处不需要背景（色）时，使用 margin； 需要在 border 内测添加空白，且空白处需要背景（色）时，使用 padding。  20. 对line-height 的理解及其赋值方式 （1）line-height 的概念：\n line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离； 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定； 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容； 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中； line-height 和 height 都能撑开一个高度；  （2）line-height 的赋值方式：\n 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px 百分比：将计算后的值传递给后代  21. CSS 优化和提高性能的方法有哪些？ 加载性能：\n（1）css 压缩：将写好的 css 进行打包压缩，可以减小文件体积。\n（2）css 单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但 margin-bottom:bottom;margin-left:left;执行效率会更高。\n（3）减少使用@import，建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n选择器性能：\n（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n（2）如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。\n（4）尽量少的去对标签进行选择，而是用 class。\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n渲染性能：\n（1）慎重使用高性能属性：浮动、定位。\n（2）尽量减少页面重排、重绘。\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。\n（4）属性值为 0 时，不加单位。\n（5）属性值为浮动小数 0.**，可以省略小数点之前的 0。\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n（7）不使用@import 前缀，它会影响 css 的加载速度。\n（8）选择器优化嵌套，尽量避免层级过深。\n（9）css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n（10）正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n（11）不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。web fonts 通常体积庞大，而且一些浏览器在下载 web fonts 时会阻塞页面渲染损伤性能。\n可维护性、健壮性：\n（1）将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 css 的可维护性。\n（2）样式与内容分离：将 css 代码定义到外部 css 中。\n22. CSS 预处理器/后处理器是什么？为什么要使用它们？ **预处理器，**如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发 UI 组件都极为方便。\n后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\ncss预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。\n其它css预处理器语言：Sass（Scss）, Less, Stylus, Turbine, Swithch css, CSS Cacheer, DT Css。\n使用原因：\n 结构清晰， 便于扩展 可以很方便的屏蔽浏览器私有语法的差异 可以轻松实现多重继承 完美的兼容了CSS代码，可以应用到老项目中  23. ::before 和 :after 的双冒号和单冒号有什么区别？ （1）冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。\n（2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n注意： :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。\n24. display:inline-block 什么时候会显示间隙？  有空格时会有间隙，可以删除空格解决； margin正值时，可以让margin使用负值解决； 使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决；  25. 单行、多行文本溢出隐藏  单行文本溢出  1 2 3  overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 white-space: nowrap; // 规定段落中的文本不进行换行    多行文本溢出  1 2 3 4 5  overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 display:-webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列 -webkit-line-clamp:3; // 显示的行数   注意：由于上面的三个属性都是 CSS3 的属性，不是所有浏览器都可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。\n26. Sass、Less 是什么？为什么要使用他们？ 他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\n为什么要使用它们？\n 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。  27. 对媒体查询的理解？ 媒体查询由⼀个可选的媒体类 型和零个或多个使⽤媒体功能的限制了样式表范围的表达式（限制表达式）组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃ CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合 web ⽹⻚应对不同型号的设备⽽做出对应的响应适配。\n媒体查询包含⼀个可选的媒体类型和满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是 true，那么该媒体查询的结果为 true。那么媒体查询内的样式将会⽣效。\n1 2 3 4 5 6 7 8 9 10  \u0026lt;!-- link元素中的CSS媒体查询 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;(max-width: 800px)\u0026#34; href=\u0026#34;example.css\u0026#34; /\u0026gt; \u0026lt;!-- 样式表中的CSS媒体查询 --\u0026gt; \u0026lt;style\u0026gt; @media (max-width: 600px) { .facet_sidebar { display: none; } } \u0026lt;/style\u0026gt;   简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n媒体查询的缺点：\n对程序员开发不友好，同一个工程当中会使用到多套css样式表，增加了开发难度。\n28. 对 CSS 工程化的理解 CSS 工程化是为了解决以下问题：\n 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？ 编码优化：怎样写出更好的 CSS？ 构建：如何处理我的 CSS，才能让它的打包结果最优？ 可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？  以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：\n 预处理器：Less、 Sass 等； 重要的工程化插件： PostCss； Webpack loader 等 。  基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：\n（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？\n预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：\n那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：\n 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用； 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码； 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。  这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：\n 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ； 支持定义 css 变量； 提供计算函数； 允许对代码片段进行 extend 和 mixin； 支持循环语句的使用； 支持将 CSS 文件模块化，实现复用。  （2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？\nPostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：\n它和预处理器的不同就在于，预处理器处理的是 类 CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。\nPostCss 在业务中的使用场景非常多：\n 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作； 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀； 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；  （3）Webpack 能处理 CSS 吗？如何实现？\nWebpack 能处理 CSS 吗：\n Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具； Webpack 在 loader 的辅助下，是可以处理 CSS 的。  如何用 Webpack 实现对 CSS 的处理：\n  Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader\n  注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：\n   css-loader：导入 CSS 模块，对 CSS 代码进行编译处理； style-loader：创建 style 标签，把 CSS 内容写入标签。    在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。\n29. 如何判断元素是否到达可视区域 以图片显示为例：\n window.innerHeight 是浏览器可视区的高度； document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离； imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）； 内容达到显示区域的：img.offsetTop \u0026lt; window.innerHeight + document.body.scrollTop;  30. z-index 属性在什么情况下会失效 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index 值越大就越是在上层。z-index 元素的 position 属性需要是 relative，absolute 或是 fixed。\nz-index 属性在下列情况下会失效：\n 父元素 position 为 relative 时，子元素的 z-index 失效。解决：父元素 position 改为 absolute 或 static； 元素没有设置 position 属性为非 static 属性。解决：设置该元素的 position 属性为 relative，absolute 或是 fixed 中的一种； 元素在设置 z-index 的同时还设置了 float 浮动。解决：float 去除，改为 display：inline-block；  31. CSS3 中的 transform 有哪些属性  translate 位移 rotate 旋转 scale 缩放 skew 斜切   更多细节补充：\n  参考 MDN文档 菜鸟教程\n CSS**transform**属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。transform属性可以指定为关键字值none 或一个或多个\u0026lt;transform-function\u0026gt;值。\n\u0026lt;transform-function\u0026gt; CSS数据类型用于对元素的显示做变换。通常，这种变换可以由矩阵表示，并且可以使用每个点上的矩阵乘法来确定所得到的图像。下面简单展示下\u0026lt;transform-function\u0026gt;值都有哪些（来自菜鸟教程，如果想要了解细则请点击这里进入MDN官方文档）\n   none 定义不进行转换。     matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。   matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。   translate(x,y) 定义 2D 转换。（平移）   translate3d(x,y,z) 定义 3D 转换。   translateX(x) 定义转换，只是用 X 轴的值。   translateY(y) 定义转换，只是用 Y 轴的值。   translateZ(z) 定义 3D 转换，只是用 Z 轴的值。   scale(x,y) 定义 2D 缩放转换。   scale3d(x,y,z) 定义 3D 缩放转换。   scaleX(x) 通过设置 X 轴的值来定义缩放转换。   scaleY(y) 通过设置 Y 轴的值来定义缩放转换。   scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。   rotate(angle) 定义 2D 旋转，在参数中规定角度。   rotate3d(x,y,z,angle) 定义 3D 旋转。   rotateX(angle) 定义沿着 X 轴的 3D 旋转。   rotateY(angle) 定义沿着 Y 轴的 3D 旋转。   rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。   skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。   skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。   skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。   perspective(n) 为 3D 转换元素定义透视视图。    二、页面布局 1. 常见的 CSS 布局单位 常用的布局单位包括像素（px），百分比（%），em，rem，vw/vh。\n（1）像素（px）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS 像素和物理像素：\n CSS 像素：为 web 开发者提供，在 CSS 中使用的一个抽象单位； 物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。  （2）百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n（3）em 和 rem相对于 px 更具灵活性，它们都是相对长度单位，它们之间的区别：em 相对于父元素，rem 相对于根元素。\n em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认 16px)。(相对父元素的字体大小倍数)。 rem： rem 是 CSS3 新增的一个相对单位，相对于根元素（html 元素）的 font-size 的倍数。作用：利用 rem 可以实现简单的响应式布局，可以利用 html 元素中字体的大小与屏幕间的比值来设置 font-size 的值，以此实现当屏幕分辨率变化时让元素也随之变化。  （4）vw/vh是与视图窗口有关的单位，vw 表示相对于视图窗口的宽度，vh 表示相对于视图窗口高度，除了 vw 和 vh 外，还有 vmin 和 vmax 两个相关的单位。\n vw：相对于视窗的宽度，视窗宽度是 100vw； vh：相对于视窗的高度，视窗高度是 100vh； vmin：vw 和 vh 中的较小值； vmax：vw 和 vh 中的较大值；  vw/vh 和百分比很类似，两者的区别：\n 百分比（%）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate 等) vw/vh：相对于视窗的尺寸  2. px、em、rem 的区别及使用场景 三者的区别：\n px 是固定的像素，一旦设置了就无法因为适应页面大小而改变。 em 和 rem 相对于 px 更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。 em 是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 rem 是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。  使用场景：\n 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用 px 即可 。 对于需要适配各种移动设备，使用 rem，例如需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备。  rem的原理\n1rem就是指一个html字体的大小（通常为12px），通常设置html字体大小为：设备的宽度 / 设计稿的宽度 * 100 ，前半部分是指渲染效果的缩放比，乘以一百是因为浏览器的最小字体问题，当设置了校园浏览器最小字体是会强制显示为最小字体。解决方法：设置-webkit-text-size-adjust:none\n3. 两栏布局的实现 一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，两栏布局的具体实现：\n 利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。  1 2 3 4 5 6 7 8 9 10 11 12 13  .outer { height: 100px; } .left { float: left; width: 200px; background: tomato; } .right { margin-left: 200px; width: auto; background: gold; }    利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置 overflow: hidden; 这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。  1 2 3 4 5 6 7 8 9 10 11  .left{ width: 100px; height: 200px; background: red; float: left; } .right{ height: 300px; background: blue; overflow: hidden; }    利用 flex 布局，将左边元素设置为固定宽度 200px，将右边的元素设置为 flex:1。  1 2 3 4 5 6 7 8 9 10 11 12  .outer { display: flex; height: 100px; } .left { width: 200px; background: tomato; } .right { flex: 1; background: gold; }    利用绝对定位，将父级元素设置为相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  .outer { position: relative; height: 100px; } .left { position: absolute; width: 200px; height: 100px; background: tomato; } .right { margin-left: 200px; background: gold; }    利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .outer { position: relative; height: 100px; } .left { width: 200px; background: tomato; } .right { position: absolute; top: 0; right: 0; bottom: 0; left: 200px; background: gold; }   4. 三栏布局的实现 三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，三栏布局的具体实现：\n 利用绝对定位，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的值。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  .outer { position: relative; height: 100px; } .left { position: absolute; width: 100px; height: 100px; background: tomato; } .right { position: absolute; top: 0; right: 0; width: 200px; height: 100px; background: gold; } .center { margin-left: 100px; margin-right: 200px; height: 100px; background: lightgreen; }    利用 flex 布局，左右两栏设置固定大小，中间一栏设置为 flex:1。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  .outer { display: flex; height: 100px; } .left { width: 100px; background: tomato; } .right { width: 100px; background: gold; } .center { flex: 1; background: lightgreen; }    利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式**，中间一栏必须放到最后：**  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  .outer { height: 100px; } .left { float: left; width: 100px; height: 100px; background: tomato; } .right { float: right; width: 200px; height: 100px; background: gold; } .center { height: 100px; margin-left: 100px; margin-right: 200px; background: lightgreen; }    圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  .outer { height: 100px; padding-left: 100px; padding-right: 200px; } .left { position: relative; left: -100px; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato; } .right { position: relative; left: 200px; float: right; margin-left: -200px; width: 200px; height: 100px; background: gold; } .center { float: left; width: 100%; height: 100px; background: lightgreen; }    双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  .outer { height: 100px; } .left { float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato; } .right { float: left; margin-left: -200px; width: 200px; height: 100px; background: gold; } .wrapper { float: left; width: 100%; height: 100px; background: lightgreen; } .center { margin-left: 100px; margin-right: 200px; height: 100px; }   5.水平垂直居中的实现  利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。  1 2 3 4 5 6 7 8 9 10  .parent { position: relative; } .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); }    利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况：  1 2 3 4 5 6 7 8 9 10 11 12  .parent { position: relative; } .child { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; }    利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况  1 2 3 4 5 6 7 8 9 10 11  .parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; margin-top: -50px; /* 自身 height 的一半 */ margin-left: -50px; /* 自身 width 的一半 */ }    使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多：  1 2 3 4 5  .parent { display: flex; justify-content:center; align-items:center; }   另外，如果父元素设置了flex布局，只需要给子元素加上margin:auto;就可以实现垂直居中布局\n1 2 3 4 5 6  .parent{ display:flex; } .child{ margin: auto; }   这里蛮有意思的 如果不在弹性布局中 margin:auto;只能做到水平居中\n这其中的道理可以看这篇文章了解一下（具体就是与auto的定义有关）\n6. 如何根据设计稿进行移动端适配？ 移动端适配主要有两个维度：\n **适配不同像素密度，**针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真； **适配不同屏幕大小，**由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。  为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。\n7. 对 Flex 布局的理解及其使用场景 Flex 是 FlexibleBox 的缩写，意为\u0026quot;弹性布局\u0026quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\u0026quot;容器\u0026quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\u0026quot;项目\u0026quot;。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n以下 6 个属性设置在容器上：\n flex-direction 属性决定主轴的方向（即项目的排列方向）。 flex-wrap 属性定义，如果一条轴线排不下，如何换行。 flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 justify-content 属性定义了项目在主轴上的对齐方式。 align-items 属性定义项目在交叉轴上如何对齐。 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  以下 6 个属性设置在项目上：\n order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。 flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。  简单来说：\nflex 布局是 CSS3 新增的一种布局方式，可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用 flex-direction 来指定主轴的方向。可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例，还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例。\n8. 响应式设计的概念及基本原理 响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n关于原理： 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。\n关于兼容： 页面头部必须有 meta 声明的viewport。\n1  \u0026lt;meta name=\u0026#34;’viewport’\u0026#34; content=\u0026#34;”width=device-width,\u0026#34; initial-scale=\u0026#34;1.\u0026#34; maximum-scale=\u0026#34;1,user-scalable=no”\u0026#34;/\u0026gt;   三、定位与浮动 1. 为什么需要清除浮动？清除浮动的方式 浮动的定义： 非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n浮动的工作原理：\n 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） 浮动元素碰到包含它的边框或者其他浮动元素的边框停留  浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n浮动元素引起的问题？\n 父元素的高度无法被撑开，影响与父元素同级的元素（高度塌陷问题） 与浮动元素同级的非浮动元素会跟随其后 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构  清除浮动的方式如下：\n 给父级 div 定义height属性 最后一个浮动元素后面添加一个空的div，并设置样式：clear：both 包含浮动元素的父级标签添加overflow:hidden或者overflow:auto 使用 :after 伪元素。由于 IE6-7 不支持 :after，使用 zoom:1 触发 hasLayout**  1 2 3 4 5 6 7 8 9  .clearfix:after{ content: \u0026#34;\\200B\u0026#34;; display: table; height: 0; clear: both; } .clearfix{ *zoom: 1; }   2. 使用 clear 属性清除浮动的原理？ 使用 clear 属性清除浮动，其语法如下：\n1  clear:none|left|right|both   如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。\n官方对 clear 属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置 clear 属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。\n还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的。考虑到 float 属性要么是 left，要么是 right，不可能同时存在，同时由于 clear 属性对“后面的”浮动元素不闻不问，因此，当 clear:left 有效的时候，clear:right 必定无效，也就是此时 clear:left 等同于设置 clear:both；同样地，clear:right 如果有效也是等同于设置 clear:both。由此可见，clear:left 和 clear:right 这两个声明就没有任何使用的价值，至少在 CSS 世界中是如此，直接使用 clear:both 吧。\n一般使用伪元素的方式清除浮动：\n1 2 3 4 5  .clear::after{ content:\u0026#39;\u0026#39;; display: block; clear:both; }   clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因。\n3. 对 BFC 的理解，如何创建 BFC 先来看两个相关的概念：\n Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。 Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。  块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。\n创建 BFC 的条件：\n 根元素：html； 元素设置浮动：float 除 none 以外的值； 元素设置绝对定位：position (absolute、fixed)； display 值为：inline-block、table-cell、table-caption、flex 等； overflow 值为：hidden、auto、scroll；  BFC 的特点：\n 垂直方向上，自上而下排列，和文档流的排列方式一致。 在 BFC 中上下相邻的两个容器的 margin 会重叠 计算 BFC 的高度时，需要计算浮动元素的高度 BFC 区域不会与浮动的容器发生重叠 BFC 是独立的容器，容器内部元素不会影响外部元素 每个元素的左 margin 值和容器的左 border 相接触  BFC 的作用：\n 解决 margin 的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。 解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置overflow:hidden。 创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  .left{ width: 100px; height: 200px; background: red; float: left; } .right{ height: 300px; background: blue; overflow: hidden; } \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。\n4. 什么是 margin 重叠问题？如何解决？ 问题描述：\n两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。\n计算原则：\n折叠合并后外边距的计算原则如下：\n 如果两者都是正数，那么就去最大者 如果是一正一负，就会正值减去负值的绝对值 两个都是负值时，用 0 减去两个中绝对值大的那个  解决办法：\n对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠\n（1）兄弟之间重叠\n 底部元素变为行内盒子：display: inline-block 底部元素设置浮动：float 底部元素的 position 的值为absolute/fixed  （2）父子之间重叠\n 父元素加入：overflow: hidden 父元素添加透明边框：border:1px solid transparent 子元素变为行内盒子：display: inline-block 子元素加入浮动属性或定位  5. 元素的层叠顺序 层叠顺序，英 文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：\n对于上图，由上到下分别是：\n（1）背景和边框：建立当前层叠上下文元素的背景和边框。\n（2）负的 z-index：当前层叠上下文中，z-index 属性值为负的元素。\n（3）块级盒：文档流内非行内级非定位后代元素。\n（4）浮动盒：非定位浮动元素。\n（5）行内盒：文档流内行内级非定位后代元素。\n（6）z-index:0：层叠级数为 0 的定位元素。\n（7）正 z-index：z-index 属性值为正的定位元素。\n注意: 当定位元素 z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。\n6. position 的属性有哪些，区别是什么 position 有以下属性值：\n   属性值 概述     absolute 生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。   relative 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。   fixed 生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。   static 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。   inherit 规定从父元素继承 position 属性的值    前面三者的定位方式如下：\n **relative：**元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。  **fixed：**元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n**absolute：**元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n7. display、float、position 的关系 （1）首先判断 display 属性是否为 none，如果为 none，则 position 和 float 属性的值不影响元素最后的表现。\n（2）然后判断 position 的值是否为 absolute 或者 fixed，如果是，则 float 属性失效，并且 display 的值应该被设置为 table 或者 block，具体转换需要看初始转换值。\n（3）如果 position 的值不为 absolute 或者 fixed，则判断 float 属性的值是否为 none，如果不是，则 display 的值则按上面的规则转换。注意，如果 position 的值为 relative 并且 float 属性的值存在，则 relative 相对于浮动后的最终位置定位。\n（4）如果 float 的值为 none，则判断元素是否为根元素，如果是根元素则 display 属性按照上面的规则转换，如果不是，则保持指定的 display 属性值不变。\n总的来说，可以把它看作是一个类似优先级的机制，\u0026ldquo;position:absolute\u0026quot;和\u0026quot;position:fixed\u0026quot;优先级最高，有它存在的时候，浮动不起作用，\u0026lsquo;display\u0026rsquo;的值也需要调整；其次，元素的\u0026rsquo;float\u0026rsquo;特性的值不是\u0026quot;none\u0026quot;的时候或者它是根元素的时候，调整\u0026rsquo;display\u0026rsquo;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，\u0026lsquo;display\u0026rsquo;特性值同设置值。\n8. absolute 与 fixed 共同点与不同点 共同点：\n 改变行内元素的呈现方式，将 display 置为 inline-block 使元素脱离普通文档流，不再占据文档物理空间 覆盖非定位文档元素  不同点：\n absolute 与 fixed 的根元素不同，absolute 的根元素可以设置，fixed 根元素是浏览器。 在有滚动条的页面中，absolute 会跟着父元素进行移动，fixed 固定在页面的具体位置。  9. 对 sticky 定位的理解\u0026mdash;了解即可 sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n四、场景应用 1. 实现一个三角形 CSS 绘制三角形主要用到的是 border 属性，也就是边框。\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border 属性是右三角形组成的，下面看一个例子：\n1 2 3 4 5 6  div { width: 0; height: 0; border: 100px solid; border-color: orange blue red green; }   将元素的长宽都设置为 0，显示出来的效果是这样的：\n所以可以根据 border 这个特性来绘制三角形：\n（1）三角 1\n1 2 3 4 5 6 7  div { width: 0; height: 0; border-top: 50px solid red; border-right: 50px solid transparent; border-left: 50px solid transparent; }   （2）三角 2\n1 2 3 4 5 6 7  div { width: 0; height: 0; border-bottom: 50px solid red; border-right: 50px solid transparent; border-left: 50px solid transparent; }   （3）三角 3\n1 2 3 4 5 6 7  div { width: 0; height: 0; border-left: 50px solid red; border-top: 50px solid transparent; border-bottom: 50px solid transparent; }   （4）三角 4\n1 2 3 4 5 6 7  div { width: 0; height: 0; border-right: 50px solid red; border-top: 50px solid transparent; border-bottom: 50px solid transparent; }   （5）三角 5\n1 2 3 4 5 6  div { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; }   还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。\n2. 实现一个扇形 用 CSS 实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个 90° 的扇形：\n1 2 3 4 5 6 7  div{ border: 100px solid transparent; width: 0; height: 0; border-radius: 100px; border-top-color: red; }   3. 实现一个宽高自适应的正方形  利用 vw 来实现：  1 2 3 4 5  .square { width: 10%; height: 10vw; background: tomato; }    利用元素的 margin/padding 百分比是相对父元素 width 的性质来实现：  1 2 3 4 5 6  .square { width: 20%; height: 0; padding-top: 20%; background: orange; }    利用子元素的 margin-top 的值来实现：  1 2 3 4 5 6 7 8 9 10  .square { width: 30%; overflow: hidden; background: yellow; } .square::after { content: \u0026#39;\u0026#39;; display: block; margin-top: 100%; }   4. 画一条 0.5px 的线  采用 transform: scale()的方式，该方法用来定义元素的 2D 缩放转换：  1  transform: scale(0.5,0.5);    采用 meta viewport 的方式  1  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\u0026#34;/\u0026gt;   这样就能缩放到原来的 0.5 倍，如果是 1px 那么就会变成 0.5px。viewport 只针对于移动端，只在移动端上才能看到效果\n5. 设置小于 12px 的字体 在谷歌下 css 设置字体大小为 12px 及以下时，显示都是一样大小，都是默认 12px。\n解决办法：\n 使用 Webkit 的内核的-webkit-text-size-adjust 的私有 CSS 属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是 chrome 更新到 27 版本之后就不可以用了。所以高版本 chrome 谷歌浏览器已经不再支持-webkit-text-size-adjust 样式，所以要使用时候慎用。 使用 css3 的 transform 缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用 display：block/inline-block/\u0026hellip;； 使用图片：如果是内容固定不变情况下，使用将小于 12px 文字内容切出做图片，这样不影响兼容也不影响美观。  6. 如何解决 1px 问题？ 1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\n1  window.devicePixelRatio = 设备的物理像素 / CSS像素。   打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是 2：\n这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。\n**解决****1px 问题的三种思路：**\n思路一：直接写 0.5px 如果之前 1px 的样式这样写：\n1  border:1px solid #333   可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：\n1  \u0026lt;div id=\u0026#34;container\u0026#34; data-device={{window.devicePixelRatio}}\u0026gt;\u0026lt;/div\u0026gt;   然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为 2 的情况：\n1 2 3  #container[data-device=\u0026#34;2\u0026#34;] { border:0.5px solid #333 }   直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要 8 及以上的版本，安卓系统则直接不兼容。\n思路二：伪元素先放大后缩小 这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n思路是先放大、后缩小：**在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的**宽和高都设置为目标元素的两倍，border 值设为 1px。**接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一**，间接地实现了 0.5px 的效果。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #container[data-device=\u0026#34;2\u0026#34;] { position: relative; } #container[data-device=\u0026#34;2\u0026#34;]::after{ position:absolute; top: 0; left: 0; width: 200%; height: 200%; content:\u0026#34;\u0026#34;; transform: scale(0.5); transform-origin: left top; box-sizing: border-box; border: 1px solid #333; } }   思路三：viewport 缩放来解决 这个思路就是对 meta 标签里几个关键属性下手：\n1  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\u0026#34;\u0026gt;   这里针对像素比为 2 的页面，把整个页面缩放为了原来的 1/2 大小。这样，本来占用 2 个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\n1 2 3  const scale = 1 / window.devicePixelRatio; // 这里 metaEl 指的是 meta 标签对应的 Dom metaEl.setAttribute(\u0026#39;content\u0026#39;, `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);   这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。\n","permalink":"https://coderrenxy.github.io/posts/read/4-css%E7%AF%87/","summary":"一、CSS 基础 1. CSS 选择器及其优先级 选择器 格式 优先级权重 id 选择器 #id 100 类选择器 #classname 10 属性选择器 a[ref=“eee”] 10 伪类选择器 li:last-child 10 标签选择器 div","title":"CSS"},{"content":"1. src 和 href 的区别 src 和 href 都是用来引用外部的资源，它们的区别如下：\n src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。 href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。  2. 对 HTML 语义化的理解 语义化是指 赋予标签含义，然后根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。\n语义化的优点如下：\n 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录； 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。  常见的语义化标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;header\u0026gt;\u0026lt;/header\u0026gt; 头部 \u0026lt;nav\u0026gt;\u0026lt;/nav\u0026gt; 导航栏 \u0026lt;section\u0026gt;\u0026lt;/section\u0026gt; 区块（有语义化的div） \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; 主要区域 \u0026lt;article\u0026gt;\u0026lt;/article\u0026gt; 主要内容 \u0026lt;aside\u0026gt;\u0026lt;/aside\u0026gt; 侧边栏 \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; 底部   3. DOCTYPE(⽂档类型) 的作⽤ DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。\n浏览器渲染页面的两种模式（可通过 document.compatMode 获取，比如，语雀官网的文档类型是CSS1Compat）：\n CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用 W3C 的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 BackCompat：怪异模式（混杂模式）（Quick mode），浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。  4. script 标签中 defer 和 async 的区别 如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n下图可以直观的看出三者之间的区别:\n其中蓝色代表 js 脚本网络加载 时间，红色代表 js 脚本执行时间，绿色代表 html 解析。\ndefer 和 async 属性都是异步去加载外部的 JS 脚本文件，它们都不会阻塞页面的解析，其区别如下：\n 执行顺序: 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行； 脚本是否并行执行：async 属性，表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。  5. 常⽤的 meta 标签有哪些 meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了 HTTP 标准固定了一些name作为大家使用的共识，开发者还可以自定义 name。\n常用的 meta 标签：\n（1）charset，用来描述 HTML 文档的编码类型：\n1  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; \u0026gt;   （2） keywords，页面关键词：\n1  \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;关键词\u0026#34; /\u0026gt;   （3）description，页面描述：\n1  \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;页面描述内容\u0026#34; /\u0026gt;   （4）refresh，页面重定向和刷新：\n1  \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;url=\u0026#34; /\u0026gt;   （5）viewport，适配移动端，可以控制视口的大小和比例：\n1  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, maximum-scale=1\u0026#34;\u0026gt;   其中，content 参数有以下几种：\n width viewport ：宽度(数值/device-width) height viewport ：高度(数值/device-height) initial-scale ：初始缩放比例 maximum-scale ：最大缩放比例 minimum-scale ：最小缩放比例 user-scalable ：是否允许用户缩放(yes/no）  （6）搜索引擎索引方式：\n1  \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;index,follow\u0026#34; /\u0026gt;   其中，content 参数有以下几种：\n all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。  6. HTML5 有哪些更新 1. 语义化标签  header：定义文档的页眉（头部）； nav：定义导航链接的部分； footer：定义文档或节的页脚（底部）； article：定义文章内容； section：定义文档中的节（section、区段）； aside：定义其所处内容之外的内容（侧边）；  2. 媒体标签 （1） audio：音频\n1  \u0026lt;audio src=\u0026#39;\u0026#39; controls autoplay loop=\u0026#39;true\u0026#39;\u0026gt;\u0026lt;/audio\u0026gt;   属性：\n controls 控制面板 autoplay 自动播放 loop=‘true’ 循环播放  （2）video 视频\n1  \u0026lt;video src=\u0026#39;\u0026#39; poster=\u0026#39;imgs/aa.jpg\u0026#39; controls\u0026gt;\u0026lt;/video\u0026gt;   属性：\n poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一帧画面，当然通过 poster 也可以自己指定。 controls 控制面板 width height  （3）source 标签\n因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过 source 来指定视频源。\n1 2 3 4  \u0026lt;video\u0026gt; \u0026lt;source src=\u0026#39;aa.flv\u0026#39; type=\u0026#39;video/flv\u0026#39;\u0026gt;\u0026lt;/source\u0026gt; \u0026lt;source src=\u0026#39;aa.mp4\u0026#39; type=\u0026#39;video/mp4\u0026#39;\u0026gt;\u0026lt;/source\u0026gt; \u0026lt;/video\u0026gt;   3. 表单 表单类型：\n email ：能够验证当前输入的邮箱地址是否合法 url ： 验证 URL number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max 属性可以设置为最大值，min 可以设置为最小值，value 为默认值。 search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。 range ： 可以提供给一个范围，其中可以设置 max 和 min 以及 value，其中 value 属性可以设置为默认值 color ： 提供了一个颜色拾取器 time ： 时分秒 date ： 日期选择年月日 datetime ： 时间和日期(目前只有 Safari 支持) datetime-local ：日期时间控件 week ：周控件 month：月控件  表单属性：\n  placeholder ：提示信息\n  autofocus ：自动获取焦点\n  autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：\n   表单必须提交过 必须有 name 属性。    required：要求输入框不能为空，必须有值才能够提交。\n  pattern=\u0026quot; \u0026quot; 里面写入想要的正则模式，例如手机号 patte=\u0026quot;^(+86)?\\d{10}$\u0026quot;\n  multiple：可以选择多个文件或者多个邮箱\n  form=\u0026quot; form 表单的 ID\u0026quot;\n  表单事件：\n oninput 每当 input 里的输入框内容发生变化都会触发此事件。 oninvalid 当验证不通过时触发此事件。  4. 进度条、度量器   progress 标签：用来表示任务的进度（IE、Safari 不支持），max 用来表示任务的进度，value 表示已完成多少\n  meter 属性：用来显示剩余容量或剩余库存（IE、Safari 不支持）\n   high/low：规定被视作高/低的范围 max/min：规定最大/小值 value：规定当前度量值    设置规则：min \u0026lt; low \u0026lt; high \u0026lt; max\n5.DOM 查询操作  document.querySelector() document.querySelectorAll()  它们选择的对象可以是标签，可以是类(需要加点)，可以是 ID(需要加#)\n6. Web 存储 HTML5 提供了两种在客户端存储数据的新方法：\n localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储  7. 其他  拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：  1  \u0026lt;img draggable=\u0026#34;true\u0026#34; /\u0026gt;    画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。  1  \u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt;    SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准 地理定位：Geolocation（地理定位）用于定位用户的位置。‘  总结：\n（1）新增语义化标签：nav、header、footer、aside、section、article\n（2）音频、视频标签：audio、video\n（3）数据存储：localStorage、sessionStorage\n（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）\n（5）input 标签新增属性：placeholder、autocomplete、autofocus、required\n（6）history API：go、forward、back、pushstate\n移除的元素有：\n 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes；  7. img 的 srcset 属性的作⽤？ 响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的 srcset 属性。srcset 属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：\n1  \u0026lt;img src=\u0026#34;image-128.png\u0026#34; srcset=\u0026#34;image-256.png 2x\u0026#34; /\u0026gt;   使用上面的代码，就能实现在屏幕密度为 1x 的情况下加载 image-128.png, 屏幕密度为 2x 时加载 image-256.png。\n屏幕密度：一个逻辑像素对应的物理像素\n按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有 1x,2x,3x,4x 四种，如果每一个图片都设置 4 张图片，加载就会很慢。所以就有了新的 srcset 标准。代码如下：\n1 2 3  \u0026lt;img src=\u0026#34;image-128.png\u0026#34; srcset=\u0026#34;image-128.png 128w, image-256.png 256w, image-512.png 512w\u0026#34; sizes=\u0026#34;(max-width: 360px) 340px, 128px\u0026#34; /\u0026gt;   其中 srcset 指定图片的地址和对应的图片质量。sizes 用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。\nsizes 语法如下：\n1  sizes=\u0026#34;[media query] [length], [media query] [length] ... \u0026#34;   sizes 就是指默认显示 128px, 如果视区宽度大于 360px, 则显示 340px。\n8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？  行内元素有：a b span img input select strong； 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；  空元素，即没有内容的 HTML 元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：\n 常见的有：\u0026lt;br\u0026gt;、\u0026lt;hr\u0026gt;、\u0026lt;img\u0026gt;、\u0026lt;input\u0026gt;、\u0026lt;link\u0026gt;、\u0026lt;meta\u0026gt;； 鲜见的有：\u0026lt;area\u0026gt;、\u0026lt;base\u0026gt;、\u0026lt;col\u0026gt;、\u0026lt;colgroup\u0026gt;、\u0026lt;command\u0026gt;、\u0026lt;embed\u0026gt;、\u0026lt;keygen\u0026gt;、\u0026lt;param\u0026gt;、\u0026lt;source\u0026gt;、\u0026lt;track\u0026gt;、\u0026lt;wbr\u0026gt;。  9. 说一下 web worker 在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n如何创建 web worker：\n 检测浏览器对于 web worker 的支持性 创建 web worker 文件（js，回传函数等） 创建 web worker 对象  10. HTML5 的离线储存怎么使用，它的工作原理是什么\u0026ndash;了解即可 离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n**原理：**HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n使用方法：\n（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：\n1  \u0026lt;html lang=\u0026#34;en\u0026#34; manifest=\u0026#34;index.manifest\u0026#34;\u0026gt;   （2）在 cache.manifest 文件中编写需要离线存储的资源：\n1 2 3 4 5 6 7 8 9  CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html    CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。 FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。  （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。\n如何更新缓存：\n（1）更新 manifest 文件\n（2）通过 javascript 操作\n（3）清除浏览器缓存\n注意事项：\n（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。\n（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。\n（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。\n（4）FALLBACK 中的资源必须和 manifest 文件同源。\n（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。\n（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。\n（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。\n11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？  在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器会直接使用离线存储的资源。  12. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\u0026mdash;了解即可  strong 标签有语义，是起到加重语气的效果，而 b 标签是没有的，b 标签只是一个简单加粗标签。b 标签之间的字符都设为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。 title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取有很大的影响 i 内容展示为斜体，em 表示强调的文本  13. iframe 有哪些优点和缺点？ iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。\n优点：\n 用来加载速度较慢的内容（如广告） 可以使脚本并行下载 可以实现跨子域通信  缺点：\n iframe 会阻塞主页面的 onload 事件 无法被一些搜索引擎所识别 会产生很多页面，不容易管理  14. label 的作用是什么？如何使用？\u0026mdash;了解即可 label 标签来定义表单控件的关系：当用户选择 label 标签时，浏览器会自动将焦点转到和 label 标签相关的表单控件上。\n 使用方法 1：  1 2  \u0026lt;label for=\u0026#34;mobile\u0026#34;\u0026gt;Number:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;mobile\u0026#34;/\u0026gt;    使用方法 2：  1  \u0026lt;label\u0026gt;Date:\u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt;\u0026lt;/label\u0026gt;   15. Canvas 和 SVG 的区别 （1）SVG：\nSVG 可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言 XML 描述的 2D 图形的语言，SVG 基于 XML 就意味着 SVG DOM 中的每个元素都是可用的，可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n其特点如下：\n 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用  （2）Canvas：\nCanvas 是画布， 通过 JavaScript 来绘制 2D 图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。\n其特点如下：\n 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘  注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。\n16. head 标签有什么作用，其中什么标签必不可少？ 作用\n 用于定义文档的头部，它是所有头部元素的容器。 引用资源：脚本、样式表等。 描述文档：元信息、文档标题、在 Web 中的位置以及和其他文档的关系等 绝大多数文档头部包含的数据都不会真正作为内容显示给用户  常见标签\n base link meta script style title(唯一必需)  17. 文档声明（Doctype）和\u0026lt;!Doctype html\u0026gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义? **文档声明的作用：**文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。\n\u0026lt;!Doctype html\u0026gt;的作用：\u0026lt;!doctype html\u0026gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。\n严格模式与混杂模式的区分：\n 严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码； 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；  区分：网页中的DTD，直接影响到使用的是严格模式还是混杂模式，可以说DTD的使用与这两种方式的区别息息相关。\n 如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）； 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）； DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD 不存在或者格式不正确——混杂模式）； HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。  总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。\n18. 浏览器乱码的原因是什么？如何解决？\u0026mdash;了解即可 产生乱码的原因：\n 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码； html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码； 浏览器不能自动检测网页编码，造成网页乱码。  解决办法：\n 使用软件编辑 HTML 网页内容； 如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码； 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。  19. 渐进增强和优雅降级之间的区别 （1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。\n（2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。\n两者区别：\n 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。  “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。\n20. 说一下 HTML5 drag API\u0026mdash;了解即可  dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。  ","permalink":"https://coderrenxy.github.io/posts/read/3-html%E7%AF%87/","summary":"1. src 和 href 的区别 src 和 href 都是用来引用外部的资源，它们的区别如下： src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指","title":"HTML"},{"content":"一、数据类型 1. JavaScript有哪些数据类型，它们的区别？ JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n其中 Symbol 和 BigInt 是ES6 中新增的数据类型：\n Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。 BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。  这些数据可以分为原始数据类型和引用数据类型：\n 栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt） 堆：引用数据类型（对象、数组和函数）  两种类型的区别在于存储位置的不同：\n 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。  堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n 在数据结构中，栈中数据的存取方式为先进后出。 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。  在操作系统中，内存被分为栈区和堆区：\n 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。  2. 数据类型检测的方式有哪些 （1）typeof\n1 2 3 4 5 6 7 8  console.log(typeof 2); // number console.log(typeof true); // boolean console.log(typeof \u0026#39;str\u0026#39;); // string console.log(typeof []); // object console.log(typeof function(){}); // function console.log(typeof {}); // object console.log(typeof undefined); // undefined console.log(typeof null); // object   其中数组、对象、null都会被判断为object，其他判断都正确。\n例子：\n1 2 3 4 5 6 7  console.log(typeof new String()) //object console.log(typeof String)//function console.log(typeof String()) //string console.log(typeof typeof a) //string **typeof未定义的变量 返回undefined  function Fun(){} console.log(typeof new Fun()) //object   （2）instanceof\ninstanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。\n1 2 3 4 5 6 7  console.log(2 instanceof Number); // false console.log(true instanceof Boolean); // false console.log(\u0026#39;str\u0026#39; instanceof String); // false  console.log([] instanceof Array); // true console.log(function(){} instanceof Function); // true console.log({} instanceof Object); // true   可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n（3） constructor\n1 2 3 4 5 6  console.log((2).constructor === Number); // true console.log((true).constructor === Boolean); // true console.log((\u0026#39;str\u0026#39;).constructor === String); // true console.log(([]).constructor === Array); // true console.log((function() {}).constructor === Function); // true console.log(({}).constructor === Object); // true   constructor有两个作用，一是判断数据的类型，二是对象实例通过 constructor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：\n1 2 3 4 5 6 7 8  function Fn(){}; Fn.prototype = new Array(); var f = new Fn(); console.log(f.constructor===Fn); // false console.log(f.constructor===Array); // true   （4）Object.prototype.toString.call()\nObject.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：\n1 2 3 4 5 6 7 8 9 10  var a = Object.prototype.toString; console.log(a.call(2)); console.log(a.call(true)); console.log(a.call(\u0026#39;str\u0026#39;)); console.log(a.call([])); console.log(a.call(function(){})); console.log(a.call({})); console.log(a.call(undefined)); console.log(a.call(null));   同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？\n这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。\n3. 判断数组的方式有哪些  通过Object.prototype.toString.call()做判断  1  Object.prototype.toString.call(obj).slice(8,-1) === \u0026#39;Array\u0026#39;;    通过原型链做判断  1  obj.__proto__ === Array.prototype;    通过ES6的Array.isArray()做判断  1  Array.isArray(obj);    通过instanceof做判断  1  obj instanceof Array    通过Array.prototype.isPrototypeOf  1  Array.prototype.isPrototypeOf(obj)   4. null和undefined区别 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\nundefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当对这两种类型使用 typeof 进行判断时，Null 类型会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n5. typeof null 的结果是什么，为什么？ typeof null 的结果是Object。\n在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\n1 2 3 4 5  000: object - 当前存储的数据指向一个对象。 1: int - 当前存储的数据是一个 31 位的有符号整数。 010: double - 当前存储的数据指向一个双精度的浮点数。 100: string - 当前存储的数据指向一个字符串。 110: boolean - 当前存储的数据是布尔值。   如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\n有两种特殊数据类型：\n undefined的值是 (-2)30(一个超出整数范围的数字)； null 的值是机器码 NULL 指针(null 指针的值全是 0)  那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。\n6. intanceof 操作符的实现原理及实现 instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function myInstanceof(left, right) { // 获取对象的原型  let proto = Object.getPrototypeOf(left) // 获取构造函数的 prototype 对象  let prototype = right.prototype; // 判断构造函数的 prototype 对象是否在对象的原型链上  while (true) { if (!proto) return false; if (proto === prototype) return true; // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型  proto = Object.getPrototypeOf(proto); } } //自己写了一遍 function instaceOf(left,right){ let proto = Object.getPrototypeOf(left) let prototype = right.prototype while(true){ if(!proto) return false if(proto === protype) return true proto = Object.getPrototypeOf(proto) } }   7. 为什么0.1+0.2 ! == 0.3，如何让其相等 在开发过程中遇到类似这样的问题：\n1 2  let n1 = 0.1, n2 = 0.2 console.log(n1 + n2) // 0.30000000000000004   这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：\n1  (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入   toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\n一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n下面看一下双精度数是如何保存的：\n 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位 第二部分（绿色）：用来存储指数（exponent），占用11位 第三部分（红色）：用来存储小数（fraction），占用52位  对于0.1，它的二进制为：\n1  0.00011001100110011001100110011001100110011001100110011001 10011...   转为科学计数法（科学计数法的结果就是浮点数）：\n1  1.1001100110011001100110011001100110011001100110011001*2^-4   可以看出0.1的符号位为0，指数位为-4，小数位为：\n1  1001100110011001100110011001100110011001100110011001   那么问题又来了，指数位是负数，该如何保存呢？\nIEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定双精度数的偏移量为1023。\n 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是-1022~1013。 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。  对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：1111111011.\n所以，0.1表示为：\n1  0 1111111011 1001100110011001100110011001100110011001100110011001   说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？\n对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3\n1 2 3 4 5  function numberepsilon(arg1,arg2){ return Math.abs(arg1 - arg2) \u0026lt; Number.EPSILON; } console.log(numberepsilon(0.1 + 0.2, 0.3)); // true   8. 如何获取安全的 undefined 值？ 因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。\n9. typeof NaN 的结果是什么？ NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\n1  typeof NaN; // \u0026#34;number\u0026#34;   NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。\n10. isNaN 和 Number.isNaN 函数的区别？  函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。  11. == 操作符的强制类型转换规则？ 对于 == 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：\n 首先会判断两者类型是否**相同，**相同的话就比较两者的大小； 类型不相同的话，就会进行类型转换； 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number  1 2 3  1 == \u0026#39;1\u0026#39; ↓ 1 == 1   判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断  1 2 3 4 5  \u0026#39;1\u0026#39; == true ↓ \u0026#39;1\u0026#39; == 1 ↓ 1 == 1   判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断  1 2 3  \u0026#39;1\u0026#39; == { name: \u0026#39;js\u0026#39; } ↓ \u0026#39;1\u0026#39; == \u0026#39;[object Object]\u0026#39;   其流程图如下：\n12. 其他值到字符串的转换规则？  Null 和 Undefined 类型 ，null 转换为 \u0026ldquo;null\u0026rdquo;，undefined 转换为 \u0026ldquo;undefined\u0026rdquo;， Boolean 类型，true 转换为 \u0026ldquo;true\u0026rdquo;，false 转换为 \u0026ldquo;false\u0026rdquo;。 Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。 Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\u0026quot;[object Object]\u0026quot;。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。  13. 其他值到数字值的转换规则？  Undefined 类型的值转换为 NaN。 Null 类型的值转换为 0。 Boolean 类型的值，true 转换为 1，false 转换为 0。 String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串或者全是空格的字符串为 0。 Symbol 类型的值不能转换为数字，会报错。 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。  为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\n14. 其他值到布尔类型的值的转换规则？ 以下这些是假值：\n• undefined\n• null\n• false\n• +0、-0 和 NaN\n• \u0026quot;\u0026quot;\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。\n15. || 和 \u0026amp;\u0026amp; 操作符的返回值？ || 和 \u0026amp;\u0026amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\n 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。 \u0026amp;\u0026amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。  || 和 \u0026amp;\u0026amp; 返回它们其中一个操作数的值，而非条件判断的结果\n16. Object.is() 与比较操作符 “===”、“==” 的区别？  使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。  17. 什么是 JavaScript 中的包装类型？ 在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：\n1 2 3  const a = \u0026#34;abc\u0026#34;; a.length; // 3 a.toUpperCase(); // \u0026#34;ABC\u0026#34;   在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。\nJavaScript也可以使用Object函数显式地将基本类型转换为包装类型：\n1 2  var a = \u0026#39;abc\u0026#39; Object(a) // String {\u0026#34;abc\u0026#34;}   也可以使用valueOf方法将包装类型倒转成基本类型：\n1 2 3  var a = \u0026#39;abc\u0026#39; var b = Object(a) var c = b.valueOf() // \u0026#39;abc\u0026#39;   看看如下代码会打印出什么：\n1 2 3 4  var a = new Boolean( false ); if (!a) { console.log( \u0026#34;Oops\u0026#34; ); // never runs }   答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。\n18. JavaScript 中如何进行隐式类型转换？ 首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：\n1 2 3 4 5  /** * @obj 需要转换的对象 * @type 期望的结果类型 */ ToPrimitive(obj,type)   type的值为number或者string。\n（1）当type为number时规则如下：\n 调用obj的valueOf方法，如果为原始值，则返回，否则下一步； 调用obj的toString方法，后续同上； 抛出TypeError 异常。  （2）当type为string时规则如下：\n 调用obj的toString方法，如果为原始值，则返回，否则下一步； 调用obj的valueOf方法，后续同上； 抛出TypeError 异常。  可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：\n 如果对象为 Date 对象，则type默认为string； 其他情况下，type默认为number。  总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：\n1 2 3  var objToNumber = value =\u0026gt; Number(value.valueOf().toString()) objToNumber([]) === 0 objToNumber({}) === NaN   而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及==、\u0026gt;、\u0026lt;这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。\n以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：\n +操作符+操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。  1 2 3 4 5  1 + \u0026#39;23\u0026#39; // \u0026#39;123\u0026#39;  1 + false // 1  1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number  \u0026#39;1\u0026#39; + false // \u0026#39;1false\u0026#39;  false + true // 1   -、*、\\操作符NaN也是一个数字  1 2 3  1 * \u0026#39;23\u0026#39; // 23  1 * false // 0  1 / \u0026#39;aa\u0026#39; // NaN   对于**==**操作符  操作符两边的值都尽量转成number：\n1 2 3  3 == true // false, 3 转为number为3，true转为number为1 \u0026#39;0\u0026#39; == false //true, \u0026#39;0\u0026#39;转为number为0，false转为number为0 \u0026#39;0\u0026#39; == 0 // \u0026#39;0\u0026#39;转为number为0   对于**\u0026lt;和\u0026gt;**比较符  如果两边都是字符串，则比较字母表顺序：\n1 2  \u0026#39;ca\u0026#39; \u0026lt; \u0026#39;bd\u0026#39; // false \u0026#39;a\u0026#39; \u0026lt; \u0026#39;b\u0026#39; // true   其他情况下，转换为数字再比较：\n1 2  \u0026#39;12\u0026#39; \u0026lt; 13 // true false \u0026gt; -1 // true   以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：\n1 2  var a = {} a \u0026gt; 2 // false   其对比过程如下：\n1 2 3 4  a.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步 a.toString() // \u0026#34;[object Object]\u0026#34;，现在是一个字符串了 Number(a.toString()) // NaN，根据上面 \u0026lt; 和 \u0026gt; 操作符的规则，要转换成数字 NaN \u0026gt; 2 //false，得出比较结果   又比如：\n1 2 3  var a = {name:\u0026#39;Jack\u0026#39;} var b = {age: 18} a + b // \u0026#34;[object Object][object Object]\u0026#34;   运算过程如下：\n1 2 3 4 5  a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步 a.toString() // \u0026#34;[object Object]\u0026#34; b.valueOf() // 同理 b.toString() // \u0026#34;[object Object]\u0026#34; a + b // \u0026#34;[object Object][object Object]\u0026#34;   19. + 操作符什么时候用于字符串的拼接？ 根据 ES5 规范：\n 如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作； 如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文； 如果不能转换为字符串，则会将其转换为数字类型来进行计算。  简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。\n那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n20. 为什么会有BigInt的提案？ JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。\n21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别 扩展运算符：\n1 2 3 4 5 6  let outObj = { inObj: {a: 1, b: 2} } let newObj = {...outObj} newObj.inObj.a = 2 console.log(outObj) // {inObj: {a: 2, b: 2}}   Object.assign():\n1 2 3 4 5 6  let outObj = { inObj: {a: 1, b: 2} } let newObj = Object.assign({}, outObj) newObj.inObj.a = 2 console.log(outObj) // {inObj: {a: 2, b: 2}}   二、ES6 1. let、const、var的区别 **（1）块级作用域：**块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：\n 内层变量可能覆盖外层变量 用来计数的循环变量泄露为全局变量  **（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。\n**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。\n（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。\n**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。\n**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。\n   区别 var let const     是否有块级作用域 × ✔️ ✔️   是否存在变量提升 ✔️ × ×   是否添加全局属性 ✔️ × ×   能否重复声明变量 ✔️ × ×   是否存在暂时性死区 × ✔️ ✔️   是否必须设置初始值 × × ✔️   能否改变指针指向 ✔️ ✔️ ×    2. const对象的属性可以修改吗 const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n3. 如果new一个箭头函数的会怎么样 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\nnew操作符的实现步骤如下：\n 创建一个对象 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性） 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法） 返回新的对象  所以，上面的第二、三步，箭头函数都是没有办法执行的。\n4. 箭头函数与普通函数的区别 （1）箭头函数比普通函数更加简洁\n 如果没有参数，就直接写一个空括号即可 如果只有一个参数，可以省去参数的括号 如果有多个参数，用逗号分割 如果函数体的返回值只有一句，可以省略大括号 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：  1  let fn = () =\u0026gt; void doesNotReturn();   （2）箭头函数没有自己的this\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n（3）箭头函数继承来的this指向永远不会改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var id = \u0026#39;GLOBAL\u0026#39;; var obj = { id: \u0026#39;OBJ\u0026#39;, a: function(){ console.log(this.id); }, b: () =\u0026gt; { console.log(this.id); } }; obj.a(); // \u0026#39;OBJ\u0026#39; obj.b(); // \u0026#39;GLOBAL\u0026#39; new obj.a() // undefined new obj.b() // Uncaught TypeError: obj.b is not a constructor   对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向\n1 2 3 4 5 6 7 8  var id = \u0026#39;Global\u0026#39;; let fun1 = () =\u0026gt; { console.log(this.id) }; fun1(); // \u0026#39;Global\u0026#39; fun1.call({id: \u0026#39;Obj\u0026#39;}); // \u0026#39;Global\u0026#39; fun1.apply({id: \u0026#39;Obj\u0026#39;}); // \u0026#39;Global\u0026#39; fun1.bind({id: \u0026#39;Obj\u0026#39;})(); // \u0026#39;Global\u0026#39;   （5）箭头函数不能作为构造函数使用\n构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n（6）箭头函数没有自己的arguments\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n（7）箭头函数没有prototype\n（8）箭头函数不能用作Generator函数，不能使用yeild关键字\n5. 箭头函数的this指向哪⾥？ 箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n可以⽤Babel理解⼀下箭头函数:\n1 2 3 4 5 6 7 8  // ES6 const obj = { getArrow() { return () =\u0026gt; { console.log(this === obj); }; } }   转化后：\n1 2 3 4 5 6 7 8 9  // ES5，由 Babel 转译 var obj = { getArrow: function getArrow() { var _this = this; return function () { console.log(_this === obj); }; } };   6. 扩展运算符的作用及使用场景 （1）对象扩展运算符\n对象的扩展运算符(\u0026hellip;)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。\n1 2  let bar = { a: 1, b: 2 }; let baz = { ...bar }; // { a: 1, b: 2 }   上述方法实际上等价于:\n1 2  let bar = { a: 1, b: 2 }; let baz = Object.assign({}, bar); // { a: 1, b: 2 }   Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n1 2  let bar = {a: 1, b: 2}; let baz = {...bar, ...{a:2, b: 4}}; // {a: 2, b: 4}   利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。\n需要注意：扩展运算符对****对象实例的拷贝属于浅拷贝。\n（2）数组扩展运算符\n数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。\n1 2 3 4  console.log(...[1, 2, 3]) // 1 2 3 console.log(...[1, [2, 3, 4], 5]) // 1 [2, 3, 4] 5   下面是数组的扩展运算符的应用：\n 将数组转换为参数序列  1 2 3 4 5  function add(x, y) { return x + y; } const numbers = [1, 2]; add(...numbers) // 3    复制数组  1 2  const arr1 = [1, 2]; const arr2 = [...arr1];    合并数组  如果想在数组内合并数组，可以这样：\n1 2 3  const arr1 = [\u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]; const arr2 = [\u0026#39;one\u0026#39;, ...arr1, \u0026#39;four\u0026#39;, \u0026#39;five\u0026#39;]; // [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34;]    扩展运算符与解构赋值结合起来，用于生成数组  1 2 3  const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5]   需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n1 2  const [...rest, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...rest, last] = [1, 2, 3, 4, 5]; // 报错    将字符串转为真正的数组  1  [...\u0026#39;hello\u0026#39;] // [ \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34; ]    任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组  比较常见的应用是可以将某些数据结构转为数组：\n1 2 3 4  // arguments对象 function foo() { const args = [...arguments]; }   用于替换es5中的Array.prototype.slice.call(arguments)写法。\n 使用Math函数获取数组中特定的值  1 2 3  const numbers = [9, 4, 7, 1]; Math.min(...numbers); // 1 Math.max(...numbers); // 9   7. Proxy 可以实现什么功能？ 在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。\nProxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。\n1  let p = new Proxy(target, handler)   target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。\n下面来通过 Proxy 来实现一个数据响应式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let onWatch = (obj, setBind, getLogger) =\u0026gt; { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver) }, set(target, property, value, receiver) { setBind(value, property) return Reflect.set(target, property, value) } } return new Proxy(obj, handler) } let obj = { a: 1 } let p = onWatch( obj, (v, property) =\u0026gt; { console.log(`监听到属性${property}改变为${v}`) }, (target, property) =\u0026gt; { console.log(`\u0026#39;${property}\u0026#39; = ${target[property]}`) } ) p.a = 2 // 监听到属性a改变 p.a // \u0026#39;a\u0026#39; = 2   在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。\n当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。\n8. 对对象与数组的解构的理解 解构赋值是es6提供的一种新的提取数据的模式，这种模式能够从对象或数组中有针对地拿到想要地数值。\n1）数组的解构\n在解构数组时，以元素的位置为匹配条件来提取想要的数据的：\n1  const [a, b, c] = [1, 2, 3]   最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：\n数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：\n1  const [a,,c] = [1,2,3]   通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：\n2）对象的解构\n对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：\n1 2 3 4  const stu = { name: \u0026#39;Bob\u0026#39;, age: 24 }   假如想要解构它的两个自有属性，可以这样：\n1  const { name, age } = stu   这样就得到了 name 和 age 两个和 stu 平级的变量：\n注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：\n1  const { age, name } = stu   9. 如何提取高度嵌套的对象里的指定属性？ 有时会遇到一些嵌套程度非常深的对象：\n1 2 3 4 5 6 7 8  const school = { classes: { stu: { name: \u0026#39;Bob\u0026#39;, age: 24, } } }   像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：\n1  const { name } = school   显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：\n1 2 3 4  const { classes } = school const { stu } = classes const { name } = stu name // \u0026#39;Bob\u0026#39;   但是还有一种更标准的做法，可以用一行代码来解决这个问题：\n1 2 3  const { classes: { stu: { name } }} = school console.log(name) // \u0026#39;Bob\u0026#39;   可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。\n10. 对 rest 参数的理解：将扩展运算符应用在函数地形参里 扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：\n1 2 3 4 5 6 7 8  function mutiple(...args) { let result = 1; for (var val of args) { result *= val; } return result; } mutiple(1, 2, 3, 4) // 24   这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：\n1 2 3 4  function mutiple(...args) { console.log(args) } mutiple(1, 2, 3, 4) // [1, 2, 3, 4]   这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。\n11. ES6中模板语法与字符串处理 ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：\n1 2 3 4  var name = \u0026#39;css\u0026#39; var career = \u0026#39;coder\u0026#39; var hobby = [\u0026#39;coding\u0026#39;, \u0026#39;writing\u0026#39;] var finalString = \u0026#39;my name is \u0026#39; + name + \u0026#39;, I work as a \u0026#39; + career + \u0026#39;, I love \u0026#39; + hobby[0] + \u0026#39; and \u0026#39; + hobby[1]   仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：\n1 2 3 4  var name = \u0026#39;css\u0026#39; var career = \u0026#39;coder\u0026#39; var hobby = [\u0026#39;coding\u0026#39;, \u0026#39;writing\u0026#39;] var finalString = `my name is ${name}, I work as a ${career}I love ${hobby[0]}and ${hobby[1]}`   字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：\n 在模板字符串中，空格、缩进、换行都会被保留 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算  基于第一点，可以在模板字符串里无障碍地直接写 html 代码：\n1 2 3 4 5 6 7  let list = ` \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;列表项1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; `; console.log(message); // 正确输出，不存在报错   基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：\n1 2 3 4 5  function add(a, b) { const finalString = `${a}+ ${b}= ${a+b}` console.log(finalString) } add(1, 2) // 输出 \u0026#39;1 + 2 = 3\u0026#39;   除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：\n  存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf \u0026gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。\n   includes：判断字符串与子串的包含关系：    1 2 3  const son = \u0026#39;haha\u0026#39; const father = \u0026#39;xixi haha hehe\u0026#39; father.includes(son) // true      startsWith：判断字符串是否以某个/某串字符开头：    1 2 3  const father = \u0026#39;xixi haha hehe\u0026#39; father.startsWith(\u0026#39;haha\u0026#39;) // false father.startsWith(\u0026#39;xixi\u0026#39;) // true      endsWith：判断字符串是否以某个/某串字符结尾：    1 2  const father = \u0026#39;xixi haha hehe\u0026#39; father.endsWith(\u0026#39;hehe\u0026#39;) // true    自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：  1 2 3  const sourceCode = \u0026#39;repeat for 3 times;\u0026#39; const repeated = sourceCode.repeat(3) console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;   三、JavaScript基础 1. new操作符的实现原理 new操作符的执行过程：\n（1）首先创建了一个新的空对象\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function objectFactory() { let newObject = null; let constructor = Array.prototype.shift.call(arguments); let result = null; // 判断参数是否是一个函数 if (typeof constructor !== \u0026#34;function\u0026#34;) { console.error(\u0026#34;type error\u0026#34;); return; } // 新建一个空对象，对象的原型为构造函数的 prototype 对象 newObject = Object.create(constructor.prototype); // 将 this 指向新建对象，并执行函数 result = constructor.apply(newObject, arguments); // 判断返回对象 let flag = result \u0026amp;\u0026amp; (typeof result === \u0026#34;object\u0026#34; || typeof result === \u0026#34;function\u0026#34;); // 判断返回结果 return flag ? result : newObject; } // 使用方法 objectFactory(构造函数, 初始化参数);   2. map和Object的区别\u0026mdash;了解即可     Map Object     意外的键 Map默认情况不包含任何键，只包含显式插入的键。 Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。   键的类型 Map的键可以是任意值，包括函数、对象或任意基本类型。 Object 的键必须是 String 或是Symbol。   键的顺序 Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 Object 的键是无序的   Size Map 的键值对个数可以轻易地通过size 属性获取 Object 的键值对个数只能手动计算   迭代 Map 是 iterable 的，所以可以直接被迭代。 迭代Object需要以某种方式获取它的键然后才能迭代。   性能 在频繁增删键值对的场景下表现更好。 在频繁添加和删除键值对的场景下未作出优化。    3. map和weakMap的区别\u0026mdash;了解即可 （1）Map\nmap本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。\n实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：\n1 2 3 4  const map = [ [\u0026#34;name\u0026#34;,\u0026#34;张三\u0026#34;], [\u0026#34;age\u0026#34;,18], ]   Map数据结构有以下操作方法：\n size： map.size 返回Map结构的成员总数。 set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用） get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。 has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。 delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。 clear()：map.clear()清除所有成员，没有返回值。  Map结构原生提供是三个遍历器生成函数和一个遍历方法\n keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const map = new Map([ [\u0026#34;foo\u0026#34;,1], [\u0026#34;bar\u0026#34;,2], ]) for(let key of map.keys()){ console.log(key); // foo bar } for(let value of map.values()){ console.log(value); // 1 2 } for(let items of map.entries()){ console.log(items); // [\u0026#34;foo\u0026#34;,1] [\u0026#34;bar\u0026#34;,2] } map.forEach( (value,key,map) =\u0026gt; { console.log(key,value); // foo 1 bar 2 })   （2）WeakMap\nWeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。\n该对象也有以下几种方法：\n set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用） get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。 has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。 delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。  其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。\nWeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。\n而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n总结：\n Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。  4. JavaScript有哪些内置对象 全局的对象（ global objects ）或称标准内置对象，不要和 \u0026ldquo;全局对象（global object）\u0026rdquo; 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n标准内置对象的分类：\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n例如 Infinity、NaN、undefined、null 字面量\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n例如 eval()、parseFloat()、parseInt() 等\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n例如 Object、Function、Boolean、Symbol、Error 等\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n例如 Number、Math、Date\n（5）字符串，用来表示和操作字符串的对象。\n例如 String、RegExp\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n例如 Map、Set、WeakMap、WeakSet\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n例如 SIMD 等\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n例如 JSON 等\n（10）控制抽象对象\n例如 Promise、Generator 等\n（11）反射\n例如 Reflect、Proxy\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n例如 Intl、Intl.Collator 等\n（13）WebAssembly\n（14）其他\n例如 arguments\n总结：\njs 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。\n5. 常用的正则表达式有哪些？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // （1）匹配 16 进制颜色值 var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; // （2）匹配日期，如 yyyy-mm-dd 格式 var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; // （3）匹配 qq 号 var regex = /^[1-9][0-9]{4,10}$/g; // （4）手机号码正则 var regex = /^1[34578]\\d{9}$/g; // （5）用户名正则 var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/;   6. 对JSON的理解\u0026mdash;了解即可 JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\n在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为\nJSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。\n在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，\n JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。  7. JavaScript脚本延迟加载的方式有哪些？ 延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。\n一般有以下几种方式：\n **defer 属性：**给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同时进行，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。 **async 属性：**给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。 **动态创建 DOM 方式：**动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。 **使用 setTimeout 延迟方法：**设置一个定时器来延迟加载js脚本文件 **让 JS 最后加载：**将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。  8. JavaScript 类数组对象的定义？ 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\n常见的类数组转换为数组的方法有这样几种：\n（1）通过 call 调用数组的 slice 方法来实现转换\n1  Array.prototype.slice.call(arrayLike);   （2）通过 call 调用数组的 splice 方法来实现转换\n1  Array.prototype.splice.call(arrayLike, 0);   （3）通过 apply 调用数组的 concat 方法来实现转换\n1  Array.prototype.concat.apply([], arrayLike);   （4）通过 Array.from 方法来实现转换\n1  Array.from(arrayLike);   9. 数组有哪些原生方法？  数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返 回值为正数，则交换两个参数的位置。 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法 数组归并方法 reduce() 和 reduceRight() 方法  10. Unicode、UTF-8、UTF-16、UTF-32的区别？\u0026mdash;了解即可 （1）Unicode 在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。\n 它是基于拉丁字母的一套电脑编码系统。 它定义了一个用于代表常见字符的字典。 它包含了\u0026quot;A-Z\u0026quot;(包含大小写)，数据\u0026quot;0-9\u0026quot; 以及一些常见的符号。 它是专门为英语而设计的，有128个编码，对其他语言无能为力  ASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。\nUnicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\nUnicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。\n（2）UTF-8 UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。\n注意： UTF-8 是一种编码方式，Unicode是一个字符集合。\nUTF-8的编码规则：\n 对于单字节的符号，字节的第一位为0，后面的7位为这个字符的Unicode编码，因此对于英文字母，它的Unicode编码和ACSII编码一样。 对于n字节的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的Unicode码 。  来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：\n   编码范围（编号对应的十进制数） 二进制格式     0x00—0x7F （0-127） 0xxxxxxx   0x80—0x7FF （128-2047） 110xxxxx 10xxxxxx   0x800—0xFFFF （2048-65535） 1110xxxx 10xxxxxx 10xxxxxx   0x10000—0x10FFFF （65536以上） 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：\n 找到该Unicode编码的所在的编号范围，进而找到与之对应的二进制格式 将Unicode编码转换为二进制数（去掉最高位的0） 将二进制数从右往左一次填入二进制格式的X中，如果有X未填，就设为0  来看一个实际的例子：\n“马” 字的Unicode编码是：0x9A6C，整数编号是39532\n（1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx\n（2）39532对应的二进制数为1001 1010 0110 1100\n（3）将二进制数填入X中，结果是：11101001 10101001 10101100\n（3）UTF-16 1. 平面的概念\n在了解UTF-16之前，先看一下平面的概念：\nUnicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。\n最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。\n2. UTF-16 概念：\nUTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。\n3. UTF-16 编码规则：\n 编号在 U+0000—U+FFFF 的字符（常用字符集），直接用两个字节表示。 编号在 U+10000—U+10FFFF 之间的字符，需要用四个字节表示。  4. 编码识别\n那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？\nUTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。\n辅助平面共有 2****20 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。\n因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。\n5. 举例说明\n以 \u0026ldquo;𡠀\u0026rdquo; 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：\n 首先计算超出部分的结果：0x21800 - 0x10000 将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000 将得到的两个10位二进制数分别对应到两个区间中 U+D800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xD846。同理，低位为 0xDC00，所以这个字的UTF-16 编码为 0xD846 0xDC00  （4） UTF-32 UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。\n比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。\n（5）总结 Unicode、UTF-8、UTF-16、UTF-32有什么区别？\n Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）； UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制； UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强； 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；  11. 常见的位运算符有哪些？其计算规则是什么？\u0026mdash;了解即可 现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。\n常见的位运算有以下几种：\n   运算符 描述 运算规则     \u0026amp; 与 两个位都为1时，结果才为1   | 或 两个位都为0时，结果才为0   ^ 异或 两个位相同为0，相异为1   ~ 取反 0变1，1变0   \u0026lt;\u0026lt; 左移 各二进制位全部左移若干位，高位丢弃，低位补0   \u0026gt;\u0026gt; 右移 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃    1. 按位与运算符（\u0026amp;） 定义： 参加运算的两个数据按二进制位进行“与”运算。\n运算规则：\n1 2 3 4  0 \u0026amp; 0 = 0 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 1 \u0026amp; 1 = 1   总结：两位同时为1，结果才为1，否则结果为0。\n例如：3\u0026amp;5 即：\n1 2 3  0000 0011 0000 0101 = 0000 0001   因此 3\u0026amp;5 的值为1。\n注意：负数按补码形式参加按位与运算。\n用途：\n（1）判断奇偶\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i \u0026amp; 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。\n（2）清零\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n2. 按位或运算符（|） 定义： 参加运算的两个对象按二进制位进行“或”运算。\n运算规则：\n1 2 3 4  0 | 0 = 0 0 | 1 = 1 1 | 0 = 1 1 | 1 = 1   总结：参加运算的两个对象只要有一个为1，其值为1。\n例如：3|5即：\n1 2 3  0000 0011 0000 0101 = 0000 0111   因此，3|5的值为7。\n注意：负数按补码形式参加按位或运算。\n3. 异或运算符（^） 定义： 参加运算的两个数据按二进制位进行“异或”运算。\n运算规则：\n1 2 3 4  0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0   总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。\n例如：3|5即：\n1 2 3  0000 0011 0000 0101 = 0000 0110   因此，3^5的值为6。\n异或运算的性质:\n 交换律：(a^b)^c == a^(b^c) 结合律：(a + b)^c == a^b + b^c 对于任何数x，都有 x^x=0，x^0=x 自反性: a^b^b=a^0=a;  4. 取反运算符 (~) 定义： 参加运算的一个数据按二进制进行“取反”运算。\n运算规则：\n1 2  ~ 1 = 0 ~ 0 = 1   总结：对一个二进制数按位取反，即将0变1，1变0。\n例如：~6 即：\n1 2  0000 0110 = 1111 1001   在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。\n当发现按位取反为负数时，就直接取其补码，变为十进制：\n1 2 3 4  0000 0110 = 1111 1001 反码：1000 0110 补码：1000 0111   因此，~6的值为-7。\n5. 左移运算符（\u0026laquo;） 定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。\n设 a=1010 1110，a = a\u0026laquo; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。\n若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n6. 右移运算符（\u0026raquo;） 定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\n例如：a=a\u0026raquo;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。\n操作数每右移一位，相当于该数除以2。\n7. 原码、补码、反码 上面提到了补码、反码等知识，这里就补充一下。\n计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。\n（1）原码\n原码就是一个数的二进制数。\n例如：10的原码为0000 1010\n（2）反码\n 正数的反码与原码相同，如：10 反码为 0000 1010 负数的反码为除符号位，按位取反，即0变1，1变0。  例如：-10\n1 2  原码：1000 1010 反码：1111 0101   （3）补码\n 正数的补码与原码相同，如：10 补码为 0000 1010 负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。  例如：-10\n1 2 3  原码：1000 1010 反码：1111 0101 补码：1111 0110   12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组? arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。\n要遍历类数组，有三个方法：\n（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：\n1 2 3  function foo(){ Array.prototype.forEach.call(arguments, a =\u0026gt; console.log(a)) }   （2）使用Array.from方法将类数组转化成数组：‌\n1 2 3 4  function foo(){ const arrArgs = Array.from(arguments) arrArgs.forEach(a =\u0026gt; console.log(a)) }   （3）使用展开运算符将类数组转化成数组\n1 2 3 4  function foo(){ const arrArgs = [...arguments] arrArgs.forEach(a =\u0026gt; console.log(a)) }   13. 什么是 DOM 和 BOM？  DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。 BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。  14. 对类数组对象的理解，如何转化为数组 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n常见的类数组转换为数组的方法有这样几种：\n 通过 call 调用数组的 slice 方法来实现转换  1  Array.prototype.slice.call(arrayLike);    通过 call 调用数组的 splice 方法来实现转换  1  Array.prototype.splice.call(arrayLike, 0);    通过 apply 调用数组的 concat 方法来实现转换  1  Array.prototype.concat.apply([], arrayLike);    通过 Array.from 方法来实现转换  1  Array.from(arrayLike);   15. escape、encodeURI、encodeURIComponent 的区别  encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。 encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。 escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。  16. 对AJAX的理解，实现一个AJAX请求 AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n创建AJAX请求的步骤：\n 创建一个 XMLHttpRequest 对象。 在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const SERVER_URL = \u0026#34;/server\u0026#34;; let xhr = new XMLHttpRequest(); // 创建 Http 请求 xhr.open(\u0026#34;GET\u0026#34;, url, true); // 设置状态监听函数 xhr.onreadystatechange = function() { if (this.readyState !== 4) return; // 当请求成功时 if (this.status === 200) { handle(this.response); } else { console.error(this.statusText); } }; // 设置请求失败时的监听函数 xhr.onerror = function() { console.error(this.statusText); }; // 设置请求头信息 xhr.responseType = \u0026#34;json\u0026#34;; xhr.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); // 发送 Http 请求 xhr.send(null);   使用Promise封装AJAX：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // promise 封装实现： function getJSON(url) { // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) { let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(\u0026#34;GET\u0026#34;, url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() { if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; // 设置错误监听函数 xhr.onerror = function() { reject(new Error(this.statusText)); }; // 设置响应的数据类型 xhr.responseType = \u0026#34;json\u0026#34;; // 设置请求头信息 xhr.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); // 发送 http 请求 xhr.send(null); }); return promise; }   17. JavaScript为什么要进行变量提升，它导致了什么问题？ 变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。\n首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。\n  在解析阶段，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n   全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments    在执行阶段，就是按照代码的顺序依次执行。\n  那为什么会进行变量提升呢？主要有以下两个原因：\n 提高性能 容错性更好  （1）提高性能\n在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。\n（2）容错性更好\n变量提升可以在一定程度上提高JS的容错性，看下面的代码：\n1 2 3  a = 1; var a; console.log(a);   如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。\n虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。\n总结：\n 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行  变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：\n1 2 3 4 5 6 7 8 9 10  var tmp = new Date(); function fn(){ console.log(tmp); if(false){ var tmp = \u0026#39;hello world\u0026#39;; } } fn(); // undefined   在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。\n1 2 3 4 5 6 7  var tmp = \u0026#39;hello world\u0026#39;; for (var i = 0; i \u0026lt; tmp.length; i++) { console.log(tmp[i]); } console.log(i); // 11   由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。\n18. 什么是尾调用，使用尾调用有什么好处？ 尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n19. ES6模块与CommonJS模块有什么异同？ ES6 Module和CommonJS模块的区别：\n CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const； import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。  ES6 Module和CommonJS模块的共同点：\n CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。  20. 常见的DOM操作有哪些 1）DOM 节点的获取 DOM 节点的获取的API及使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  getElementById // 按照 id 查询 getElementsByTagName // 按照标签名查询 getElementsByClassName // 按照类名查询 querySelectorAll // 按照 css 选择器查询 // 按照 id 查询 var imooc = document.getElementById(\u0026#39;imooc\u0026#39;) // 查询到 id 为 imooc 的元素 // 按照标签名查询 var pList = document.getElementsByTagName(\u0026#39;p\u0026#39;) // 查询到标签为 p 的集合 console.log(divList.length) console.log(divList[0]) // 按照类名查询 var moocList = document.getElementsByClassName(\u0026#39;mooc\u0026#39;) // 查询到类名为 mooc 的集合 // 按照 css 选择器查询 var pList = document.querySelectorAll(\u0026#39;.mooc\u0026#39;) // 查询到类名为 mooc 的集合   2）DOM 节点的创建 **创建一个新节点，并把它添加到指定节点的后面。**已知的 HTML 结构如下：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;DEMO\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：\n1 2 3 4 5 6 7 8  // 首先获取父节点 var container = document.getElementById(\u0026#39;container\u0026#39;) // 创建新节点 var targetSpan = document.createElement(\u0026#39;span\u0026#39;) // 设置 span 节点的内容 targetSpan.innerHTML = \u0026#39;hello world\u0026#39; // 把新创建的元素塞进父节点里去 container.appendChild(targetSpan)   3）DOM 节点的删除 **删除指定的 DOM 节点，**已知的 HTML 结构如下：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;DEMO\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   需要删除 id 为 title 的元素，做法是：\n1 2 3 4 5 6  // 获取目标元素的父元素 var container = document.getElementById(\u0026#39;container\u0026#39;) // 获取目标元素 var targetNode = document.getElementById(\u0026#39;title\u0026#39;) // 删除目标元素 container.removeChild(targetNode)   或者通过子节点数组来完成删除：\n1 2 3 4 5 6  // 获取目标元素的父元素 var container = document.getElementById(\u0026#39;container\u0026#39;) // 获取目标元素 var targetNode = container.childNodes[1] // 删除目标元素 container.removeChild(targetNode)   4）修改 DOM 元素 修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。\n**将指定的两个 DOM 元素交换位置，**已知的 HTML 结构如下：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;DEMO\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026lt;p id=\u0026#34;content\u0026#34;\u0026gt;我是内容\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：\n1 2 3 4 5 6 7 8  // 获取父元素 var container = document.getElementById(\u0026#39;container\u0026#39;) // 获取两个需要被交换的元素 var title = document.getElementById(\u0026#39;title\u0026#39;) var content = document.getElementById(\u0026#39;content\u0026#39;) // 交换两个元素，把 content 置于 title 前面 container.insertBefore(content, title)   21. use strict是什么意思 ? 使用它区别是什么？ use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：\n 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为; 消除代码运行的不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。  区别：\n 禁止使用 with 语句。 禁止 this 关键字指向全局对象。 对象不能有重名的属性。  22. 如何判断一个对象是否属于某个类？  第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。  23. 强类型语言和弱类型语言的区别  强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。 弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12\u0026rsquo;和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。  两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。\n24. 解释性语言和编译型语言的区别\u0026mdash;了解即可 （1）解释型语言\n使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下\n 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低； 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植； JavaScript、Python等属于解释型语言。  （2）编译型语言\n使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：\n 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高； 与特定平台相关，一般无法移植到其他平台； C、C++等属于编译型语言。  **两者主要区别在于：**前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。\n25. for\u0026hellip;in和for\u0026hellip;of的区别 for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\n for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名； for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链； 对于数组的遍历，for…of 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…in 只返回数组的下标对应的属性值；  **总结：**for\u0026hellip;in 循环主要是为了遍历对象而生，不适用于遍历数组；for\u0026hellip;of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\n26. 如何使用for\u0026hellip;of遍历对象 for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。\n如果需要遍历的对象是类数组对象，用Array.from转成数组即可。\n1 2 3 4 5 6 7 8 9  var obj = { 0:\u0026#39;one\u0026#39;, 1:\u0026#39;two\u0026#39;, length: 2 }; obj = Array.from(obj); for(var k of obj){ console.log(k) }   如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  //方法一： var obj = { a:1, b:2, c:3 }; obj[Symbol.iterator] = function(){ var keys = Object.keys(this); var count = 0; return { next(){ if(count\u0026lt;keys.length){ return {value: obj[keys[count++]],done:false}; }else{ return {value:undefined,done:true}; } } } }; for(var k of obj){ console.log(k); } // 方法二 var obj = { a:1, b:2, c:3 }; obj[Symbol.iterator] = function(){ var keys = Object.keys(obj); for(var k of keys){ yield [k,obj[k]] } }; for(var [k,v] of obj){ console.log(k,v); }   27. ajax、axios、fetch的区别 （1）AJAX\nAjax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\n 本身是针对MVC编程，不符合前端MVVM的浪潮 基于原生XHR开发，XHR本身的架构不清晰 不符合关注分离（Separation of Concerns）的原则 配置和调用方式非常混乱，而且基于事件的异步模型不友好。  （2）Fetch\nfetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。\nfetch的优点：\n 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 更加底层，提供的API丰富（request, response） 脱离了XHR，是ES规范里新的实现方式  fetch的缺点：\n fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: \u0026lsquo;include\u0026rsquo;}) fetch不支持abort，取消请求，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 fetch没有原生方法检测请求地进度，而XHR可以  （3）Axios\nAxios 是一种基于Promise封装的HTTP客户端，其特点如下：\n 浏览器端发起XMLHttpRequests请求 node端发起http请求 支持Promise API 监听请求和返回 对请求和返回进行转化 取消请求 自动转换json数据 客户端支持抵御XSRF攻击  28. 数组的遍历方法有哪些    方法 是否改变原数组 特点     forEach() 取决于元素的数据类型 数组方法，没有返回值，是否会改变原数组取决于数组元素的类型是基本类型还是引用类型，详细解释可参考文章：《forEach到底可以改变原数组吗》   map() 否 数组方法，不改变原数组，有返回值，可链式调用   filter() 否 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用   for\u0026hellip;of 否 for\u0026hellip;of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环   every() 和 some() 否 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.   find() 和 findIndex() 否 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值   reduce() 和 reduceRight() 否 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作    遍历方法的详细解释：《细数JavaScript中那些遍历和循环》\n29. forEach和map方法有什么区别 这方法都是用来遍历数组的，两者区别如下：\n forEach()方法会针对每一个元素执行提供的函数，该方法没有返回值，是否会改变原数组取决于数组元素的类型是基本类型还是引用类型，详细解释可参考文章：《forEach到底可以改变原数组吗》 map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；  四、原型与原型链 1. 对原型、原型链的理解 在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n注意：所有构造函数的显示原型上的方法和属性，都能通过该构造函数的实例去访问，也就是说原型对象上的属性和方法都是共享的。\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n**特点：**JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n2. 原型修改、重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Person(name) { this.name = name } // 修改原型 Person.prototype.getName = function() {} var p = new Person(\u0026#39;hello\u0026#39;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // true // 重写原型 Person.prototype = { getName: function() {} } var p = new Person(\u0026#39;hello\u0026#39;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // false   可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor === Object ，而不是p.constructor === Person。要想成立，就要用constructor指回来：\n1 2 3 4 5 6 7  Person.prototype = { getName: function() {} } var p = new Person(\u0026#39;hello\u0026#39;) p.constructor = Person console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // true   3. 原型链指向 1 2 3 4 5 6 7  p.__proto__ // Person.prototype Person.prototype.__proto__ // Object.prototype p.__proto__.__proto__ //Object.prototype p.__proto__.constructor.prototype.__proto__ // Object.prototype Person.prototype.constructor.prototype.__proto__ // Object.prototype p1.__proto__.constructor // Person Person.prototype.constructor // Person   1 2 3 4 5 6 7  p.__proto__ // Person.prototype Person.prototype.__proto__ // Object.prototype p.__proto__.__proto__ //Object.prototype p.__proto__.constructor.prototype.__proto__ // Object.prototype Person.prototype.constructor.prototype.__proto__ // Object.prototype p1.__proto__.constructor // Person Person.prototype.constructor // Person   4. 原型链的终点是什么？如何打印出原型链的终点？ 由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。\n5. 如何获得对象非原型链上的属性？ 使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：hasOwnProperty用于判断是否是某实例本身拥有的属性和方法，有则返回true，没有则返回false，不会沿着原型链去寻找\n1 2 3 4 5 6 7 8  function iterate(obj){ var res=[]; for(var key in obj){ if(obj.hasOwnProperty(key)) res.push(key+\u0026#39;: \u0026#39;+obj[key]); } return res; }   五、执行上下文/作用域链/闭包 1. 对闭包的理解 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n闭包有两个常用的用途；\n 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。  删除闭包中的变量：\n​\t首先如果是函数访问了外部变量而自动创建了闭包的这种情况，我们是无需操心的，因为它会自动销毁，而如果是我们手动去实现的闭包，我们可以把访问的函数局部变量值设为 null , 即手动清除变量，这样 js 垃圾回收器在下一次垃圾回收时就会把这个局部变量回收，从而就销毁了这个手动设的闭包。\n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n1 2 3 4 5 6 7 8  function A() { let a = 1 window.B = function () { console.log(a) } } A() B() // 1   在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\n1 2 3 4 5  for (var i = 1; i \u0026lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) }   首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：\n 第一种是使用闭包的方式  1 2 3 4 5 6 7  for (var i = 1; i \u0026lt;= 5; i++) { ;(function(j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i) }   在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。\n 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。  1 2 3 4 5 6 7 8 9  for (var i = 1; i \u0026lt;= 5; i++) { setTimeout( function timer(j) { console.log(j) }, i * 1000, i ) }    第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式  1 2 3 4 5  for (let i = 1; i \u0026lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) }   2. 对作用域、作用域链的理解 1）全局作用域和函数作用域 （1）全局作用域\n 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未定义直接赋值的变量自动声明为全局作用域 所有window对象的属性拥有全局作用域 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。  （2）函数作用域\n 函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到 作用域是分层的，内层作用域可以访问外层作用域，反之不行  2）块级作用域  使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段） let和const声明的变量不会有变量提升，也不可以重复声明 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。  作用域链：\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。\n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n3. 对执行上下文的理解 1. 执行上下文类型 （1）全局执行上下文\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n（2）函数执行上下文\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n（3）**eval**函数执行上下文\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\n2. 执行上下文栈  JavaScript引擎使用执行上下文栈来管理执行上下文 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。  1 2 3 4 5 6 7 8 9 10 11 12  let a = \u0026#39;Hello World!\u0026#39;; function first() { console.log(\u0026#39;Inside first function\u0026#39;); second(); console.log(\u0026#39;Again inside first function\u0026#39;); } function second() { console.log(\u0026#39;Inside second function\u0026#39;); } first(); //执行顺序 //先执行second(),在执行first()   3. 创建执行上下文 创建执行上下文有两个阶段：创建阶段和执行阶段\n1）创建阶段\n（1）this绑定\n 在全局执行上下文中，this指向全局对象（window对象） 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined  （2）创建词法环境组件\n 词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。 词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域  （3）创建变量环境组件\n 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。  2）执行阶段\n此阶段会完成对变量的分配，最后执行完代码。\n简单来说执行上下文就是指：\n在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n 全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments  六、this/call/apply/bind 1. 对this对象的理解 this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。 第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。 函数调用 方法调用 构造函数调用 call，apply，bind调用  这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n2. call() 和 apply() 的区别？ 它们的作用一模一样，区别仅在于传入参数的形式的不同。\n apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。  3. 实现call、apply 及 bind 函数（建议看一下鲨鱼哥的掘金手写） （1）call 函数的实现步骤：\n 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 判断传入上下文对象是否存在，如果不存在，则设置为 window 。 处理传入的参数，截取第一个参数后的所有参数。 将函数作为上下文对象的一个属性。 使用上下文对象来调用这个方法，并保存返回结果。 删除刚才新增的属性。 返回结果。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Function.prototype.myCall = function(context) { // 判断调用对象  if (typeof this !== \u0026#34;function\u0026#34;) { console.error(\u0026#34;type error\u0026#34;); } // 获取参数：也可以在形参中使用rest参数获取（contex,...args）  let args = [...arguments].slice(1), result = null; // 判断 context 是否传入，如果未传入则设置为 window  context = context || window; // 将调用函数设为对象的方法：这里的this就是函数本身  context.fn = this; // 调用函数  result = context.fn(...args); // 将属性删除  delete context.fn; return result; };   （2）apply 函数的实现步骤：\n 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 判断传入上下文对象是否存在，如果不存在，则设置为 window 。 将函数作为上下文对象的一个属性。 判断参数值是否传入 使用上下文对象来调用这个方法，并保存返回结果。 删除刚才新增的属性 返回结果  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Function.prototype.myApply = function(context) { // 判断调用对象是否为函数  if (typeof this !== \u0026#34;function\u0026#34;) { throw new TypeError(\u0026#34;Error\u0026#34;); } let result = null; // 判断 context 是否存在，如果未传入则为 window  context = context || window; // 将函数设为对象的方法  context.fn = this; // 调用方法：apply只允许有两个参数，所以第二个参数就是一个函数的形参（类）数组对象  if (arguments[1]) { result = context.fn(...arguments[1]); } else { result = context.fn(); } // 将属性删除  delete context.fn; return result; };   （3）bind 函数的实现步骤：\n 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 保存当前函数的引用，获取其余传入参数值。 创建一个函数返回 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Function.prototype.myBind = function(context) { // 判断调用对象是否为函数  if (typeof this !== \u0026#34;function\u0026#34;) { throw new TypeError(\u0026#34;Error\u0026#34;); } // 获取参数  var args = [...arguments].slice(1), fn = this; return function Fn() { // 根据调用方式，传入不同绑定值  return fn.apply( this instanceof Fn ? this : context, args.concat(...arguments) ); }; };   七、异步编程 1. 异步编程的实现方式？ JavaScript中的异步机制可以分为以下几种：\n 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。  2. setTimeout、Promise、Async/Await 的区别 （1）setTimeout 1 2 3 4 5 6  console.log(\u0026#39;script start\u0026#39;) //1. 打印 script start setTimeout(function(){ console.log(\u0026#39;settimeout\u0026#39;) // 4. 打印 settimeout }) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数 console.log(\u0026#39;script end\u0026#39;) //3. 打印 script start // 输出顺序：script start-\u0026gt;script end-\u0026gt;settimeout   （2）Promise Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13  console.log(\u0026#39;script start\u0026#39;) let promise1 = new Promise(function (resolve) { console.log(\u0026#39;promise1\u0026#39;) resolve() console.log(\u0026#39;promise1 end\u0026#39;) }).then(function () { console.log(\u0026#39;promise2\u0026#39;) }) setTimeout(function(){ console.log(\u0026#39;settimeout\u0026#39;) }) console.log(\u0026#39;script end\u0026#39;) // 输出顺序: script start-\u0026gt;promise1-\u0026gt;promise1 end-\u0026gt;script end-\u0026gt;promise2-\u0026gt;settimeout   当JS主线程执行到Promise对象时：\n promise1.then() 的回调就是一个 task promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue（微任务队列） promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中 setTimeout 的回调也是个 task ，它会被放入 macrotask queue（宏任务队列） 即使是 0ms 的情况  （3）async/await 1 2 3 4 5 6 7 8 9 10 11 12  async function async1(){ console.log(\u0026#39;async1 start\u0026#39;); await async2(); console.log(\u0026#39;async1 end\u0026#39;) } async function async2(){ console.log(\u0026#39;async2\u0026#39;) } console.log(\u0026#39;script start\u0026#39;); async1(); console.log(\u0026#39;script end\u0026#39;) // 输出顺序：script start-\u0026gt;async1 start-\u0026gt;async2-\u0026gt;script end-\u0026gt;async1 end   async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n例如：\n1 2 3 4  async function func1() { return 1 } console.log(func1())   func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。\n1 2 3  func1().then(res =\u0026gt; { console.log(res); // 30 })   await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。\n3. 对Promise的理解 Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n（1）Promise的实例有三个状态:\n Pending（进行中） Resolved（已完成） Rejected（已拒绝）  当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。\n（2）Promise的实例有两个过程：\n pending -\u0026gt; fulfilled : Resolved（已完成） pending -\u0026gt; rejected：Rejected（已拒绝）  注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\nPromise的特点：\n 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”； 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。  Promise的缺点：\n 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  总结：\nPromise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n**注意：**在构造 Promise 的时候，构造函数内部的代码是立即执行的\n4. Promise的基本用法 （1）创建Promise对象 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n1 2 3 4 5 6 7 8  const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } });   一般情况下都会使用**new Promise()**来创建promise对象，但是也可以使用**promise.resolve**和 **promise.reject**这两个方法：\n Promise.resolve  Promise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：\n1 2 3  Promise.resolve(11).then(function(value){ console.log(value); // 打印出11 });   resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；\n创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；\n Promise.reject  Promise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：\n1  Promise.reject(new Error(“我错了，请原谅俺！！”));   就是下面的代码new Promise的简单形式：\n1 2 3  new Promise(function(resolve,reject){ reject(new Error(\u0026#34;我错了，请原谅俺！！\u0026#34;)); });   下面是使用resolve方法和reject方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function testPromise(ready) { return new Promise(function(resolve,reject){ if(ready) { resolve(\u0026#34;hello world\u0026#34;); }else { reject(\u0026#34;No thanks\u0026#34;); } }); }; // 方法调用 testPromise(true).then(function(msg){ console.log(msg); },function(error){ console.log(error); });   上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；\n（2）Promise方法 Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。\n then()  当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？\n1 2 3 4 5  promise.then(function(value) { // success }, function(error) { // failure });   then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。\nthen方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n当要写有顺序的异步事件时，需要串行时，可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let promise = new Promise((resolve,reject)=\u0026gt;{ ajax(\u0026#39;first\u0026#39;).success(function(res){ resolve(res); }) }) promise.then(res=\u0026gt;{ return new Promise((resovle,reject)=\u0026gt;{ ajax(\u0026#39;second\u0026#39;).success(function(res){ resolve(res) }) }) }).then(res=\u0026gt;{ return new Promise((resovle,reject)=\u0026gt;{ ajax(\u0026#39;second\u0026#39;).success(function(res){ resolve(res) }) }) }).then(res=\u0026gt;{ })   那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。\n2. catch()\nPromise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。\n1 2 3 4 5 6 7 8 9 10 11  p.then((data) =\u0026gt; { console.log(\u0026#39;resolved\u0026#39;,data); },(err) =\u0026gt; { console.log(\u0026#39;rejected\u0026#39;,err); } ); p.then((data) =\u0026gt; { console.log(\u0026#39;resolved\u0026#39;,data); }).catch((err) =\u0026gt; { console.log(\u0026#39;rejected\u0026#39;,err); });   3. all()\nall方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  javascript let promise1 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(1); },2000) }); let promise2 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(2); },1000) }); let promise3 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(3); },3000) }); Promise.all([promise1,promise2,promise3]).then(res=\u0026gt;{ console.log(res); //结果为：[1,2,3] })   调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。\n（4）race()\nrace方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let promise1 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ reject(1); },2000) }); let promise2 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(2); },1000) }); let promise3 = new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(3); },3000) }); Promise.race([promise1,promise2,promise3]).then(res=\u0026gt;{ console.log(res); //结果：2 },rej=\u0026gt;{ console.log(rej)}; )   那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n1  Promise.race([promise1,timeOutPromise(5000)]).then(res=\u0026gt;{})   5. finally()\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n1 2 3 4  promise .then(result =\u0026gt; {···}) .catch(error =\u0026gt; {···}) .finally(() =\u0026gt; {···});   上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。\n1 2 3 4 5  server.listen(port) .then(function () { // ... }) .finally(server.stop);   finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  promise .finally(() =\u0026gt; { // 语句 }); // 等同于 promise .then( result =\u0026gt; { // 语句 return result; }, error =\u0026gt; { // 语句 throw error; } );   上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n5. Promise解决了什么问题 在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：\n1 2 3 4 5 6 7 8  let fs = require(\u0026#39;fs\u0026#39;) fs.readFile(\u0026#39;./a.txt\u0026#39;,\u0026#39;utf8\u0026#39;,function(err,data){ fs.readFile(data,\u0026#39;utf8\u0026#39;,function(err,data){ fs.readFile(data,\u0026#39;utf8\u0026#39;,function(err,data){ console.log(data) }) }) })   上面的代码有如下缺点：\n 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。  Promise出现之后，代码变成这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let fs = require(\u0026#39;fs\u0026#39;) function read(url){ return new Promise((resolve,reject)=\u0026gt;{ fs.readFile(url,\u0026#39;utf8\u0026#39;,function(error,data){ error \u0026amp;\u0026amp; reject(error) resolve(data) }) }) } read(\u0026#39;./a.txt\u0026#39;).then(data=\u0026gt;{ return read(data) }).then(data=\u0026gt;{ return read(data) }).then(data=\u0026gt;{ console.log(data) })   这样代码看起了就简洁了很多，解决了地狱回调的问题。\n6. Promise.all和Promise.race的区别的使用场景 **（1）**Promise.all\nPromise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\nPromise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\n（2）Promise.race\n顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n1  Promise.race([promise1,timeOutPromise(5000)]).then(res=\u0026gt;{})   7. 对async/await 的理解 async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：\n1 2 3 4 5  async function testAsy(){ return \u0026#39;hello world\u0026#39;; } let result = testAsy(); console.log(result)   所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：\n1 2 3 4 5 6 7 8  async function testAsy(){ return \u0026#39;hello world\u0026#39; } let result = testAsy() console.log(result) result.then(v=\u0026gt;{ console.log(v) // hello world })   那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。\n联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n注意：Promise.resolve(x) 可以看作是 new Promise(resolve =\u0026gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n8. await 到底在等啥？ **await 在等待什么呢？**一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：\n1 2 3 4 5 6 7 8 9 10 11 12  function getSomething() { return \u0026#34;something\u0026#34;; } async function testAsync() { return Promise.resolve(\u0026#34;hello async\u0026#34;); } async function test() { const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2); } test();   await 表达式的运算结果取决于它等的是什么。\n 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。  来看一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function testAsy(x){ return new Promise(resolve=\u0026gt;{setTimeout(() =\u0026gt; { resolve(x); }, 3000) } ) } async function testAwt(){ let result = await testAsy(\u0026#39;hello world\u0026#39;); console.log(result); // 3秒钟之后出现hello world console.log(\u0026#39;cuger\u0026#39;) // 3秒钟之后出现cug } testAwt(); console.log(\u0026#39;cug\u0026#39;) //立即输出cug   这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以\u0026rsquo;cug'\u0026lsquo;最先输出，hello world\u0026rsquo;和‘cuger’是3秒钟后同时出现的。\n9. async/await的优势 单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */ function takeLongTime(n) { return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; resolve(n + 200), n); }); } function step1(n) { console.log(`step1 with ${n}`); return takeLongTime(n); } function step2(n) { console.log(`step2 with ${n}`); return takeLongTime(n); } function step3(n) { console.log(`step3 with ${n}`); return takeLongTime(n); }   现在用 Promise 方式来实现这三个步骤的处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function doIt() { console.time(\u0026#34;doIt\u0026#34;); const time1 = 300; step1(time1) .then(time2 =\u0026gt; step2(time2)) .then(time3 =\u0026gt; step3(time3)) .then(result =\u0026gt; { console.log(`result is ${result}`); console.timeEnd(\u0026#34;doIt\u0026#34;); }); } doIt(); // c:\\var\\test\u0026gt;node --harmony_async_await . // step1 with 300 // step2 with 500 // step3 with 700 // result is 900 // doIt: 1507.251ms   如果用 async/await 来实现呢，会是这样：\n1 2 3 4 5 6 7 8 9 10  async function doIt() { console.time(\u0026#34;doIt\u0026#34;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is ${result}`); console.timeEnd(\u0026#34;doIt\u0026#34;); } doIt();   结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n10. async/await对比Promise的优势  代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。  11. async/await 如何捕获异常 1 2 3 4 5 6 7  async function fn(){ try{ let a = await Promise.reject(\u0026#39;error\u0026#39;) }catch(error){ console.log(error) } }   12. 并发与并行的区别？\u0026mdash;了解即可  并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。  13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？ 什么是回调函数：\n​\t将函数作为一个参数传递，该函数不会立即执行，会在未来的有需要时执行该函数（某一个事件被触发，或者某个时间节点到达时）。\n以下代码就是一个回调函数的例子：\n1 2 3  ajax(url, () =\u0026gt; { // 处理逻辑 })   回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：\n1 2 3 4 5 6 7 8 9  ajax(url, () =\u0026gt; { // 处理逻辑 ajax(url1, () =\u0026gt; { // 处理逻辑 ajax(url2, () =\u0026gt; { // 处理逻辑 }) }) })   以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function firstAjax() { ajax(url1, () =\u0026gt; { // 处理逻辑 secondAjax() }) } function secondAjax() { ajax(url2, () =\u0026gt; { // 处理逻辑 }) } ajax(url, () =\u0026gt; { // 处理逻辑 firstAjax() })   以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：\n 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身 嵌套函数一多，就很难处理错误  当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。\n14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？ 异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。\n其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  let period = 60 * 1000 * 60 * 2 let startTime = new Date().getTime() let count = 0 let end = new Date().getTime() + period let interval = 1000 let currentInterval = interval function loop() { count++ // 代码执行所消耗的时间 let offset = new Date().getTime() - (startTime + count * interval); let diff = end - new Date().getTime() let h = Math.floor(diff / (60 * 1000 * 60)) let hdiff = diff % (60 * 1000 * 60) let m = Math.floor(hdiff / (60 * 1000)) let mdiff = hdiff % (60 * 1000) let s = mdiff / (1000) let sCeil = Math.ceil(s) let sFloor = Math.floor(s) // 得到下一次循环所消耗的时间 currentInterval = interval - offset console.log(\u0026#39;时：\u0026#39;+h, \u0026#39;分：\u0026#39;+m, \u0026#39;毫秒：\u0026#39;+s, \u0026#39;秒向上取整：\u0026#39;+sCeil, \u0026#39;代码执行时间：\u0026#39;+offset, \u0026#39;下次循环间隔\u0026#39;+currentInterval) setTimeout(loop, currentInterval) } setTimeout(loop, currentInterval)   接下来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。\n通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码\n1 2 3 4 5 6 7  function demo() { setInterval(function(){ console.log(2) },1000) sleep(2000) } demo()   以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。\n如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function setInterval(callback, interval) { let timer const now = Date.now let startTime = now() let endTime = startTime const loop = () =\u0026gt; { timer = window.requestAnimationFrame(loop) endTime = now() if (endTime - startTime \u0026gt;= interval) { startTime = endTime = now() callback(timer) } } timer = window.requestAnimationFrame(loop) return timer } let a = 0 setInterval(timer =\u0026gt; { console.log(1) a++ if (a === 3) cancelAnimationFrame(timer) }, 1000)   首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。\n八、面向对象 1. 对象创建的方式有哪些？ 一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n2. 对象继承的方式有哪些？ （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n九、垃圾回收与内存泄漏\u0026mdash;了解即可 1. 浏览器的垃圾回收机制 （1）垃圾回收的概念 垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\n回收机制：\n Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。  （2）垃圾回收的方式 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。\n1）标记清除\n 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。  2）引用计数\n 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。  1 2 3 4 5 6  function fun() { let obj1 = {}; let obj2 = {}; obj1.a = obj2; // obj1 引用 obj2 obj2.a = obj1; // obj2 引用 obj1 }   这种情况下，就要手动释放变量占用的内存：\n1 2  obj1.a = null obj2.a = null   （3）减少垃圾回收 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\n **对数组进行优化：**在清空一个数组时，最简单的方法就是给其赋值为，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 对**object****进行优化：**对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 **对函数进行优化：**在循环中的函数表达式，如果可以复用，尽量放在函数的外面。  2. 哪些情况会导致内存泄漏 定义：由于疏忽或错误造成程序未能释放已经不再使用的内存，也就是内存被一些无用的东西给占用\n以下四种情况会造成内存的泄漏：\n **意外的全局变量：**由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 **被遗忘的计时器或回调函数：**设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 **脱离 DOM 的引用：**获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 **闭包：**不合理的使用闭包，从而导致某些变量一直被留在内存当中。  3.内存溢出 定义：是指程序在申请内存时，没有足够的内存空间供其使用\n","permalink":"https://coderrenxy.github.io/posts/read/5-javascript%E7%AF%87/","summary":"一、数据类型 1. JavaScript有哪些数据类型，它们的区别？ JavaScript共有八种数据类型，分别是 Undefined、Null、Bo","title":"JS"},{"content":"author: [\u0026ldquo;小任同学\u0026rdquo;] draft: false # 是否为草稿 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: flase # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 date: 2023-06-26T00:15:37+08:00 lastmod: 2023-06-26T00:15:37+08:00\t#更新文章的时候手动改一下时间就可以 tags:\n 阅读 description: \u0026ldquo;css\u0026rdquo; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026quot;\u0026quot;  cover: image: \u0026quot;\u0026quot; caption: \u0026quot;\u0026quot; alt: \u0026quot;\u0026quot; relative: false Vue面试题推荐配合鲨鱼哥掘金文章-最全的Vue面试题 一起看 一、Vue 基础 1. Vue的基本原理 vue的基本原理主要包含两部分，第一是虚拟DOM部分，这是diff算法处理的对象，用于保证vue的性能。第二是双向数据绑定原理，vue借鉴mvvm模型，分离视图层和数据层，以vue作用二者的媒介，达到数据变更，试图更新，视图更新，数据变更。\n2. 双向数据绑定的原理 Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退 Dep依赖管理类（属性订阅器）：里面含有一个static 属性 target，全局唯一，保证同一时刻只有一个watcher被计算，每一个watcher中都有一个Dep的实例，dep主要进行依赖管理，depend方法添加依赖，removeDepend删除依赖，notice通知更新。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\u0026gt; 视图更新；视图交互变化(input) -\u0026gt; 数据model变更的双向绑定效果。  3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ 在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\n在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。\n4. MVVM、MVC、MVP的区别 MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n（1）MVC\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。\n（2）MVVM\nMVVM 分为 Model、View、ViewModel：\n Model代表数据模型，数据和业务逻辑都在Model层中定义； View代表UI视图，负责数据的展示； ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；  Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。\n（3）MVP\nMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。\n5. Computed 和 Watch 的区别 对于Computed：\n 它支持缓存，只有依赖的数据发生了变化，才会重新计算 不支持异步，当Computed中有异步操作时，无法监听数据的变化 computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed 如果computed属性的属性值是函数， 那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。  对于Watch：\n  它不支持缓存，数据变化时，它就会触发相应的操作\n  支持异步监听\n  监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n  当一个属性发生变化时，就需要执行相应的操作\n  监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n   immediate：组件加载立即触发回调函数 deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。    当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。\n总结：\n computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。  运用场景：\n 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。  6. Computed 和 Methods 的区别 可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\n不同点：\n computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值； method 调用总会执行该函数。  7. slot是什么？有什么作用？原理是什么？ slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。\n 默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。  实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。\n8. 过滤器的作用，如何实现一个过滤器 根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。\n使用场景：\n 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。  过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 **{{ }}** 和 **v-bind** 表达式 中，然后放在操作符“ **|** ”后面进行指示。\n例如，在显示金额，给商品价格添加单位：\n1 2 3 4 5 6 7  \u0026lt;li\u0026gt;商品价格：{{item.price | filterPrice}}\u0026lt;/li\u0026gt; filters: { filterPrice (price) { return price ? (\u0026#39;￥\u0026#39; + price) : \u0026#39;--\u0026#39; } }   9. 如何保存页面的当前的状态 既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：\n 前组件会被卸载 前组件不会被卸载  那么可以按照这两种情况分别得到以下方法：\n组件会被卸载：\n（1）将状态存储在LocalStorage / SessionStorage\n只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。\n比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。\n优点  兼容性好，不需要额外库或工具。 简单快捷，基本可以满足大部分需求。  缺点  状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点） 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象  （2）路由传值\n通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。\n在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。\n优点  简单快捷，不会污染 LocalStorage / SessionStorage。 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）  缺点  如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。  组件不会被卸载：\n（1）单页面渲染\n要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。\n优点  代码量少 不需要考虑状态传递过程中的错误  缺点  增加 A 组件维护成本 需要传入额外的 prop 到 B 组件 无法利用路由定位页面  除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行\n被包裹在keep-alive中的组件的状态将会被保留：\n1 2 3  \u0026lt;keep-alive\u0026gt; \u0026lt;router-view v-if=\u0026#34;$route.meta.keepAlive\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/kepp-alive\u0026gt;   router.js\n1 2 3 4 5 6 7 8  { path: \u0026#39;/\u0026#39;, name: \u0026#39;xxx\u0026#39;, component: ()=\u0026gt;import(\u0026#39;../src/views/xxx.vue\u0026#39;), meta:{ keepAlive: true // 需要被缓存 } },   10. 常见的事件修饰符及其作用  .stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡； .prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）； .capture ：与事件冒泡的方向相反，事件捕获由外到内； .self ：只会触发自己范围内的事件，不包含子元素； .once ：只会触发一次。 .native ：在组件身上绑定的事件会被优先解析为自定义事件，使用该修饰符意味着将该事件当作原生DOM事件进行处理  11. v-if、v-show、v-html 的原理  v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染； v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。  13. v-if和v-show的区别  手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐； 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留； 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。  14. v-model 是如何实现的，语法糖实际是什么？ （1）作用在表单元素上\n动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;input v-model=\u0026#34;sth\u0026#34; /\u0026gt; // 等同于 \u0026lt;input v-bind:value=\u0026#34;message\u0026#34; v-on:input=\u0026#34;message=$event.target.value\u0026#34; \u0026gt; //$event 指代当前触发的事件对象; //$event.target 指代当前触发的事件对象的dom; //$event.target.value 就是当前dom的value值; //在@input方法中，value =\u0026gt; sth; //在:value中,sth =\u0026gt; value;   （2）作用在组件上\n在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件\n**本质是一个父子组件通信的语法糖，通过prop和$.emit实现。**因此父组件 v-model 语法糖本质上可以修改为：\n1  \u0026lt;child :value=\u0026#34;message\u0026#34; @input=\u0026#34;function(e){message = e}\u0026#34;\u0026gt;\u0026lt;/child\u0026gt;   在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 父组件 \u0026lt;aa-input v-model=\u0026#34;aa\u0026#34;\u0026gt;\u0026lt;/aa-input\u0026gt; // 等价于 \u0026lt;aa-input v-bind:value=\u0026#34;aa\u0026#34; v-on:input=\u0026#34;aa=$event.target.value\u0026#34;\u0026gt;\u0026lt;/aa-input\u0026gt; // 子组件： \u0026lt;input v-bind:value=\u0026#34;aa\u0026#34; v-on:input=\u0026#34;onmessage\u0026#34;\u0026gt;\u0026lt;/aa-input\u0026gt; props:{value:aa,} methods:{ onmessage(e){ $emit(\u0026#39;input\u0026#39;,e.target.value) } }   默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。\n15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？ 可以。v-model 实际上是一个语法糖，如：\n在表单控件中使用：\n1  \u0026lt;input v-model=\u0026#34;searchText\u0026#34;\u0026gt;   实际上相当于：\n1 2 3  \u0026lt;input v-model:value=\u0026#34;searchText\u0026#34; \u0026gt;   在自定义组件中使用 ：\n1  \u0026lt;custom-input v-model=\u0026#34;searchText\u0026#34;\u0026gt;   相当于：\n1 2 3 4  \u0026lt;custom-input v-bind:value=\u0026#34;searchText\u0026#34; v-on:input=\u0026#34;searchText = $event\u0026#34; \u0026gt;\u0026lt;/custom-input\u0026gt;   显然，custom-input 与父组件的交互如下：\n 父组件将searchText变量传入custom-input 组件，使用的 prop 名为value； custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText；  所以，custom-input 组件的实现应该类似于这样：\n1 2 3 4 5 6 7 8 9  Vue.component(\u0026#39;custom-input\u0026#39;, { props: [\u0026#39;value\u0026#39;], template: ` \u0026lt;input v-bind:value=\u0026#34;value\u0026#34; v-on:input=\u0026#34;$emit(\u0026#39;input\u0026#39;, $event.target.value)\u0026#34; \u0026gt; ` })   16. data为什么是一个函数而不是对象 JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\n而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。\n17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？ 如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。\n**（1）**keep-alive\nkeep-alive有以下三个属性：\n include 字符串或正则表达式，只有名称匹配的组件会被匹配； exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存； max 数字，最多可以缓存多少组件实例。  注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。\n主要流程\n 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。 获取组件实例 key ，如果有获取实例的 key，否则重新生成。 key生成规则，cid +\u0026ldquo;∶∶\u0026rdquo;+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。  （2）keep-alive 的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const patternTypes: Array\u0026lt;Function\u0026gt; = [String, RegExp, Array] // 接收：字符串，正则，数组 export default { name: \u0026#39;keep-alive\u0026#39;, abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 props: { include: patternTypes, // 匹配的组件，缓存 exclude: patternTypes, // 不去匹配的组件，不缓存 max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限 }, created() { // 用于初始化缓存虚拟DOM数组和vnode的key this.cache = Object.create(null) this.keys = [] }, destroyed() { // 销毁缓存cache的组件实例 for (const key in this.cache) { pruneCacheEntry(this.cache, key, this.keys) } }, mounted() { // prune 削减精简[v.] // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容 this.$watch(\u0026#39;include\u0026#39;, (val) =\u0026gt; { pruneCache(this, (name) =\u0026gt; matches(val, name)) }) this.$watch(\u0026#39;exclude\u0026#39;, (val) =\u0026gt; { pruneCache(this, (name) =\u0026gt; !matches(val, name)) }) }, }   render函数：\n 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件 keep-alive 只对第一个组件有效，所以获取第一个子组件。 和 keep-alive 搭配使用的一般有：动态组件 和router-view  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  render () { // function getFirstComponentChild (children: ?Array\u0026lt;VNode\u0026gt;): ?VNode { if (Array.isArray(children)) { for (let i = 0; i \u0026lt; children.length; i++) { const c = children[i] if (isDef(c) \u0026amp;\u0026amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) { return c } } } } const slot = this.$slots.default // 获取默认插槽 const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件 const componentOptions: ?VNodeComponentOptions = vnode \u0026amp;\u0026amp; vnode.componentOptions // 组件参数 if (componentOptions) { // 是否有组件参数 // check pattern const name: ?string = getComponentName(componentOptions) // 获取组件名 const { include, exclude } = this if ( // not included (include \u0026amp;\u0026amp; (!name || !matches(include, name))) || // excluded (exclude \u0026amp;\u0026amp; name \u0026amp;\u0026amp; matches(exclude, name)) ) { // 如果不匹配当前组件的名字和include以及exclude // 那么直接返回组件的实例 return vnode } const { cache, keys } = this // 获取这个组件的key const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : \u0026#39;\u0026#39;) : vnode.key if (cache[key]) { // LRU缓存策略执行 vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined // make current key freshest remove(keys, key) keys.push(key) // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面 } else { // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除 // 使用时间间隔最长的一个 cache[key] = vnode keys.push(key) // prune oldest entry if (this.max \u0026amp;\u0026amp; keys.length \u0026gt; parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode) } } // 将组件的keepAlive属性设置为true vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数 } return vnode || (slot \u0026amp;\u0026amp; slot[0]) }   keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。\n实现步骤：\n 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode 需要缓存，判断他当前是否在缓存数组里面：   存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU） 不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key   最后将这个组件的 keepAlive 设置为 true  （3）keep-alive 本身的创建过程和 patch 过程\n缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。\n首次渲染\n 组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // core/instance/lifecycle function initLifecycle (vm: Component) { const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent \u0026amp;\u0026amp; !options.abstract) { // 判断组件的abstract属性，才往父组件里面挂载DOM while (parent.$options.abstract \u0026amp;\u0026amp; parent.$parent) { parent = parent.$parent } parent.$children.push(vm) } vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = {} vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false }    判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // core/vdom/create-component init (vnode: VNodeWithData, hydrating: boolean): ?boolean { if ( vnode.componentInstance \u0026amp;\u0026amp; !vnode.componentInstance._isDestroyed \u0026amp;\u0026amp; vnode.data.keepAlive ) { // componentInstance在初次是undefined!!! // kept-alive components, treat as a patch const mountedNode: any = vnode // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程 } else { const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) child.$mount(hydrating ? vnode.elm : undefined, hydrating) } },   prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入\n（4）LRU （least recently used）缓存策略\nLRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。\nLRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是**\u0026ldquo;如果数据最近被访问过，那么将来被访问的几率也更高\u0026rdquo;**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶\n 新数据插入到链表头部 每当缓存命中（即缓存数据被访问），则将数据移到链表头部 链表满的时候，将链表尾部的数据丢弃。  18. $nextTick 原理及作用 Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。\nnextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。\nnextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理\nnextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶\n 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染 同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要  Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。\n由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。\n1 2 3  this.$nextTick(() =\u0026gt; { // 获取数据的操作... })   所以，在以下情况下，会用到nextTick：\n 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。  因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。\n应用：\n  input获取焦点问题：\ninput.focus()操作必须放在$nextTick()之中，保证input框已经挂载到页面之上\n  轮播图显示问题：\n在我的第三个小作品当中，也应用到了该生命周期函数\n场景：\n​\t独立封装Swiper轮播图，作为其他组件的子组件进行渲染，轮播图的数据通过父组件传递过去，再通过v-for遍历数据生成轮播图的结构，轮播图的js交互部分就是new Swiper 实例来实现\n​\t如果不适用$nextTick，则轮播图始终会有问题，图片不完整，没有交互效果，或者只有部分交互效果，通过查资料，我发现是因为在创建swiper实例的时候需要用到页面中的DOM结构，而创建实例的时候，dom的结构还没有完全生成，所以导致轮播图效果不完整。\n​\t解决方案是将创建Swiper实例的操作放在$nextTick函数中，这样保证了dom结构已经渲染完成，轮播图的效果也就完善了。\n​\t因为我这里的数据是直接从父组件中传递过来的，所以不存在没拿到数据的情况，如果是在该组件中进行异步操作获取数据的话，$nextTick还需要搭配watch去使用，也就是适用watch监听数据是否已经返回，然后再使用$nextTick\n  19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;value in obj\u0026#34; :key=\u0026#34;value\u0026#34;\u0026gt; {{value}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;addObjB\u0026#34;\u0026gt;添加 obj.b\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return { obj: { a: \u0026#39;obj.a\u0026#39; } } }, methods: { addObjB () { this.obj.b = \u0026#39;obj.b\u0026#39; console.log(this.obj) } } } \u0026lt;/script\u0026gt;   点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：\n1 2 3 4  addObjB () ( this.$set(this.obj, \u0026#39;b\u0026#39;, \u0026#39;obj.b\u0026#39;) console.log(this.obj) }   $set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。\n20. Vue中封装的数组方法有哪些，其如何实现页面更新 在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。\n那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 缓存数组原型 const arrayProto = Array.prototype; // 实现 arrayMethods.__proto__ === Array.prototype export const arrayMethods = Object.create(arrayProto); // 需要进行功能拓展的方法 const methodsToPatch = [ \u0026#34;push\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;unshift\u0026#34;, \u0026#34;splice\u0026#34;, \u0026#34;sort\u0026#34;, \u0026#34;reverse\u0026#34; ]; /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function(method) { // 缓存原生数组方法 const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) { // 执行并缓存原生数组功能 const result = original.apply(this, args); // 响应式处理 const ob = this.__ob__; let inserted; switch (method) { // push、unshift会新增索引，所以要手动observer case \u0026#34;push\u0026#34;: case \u0026#34;unshift\u0026#34;: inserted = args; break; // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。 case \u0026#34;splice\u0026#34;: inserted = args.slice(2); break; } // if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听 // notify change ob.dep.notify();// 通知依赖更新 // 返回原生数组方法的执行结果 return result; }); });   简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。\n21. Vue 单页应用与多页应用的区别 概念：\n SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。 MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。  区别：\n22. Vue template 到 render 的过程 vue的模版编译过程主要如下：template -\u0026gt; ast -\u0026gt; render函数\nvue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：\n1 2  // 将模板编译为render函数 const { render, staticRenderFns } = compileToFunctions(template,options//省略}, this)   CompileToFunctions中的主要逻辑如下∶\n（1）调用parse方法将template转化为ast（抽象语法树）\n1  constast = parse(template.trim(), options)    parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。  AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本\n（2）对静态节点做优化\n1  optimize(ast,options)   这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化\n深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。\n（3）生成代码\n1  const code = generate(ast, options)   generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(`` render``) 生成render函数。\n23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ 不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。\n24. 简述 mixin、extends 的覆盖逻辑 （1）mixin 和 extends\nmixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。\n mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。  （2）mergeOptions 的执行过程\n 规范化选项（normalizeProps、normalizelnject、normalizeDirectives) 对未合并的选项，进行判断  1 2 3 4 5 6 7 8 9 10  if(!child._base) { if(child.extends) { parent = mergeOptions(parent, child.extends, vm) } if(child.mixins) { for(let i = 0, l = child.mixins.length; i \u0026lt; l; i++){ parent = mergeOptions(parent, child.mixins[i], vm) } } }    合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。 返回合并结果 options。  25. 描述下Vue自定义指令 在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。\n一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;\n（1）自定义指令基本内容\n 全局定义：Vue.directive(\u0026quot;focus\u0026quot;,{}) 局部定义：directives:{focus:{}} 钩子函数：指令定义对象提供钩子函数  ​ o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n​ o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。\n​ o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。\n​ o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。\n​ o unbind：只调用一次，指令与元素解绑时调用。\n 钩子函数参数  ​ o el：绑定元素\n​ o bing： 指令核心对象，描述指令全部信息属性\n​ o name\n​ o value\n​ o oldValue\n​ o expression\n​ o arg\n​ o modifers\n​ o vnode 虚拟节点\n​ o oldVnode：上一个虚拟节点（更新钩子函数中才有用）\n（2）使用场景\n 普通DOM元素进行底层操作的时候，可以使用自定义指令 自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。  （3）使用案例\n初级应用：\n 鼠标聚焦 下拉菜单 相对时间转换 滚动动画  高级应用：\n 自定义指令实现图片懒加载 自定义指令集成第三方插件  26. 子组件可以直接改变父组件的数据吗？ 子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。\nVue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。\n只能通过 **$emit** 派发一个自定义事件，父组件接收到后，由父组件修改。\n27. Vue是如何收集依赖的？ 在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function defieneReactive (obj, key, val){ const dep = new Dep(); ... Object.defineProperty(obj, key, { ... get: function reactiveGetter () { if(Dep.target){ dep.depend(); ... } return val } ... }) }   以上只保留了关键代码，主要就是 const dep = new Dep()实例化一个 Dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。\n（1）Dep\nDep是整个依赖收集的核心，其关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Dep { static target; subs; constructor () { ... this.subs = []; } addSub (sub) { this.subs.push(sub) } removeSub (sub) { remove(this.sub, sub) } depend () { if(Dep.target){ Dep.target.addDep(this) } } notify () { const subs = this.subds.slice(); for(let i = 0;i \u0026lt; subs.length; i++){ subs[i].update() } } }   Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶\n（2）Watcher\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Watcher { getter; ... constructor (vm, expression){ ... this.getter = expression; this.get(); } get () { pushTarget(this); value = this.getter.call(vm, vm) ... return value } addDep (dep){ ... dep.addSub(this) } ... } function pushTarget (_target) { Dep.target = _target }   Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。\n（3）过程\n在实例化 Vue 时，依赖收集的相关过程如下∶\n初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。\n初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，\n1 2 3 4  updateComponent = () =\u0026gt; { vm._update(vm._render()) } new Watcher(vm, updateComponent)   get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。\nthis.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。\n28. 对 React 和 Vue 的理解，它们的异同 相似之处：\n 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库； 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板； 都使用了Virtual DOM（虚拟DOM）提高重绘性能； 都有props的概念，允许组件间的数据传递； 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。  不同之处 ：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入\u0026quot;Virtual DOM\u0026quot;，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。  3）组件化\nReact与Vue最大的不同是模板的编写。\n Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。 React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。  具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。\n4）监听数据变化的实现原理不同\n Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。  5）高阶组件\nreact可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具：\n React ==\u0026gt; Create React APP Vue ==\u0026gt; vue-cli  7）跨平台\n React ==\u0026gt; React Native Vue ==\u0026gt; Weex  29. Vue的优点  轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ； 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单； 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势； 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式； 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。  30. assets和static的区别 相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点\n不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。\n建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。\n31. delete和Vue.delete删除数组的区别  delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。 Vue.delete 直接删除了数组 改变了数组的键值。  32. vue如何监听对象或者数组某个属性的变化 当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。\n解决方式：\n this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)  1 2  this.$set(this.arr, 0, \u0026#34;OBKoro1\u0026#34;); // 改变数组 this.$set(this.obj, \u0026#34;c\u0026#34;, \u0026#34;OBKoro1\u0026#34;); // 改变对象    调用以下几个数组的方法  1  splice()、 push()、pop()、shift()、unshift()、sort()、reverse()   vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作\nvm.$set 的实现原理是：\n 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）  33. 什么是 mixin ？  Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。  34. Vue模版编译原理 vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。\n 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。 优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。 生成阶段：将最终的AST转化为render函数字符串。  35. 对SSR的理解 SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端\nSSR的优势：\n 更好的SEO 首屏加载速度更快  SSR的缺点：\n 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子； 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境； 更多的服务端负载。  36. Vue的性能优化有哪些 （1）编码阶段\n 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 如果需要使用v-for给每项元素绑定事件时使用事件代理 SPA 页面采用keep-alive缓存组件 在更多的情况下，使用v-if替代v-show key保证唯一 使用路由懒加载、异步组件 防抖、节流 第三方模块按需导入 长列表滚动到可视区域动态加载 图片懒加载  （2）SEO优化\n 预渲染 服务端渲染SSR  （3）打包优化\n 压缩代码 Tree Shaking/Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化  （4）用户体验\n 骨架屏 PWA 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。  37. 对 SPA 单页面的理解，它的优缺点分别是什么？ SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n优点：\n 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；  缺点：\n 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。  38. template和jsx的有什么分别？ 对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。\n所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。\n39. vue初始化页面闪动问题 使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。\n首先：在css里加上以下代码：\n1 2 3  [v-cloak] { display: none; }   如果没有彻底解决问题，则在根元素加上style=\u0026quot;display: none;\u0026quot; :style=\u0026quot;{display: 'block'}\u0026quot;\n40. extend 有什么作用 这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 创建组件构造器 let Component = Vue.extend({ template: \u0026#39;\u0026lt;div\u0026gt;test\u0026lt;/div\u0026gt;\u0026#39; }) // 挂载到 #app 上 new Component().$mount(\u0026#39;#app\u0026#39;) // 除了上面的方式，还可以用来扩展已有的组件 let SuperComponent = Vue.extend(Component) new SuperComponent({ created() { console.log(1) } }) new SuperComponent().$mount(\u0026#39;#app\u0026#39;)   41. mixin 和 mixins 区别 mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。\n1 2 3 4 5 6  Vue.mixin({ beforeCreate() { // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 } })   虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。\nmixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。\n另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。\n42. MVVM的优缺点**?** 优点:\n 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的\u0026quot;View\u0026quot;上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放  缺点:\n Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。  43. Vue.use的实现原理 先贴源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // src/core/global-api/use.js import { toArray } from \u0026#39;../util/index\u0026#39; export function initUse (Vue: GlobalAPI) { Vue.use = function (plugin: Function | Object) { const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) \u0026gt; -1) { return this } // additional parameters  const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === \u0026#39;function\u0026#39;) { plugin.install.apply(plugin, args) } else if (typeof plugin === \u0026#39;function\u0026#39;) { plugin.apply(null, args) } installedPlugins.push(plugin) return this } }   可以看到，use源码部分其实不长\nVue.use()，传入一个function或object，首先会检查这个插件是否已经存在，如果存在则直接返回\ntoArray方法，将类数组转化成数组，1是指从第一个参数开始，比如\n1 2  Vue.use(globalPlugin, 1, 2, 3) // args = [1,2,3]   检查入参plugin的install属性是否为function，如果是，则通过apply调用plugin.install，此时plugin为object\n如果不是，则检查入参plugin是否为function，如果是，则通过apply调用plugin\n最后把入参plugin存到数组installedPlugins，用于检查插件是否存在\n举个栗子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // globalPlugin.js // 以下为我随手写的假代码，不一定能运行，但思路是对的 import ElementUI from \u0026#39;element-ui\u0026#39; export default (app) =\u0026gt; { useElement(app) useConfig(app) useToast(app) } /** 对象写法 export default { install(app): { useElement(app) useConfig(app) useToast(app) } } */ // 注册ElementUI const useElement = (app) =\u0026gt; { app.use(ElementUI) } // 注册全局配置 const useConfig = (app) =\u0026gt; { app.config.name = \u0026#39;xxx\u0026#39; app.config.age = 18 } // 注册自己写的toast方法 const useToast = (app) =\u0026gt; { app.$toast = () =\u0026gt; { // 自己写的toast方法  } }   1 2 3 4 5 6  // main.js import Vue from \u0026#39;vue\u0026#39; import globalPlugin from \u0026#39;./globalPlugin\u0026#39;\t// 就是上面这个js  const vm = new Vue() vm.use(globalPlugin)\t// 执行自定义插件   根据以上demo，可以得出，通过use\n 注册全局配置属性 注册全局引用方法  二、生命周期 1. 说一下Vue的生命周期 Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -\u0026gt; 渲染、更新 -\u0026gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。\n beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。 created**（创建后）** ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。 beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。 beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 updated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。 destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。  另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n2. Vue 子组件和父组件执行顺序 加载渲染过程：\n1.父组件 beforeCreate\n2.父组件 created\n3.父组件 beforeMount\n4.子组件 beforeCreate\n5.子组件 created\n6.子组件 beforeMount\n7.子组件 mounted\n8.父组件 mounted\n更新过程：\n\\1. 父组件 beforeUpdate\n2.子组件 beforeUpdate\n3.子组件 updated\n4.父组件 updated\n销毁过程：\n\\1. 父组件 beforeDestroy\n2.子组件 beforeDestroy\n3.子组件 destroyed\n4.父组件 destoryed\n3. created和mounted的区别  created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。  4. 一般在哪个生命周期请求异步数据 我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n 能更快获取到服务端数据，减少页面加载时间，用户体验更好； SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。  5. keep-alive 中的生命周期哪些 keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。\n三、组件通信 组件通信的方式如下：\n（1） props / $emit 父组件通过props向子组件传递数据，子组件通过$emit和父组件通信\n1. 父组件向子组件传值  props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。 props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。 props属性名规则：若在props中使用驼峰形式，模板中需要使用短横线的形式  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 父组件 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;son :msg=\u0026#34;msgData\u0026#34; :fn=\u0026#34;myFunction\u0026#34;\u0026gt;\u0026lt;/son\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import son from \u0026#34;./son.vue\u0026#34;; export default { name: father, data() { msgData: \u0026#34;父组件数据\u0026#34;; }, methods: { myFunction() { console.log(\u0026#34;vue\u0026#34;); } }, components: { son } }; \u0026lt;/script\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13  // 子组件 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;fn\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;son\u0026#34;, props: [\u0026#34;msg\u0026#34;, \u0026#34;fn\u0026#34;] }; \u0026lt;/script\u0026gt;   2. 子组件向父组件传值  $emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过v-on监听并接收参数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 父组件 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;com-article :articles=\u0026#34;articleList\u0026#34; @onEmitIndex=\u0026#34;onEmitIndex\u0026#34;\u0026gt;\u0026lt;/com-article\u0026gt; \u0026lt;p\u0026gt;{{currentIndex}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import comArticle from \u0026#39;./test/article.vue\u0026#39; export default { name: \u0026#39;comArticle\u0026#39;, components: { comArticle }, data() { return { currentIndex: -1, articleList: [\u0026#39;红楼梦\u0026#39;, \u0026#39;西游记\u0026#39;, \u0026#39;三国演义\u0026#39;] } }, methods: { onEmitIndex(idx) { this.currentIndex = idx } } } \u0026lt;/script\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 父组件 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;com-article :articles=\u0026#34;articleList\u0026#34; @onEmitIndex=\u0026#34;onEmitIndex\u0026#34;\u0026gt;\u0026lt;/com-article\u0026gt; \u0026lt;p\u0026gt;{{currentIndex}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import comArticle from \u0026#39;./test/article.vue\u0026#39; export default { name: \u0026#39;comArticle\u0026#39;, components: { comArticle }, data() { return { currentIndex: -1, articleList: [\u0026#39;红楼梦\u0026#39;, \u0026#39;西游记\u0026#39;, \u0026#39;三国演义\u0026#39;] } }, methods: { onEmitIndex(idx) { this.currentIndex = idx } } } \u0026lt;/script\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div v-for=\u0026#34;(item, index) in articles\u0026#34; :key=\u0026#34;index\u0026#34; @click=\u0026#34;emitIndex(index)\u0026#34;\u0026gt;{{item}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;articles\u0026#39;], methods: { emitIndex(index) { this.$emit(\u0026#39;onEmitIndex\u0026#39;, index) // 触发父组件的方法，并传递参数index } } } \u0026lt;/script\u0026gt;   （2）eventBus事件总线（$emit / $on） eventBus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下：\n（1）创建事件中心管理组件之间的通信\n1 2 3 4  // event-bus.js import Vue from \u0026#39;vue\u0026#39; export const EventBus = new Vue()   （2）发送事件\n假设有两个兄弟组件firstCom和secondCom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;first-com\u0026gt;\u0026lt;/first-com\u0026gt; \u0026lt;second-com\u0026gt;\u0026lt;/second-com\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import firstCom from \u0026#39;./firstCom.vue\u0026#39; import secondCom from \u0026#39;./secondCom.vue\u0026#39; export default { components: { firstCom, secondCom } } \u0026lt;/script\u0026gt;   在firstCom组件中发送事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;加法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {EventBus} from \u0026#39;./event-bus.js\u0026#39; // 引入事件中心 export default { data(){ return{ num:0 } }, methods:{ add(){ EventBus.$emit(\u0026#39;addition\u0026#39;, { num:this.num++ }) } } } \u0026lt;/script\u0026gt;   （3）接收事件\n在secondCom组件中发送事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;求和: {{count}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { EventBus } from \u0026#39;./event-bus.js\u0026#39; export default { data() { return { count: 0 } }, mounted() { EventBus.$on(\u0026#39;addition\u0026#39;, param =\u0026gt; { this.count = this.count + param.num; }) } } \u0026lt;/script\u0026gt;   在上述代码中，这就相当于将num值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不同组件通过它来通信。\n虽然看起来比较简单，但是这种方法也有不便之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。\n（3）依赖注入（provide / inject） 这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。\nprovide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。\n provide 钩子用来发送数据或方法 inject钩子用来接收数据或方法  在父组件中：\n1 2 3 4 5  provide() { return { num: this.num }; }   在子组件中：\n1  inject: [\u0026#39;num\u0026#39;]   还可以这样写，这样写就可以访问父组件中的所有属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13  provide() { return { app: this }; } data() { return { num: 1 }; } inject: [\u0026#39;app\u0026#39;] console.log(this.app.num)   注意： 依赖注入所提供的属性是非响应式的。\n（3）ref / $refs 这种方式也是实现父子组件之间的通信。\nref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。\n在子组件中：\n1 2 3 4 5 6 7 8 9 10 11 12  export default { data () { return { name: \u0026#39;JavaScript\u0026#39; } }, methods: { sayHello () { console.log(\u0026#39;hello\u0026#39;) } } }   在父组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;template\u0026gt; \u0026lt;child ref=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/component-a\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import child from \u0026#39;./child.vue\u0026#39; export default { components: { child }, mounted () { console.log(this.$refs.child.name); // JavaScript this.$refs.child.sayHello(); // hello } } \u0026lt;/script\u0026gt;   （4）$parent / $children  使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法） 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。  在子组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{{message}}\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;获取父组件的值为: {{parentVal}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: \u0026#39;Vue\u0026#39; } }, computed:{ parentVal(){ return this.$parent.msg; } } } \u0026lt;/script\u0026gt;   在父组件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 父组件中 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello_world\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{msg}}\u0026lt;/div\u0026gt; \u0026lt;child\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;点击改变子组件值\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import child from \u0026#39;./child.vue\u0026#39; export default { components: { child }, data() { return { msg: \u0026#39;Welcome\u0026#39; } }, methods: { change() { // 获取到子组件 this.$children[0].message = \u0026#39;JavaScript\u0026#39; } } } \u0026lt;/script\u0026gt;   在上面的代码中，子组件获取到了父组件的parentVal值，父组件改变了子组件中message的值。\n需要注意：\n 通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例 在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的 在根组件#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组 $children 的值是数组，而$parent是个对象  （5）$attrs / $listeners。 考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？\n如果是用props/$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。\n针对上述情况，Vue引入了$attrs / $listeners，实现组件之间的跨代通信。\n先来看一下inheritAttrs，它的默认值true，继承所有的父组件属性除props之外的所有属性；inheritAttrs：false 只继承class属性 。\n $attrs：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上 $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on=\u0026quot;$listeners\u0026quot; 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）  A组件（APP.vue）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; //此处监听了两个事件，可以在B组件或者C组件中直接触发 \u0026lt;child1 :p-child1=\u0026#34;child1\u0026#34; :p-child2=\u0026#34;child2\u0026#34; @test1=\u0026#34;onTest1\u0026#34; @test2=\u0026#34;onTest2\u0026#34;\u0026gt;\u0026lt;/child1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Child1 from \u0026#39;./Child1.vue\u0026#39;; export default { components: { Child1 }, methods: { onTest1() { console.log(\u0026#39;test1 running\u0026#39;); }, onTest2() { console.log(\u0026#39;test2 running\u0026#39;); } } }; \u0026lt;/script\u0026gt;   B组件（Child1.vue）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child-1\u0026#34;\u0026gt; \u0026lt;p\u0026gt;props: {{pChild1}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;$attrs: {{$attrs}}\u0026lt;/p\u0026gt; \u0026lt;child2 v-bind=\u0026#34;$attrs\u0026#34; v-on=\u0026#34;$listeners\u0026#34;\u0026gt;\u0026lt;/child2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Child2 from \u0026#39;./Child2.vue\u0026#39;; export default { props: [\u0026#39;pChild1\u0026#39;], components: { Child2 }, inheritAttrs: false, mounted() { this.$emit(\u0026#39;test1\u0026#39;); // 触发APP.vue中的test1方法 } }; \u0026lt;/script\u0026gt;   C 组件 (Child2.vue)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child-2\u0026#34;\u0026gt; \u0026lt;p\u0026gt;props: {{pChild2}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;$attrs: {{$attrs}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;pChild2\u0026#39;], inheritAttrs: false, mounted() { this.$emit(\u0026#39;test2\u0026#39;);// 触发APP.vue中的test2方法 } }; \u0026lt;/script\u0026gt;   在上述代码中：\n C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 在B组件中通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）  （6）总结 （1）父子组件间通信\n 子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。 通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。 使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。  （2）兄弟组件间通信\n 使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。 通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。  （3）任意组件之间\n 使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。  如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。\n四、路由 1. Vue-Router 的懒加载如何实现 非懒加载：\n1 2 3 4 5 6  import List from \u0026#39;@/components/list.vue\u0026#39; const router = new VueRouter({ routes: [ { path: \u0026#39;/list\u0026#39;, component: List } ] })   （1）方案一(常用)：使用箭头函数+import动态加载\n1 2 3 4 5 6  const List = () =\u0026gt; import(\u0026#39;@/components/list.vue\u0026#39;) const router = new VueRouter({ routes: [ { path: \u0026#39;/list\u0026#39;, component: List } ] })   （2）方案二：使用箭头函数+require动态加载\n1 2 3 4 5 6 7 8  const router = new Router({ routes: [ { path: \u0026#39;/list\u0026#39;, component: resolve =\u0026gt; require([\u0026#39;@/components/list\u0026#39;], resolve) } ] })   （3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。\n1 2 3 4 5 6 7 8 9 10 11 12  // r就是resolve const List = r =\u0026gt; require.ensure([], () =\u0026gt; r(require(\u0026#39;@/components/list\u0026#39;)), \u0026#39;list\u0026#39;); // 路由也是正常的写法 这种是官方推荐的写的 按模块划分懒加载 const router = new Router({ routes: [ { path: \u0026#39;/list\u0026#39;, component: List, name: \u0026#39;list\u0026#39; } ] }))   2. 路由的hash和history模式的区别 Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。\n1. hash模式 简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。\n特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。\n原理： hash模式的主要原理就是onhashchange()事件：\n1 2 3 4  window.onhashchange = function(event){ console.log(event.oldURL, event.newURL); let hash = location.hash.slice(1); }   使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。\n2. history模式 简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。\n特点： 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。\nAPI： history api可以分为两大部分，切换历史状态和修改历史状态：\n 修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。 切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。  虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。\n如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：\n1 2 3 4  const router = new VueRouter({ mode: \u0026#39;history\u0026#39;, routes: [...] })   3. 两种模式对比 调用 history.pushState() 相比于直接修改 hash，存在以下优势:\n pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL； pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中； pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串； pushState() 可额外设置 title 属性供后续使用。 hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。  hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。\n3. 如何获取页面的hash变化 （1）监听$route的变化\n1 2 3 4 5 6 7 8 9 10  // 监听,当路由发生变化的时候执行 watch: { $route: { handler: function(val, oldVal){ console.log(val); }, // 深度观察监听 deep: true } },   （2）window.location.hash读取#值\nwindow.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。\n4. $route 和$router 的区别  $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。  5. 如何定义动态路由？如何获取传过来的动态参数？ （1）param方式\n 配置路由格式：/router/:id 传递的方式：在path后面跟上对应的值 传递后形成的路径：/router/123  1）路由定义\n1 2 3 4 5 6 7 8  //在APP.vue中 \u0026lt;router-link :to=\u0026#34;\u0026#39;/user/\u0026#39;+userId\u0026#34; replace\u0026gt;用户\u0026lt;/router-link\u0026gt; //在index.js { path: \u0026#39;/user/:userid\u0026#39;, component: User, },   2）路由跳转\n1 2 3 4 5 6 7 8  // 方法1： \u0026lt;router-link :to=\u0026#34;{ name: \u0026#39;users\u0026#39;, params: { uname: wade }}\u0026#34;\u0026gt;按钮\u0026lt;/router-link // 方法2： this.$router.push({name:\u0026#39;users\u0026#39;,params:{uname:wade}}) // 方法3： this.$router.push(\u0026#39;/user/\u0026#39; + wade)   3）参数获取\n通过 $route.params.userid 获取传递的值\n（2）query方式\n 配置路由格式：/router，也就是普通配置 传递的方式：对象中使用query的key作为传递方式 传递后形成的路径：/route?id=123  1）路由定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //方式1：直接在router-link 标签上以对象的形式 \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;/profile\u0026#39;,query:{name:\u0026#39;why\u0026#39;,age:28,height:188}}\u0026#34;\u0026gt;档案\u0026lt;/router-link\u0026gt; // 方式2：写成按钮以点击事件形式 \u0026lt;button @click=\u0026#39;profileClick\u0026#39;\u0026gt;我的\u0026lt;/button\u0026gt; profileClick(){ this.$router.push({ path: \u0026#34;/profile\u0026#34;, query: { name: \u0026#34;kobi\u0026#34;, age: \u0026#34;28\u0026#34;, height: 198 } }); }   2）跳转方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 方法1： \u0026lt;router-link :to=\u0026#34;{ name: \u0026#39;users\u0026#39;, query: { uname: james }}\u0026#34;\u0026gt;按钮\u0026lt;/router-link\u0026gt; // 方法2： this.$router.push({ name: \u0026#39;users\u0026#39;, query:{ uname:james }}) // 方法3： \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/user\u0026#39;, query: { uname:james }}\u0026#34;\u0026gt;按钮\u0026lt;/router-link\u0026gt; // 方法4： this.$router.push({ path: \u0026#39;/user\u0026#39;, query:{ uname:james }}) // 方法5： this.$router.push(\u0026#39;/user?uname=\u0026#39; + jsmes)   3）获取参数\n1  通过$route.query 获取传递的值   注意\n​\t跳转时使用对象形式：path不能和params参数搭配，使用命名路由name可以和params或者query参数搭配\n6. Vue-router 路由钩子在生命周期的体现 一、Vue-Router导航守卫\n有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。\n为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的\n 全局路由钩子  vue-router全局有三个路由钩子;\n router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用 router.afterEach 全局后置钩子 进入路由之后  具体使用∶\n beforeEach（判断是否登录了，没登录就跳转到登录页）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  router.beforeEach((to, from, next) =\u0026gt; { let ifInfo = Vue.prototype.$common.getSession(\u0026#39;userData\u0026#39;); // 判断是否登录的存储信息 if (!ifInfo) { // sessionStorage里没有储存user信息 if (to.path == \u0026#39;/\u0026#39;) { //如果是登录页面路径，就直接next() next(); } else { //不然就跳转到登录 Message.warning(\u0026#34;请重新登录！\u0026#34;); window.location.href = Vue.prototype.$loginUrl; } } else { return next(); } })    afterEach （跳转之后滚动条回到顶部）  1 2 3 4  router.afterEach((to, from) =\u0026gt; { // 跳转之后滚动条回到顶部 window.scrollTo(0,0); });    单个路由独享钩子  beforeEnter\n如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next\n1 2 3 4 5 6 7 8 9 10 11  export default [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;login\u0026#39;, component: login, beforeEnter: (to, from, next) =\u0026gt; { console.log(\u0026#39;即将进入登录页面\u0026#39;) next() } } ]    组件内钩子  beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave\n这三个钩子都有三个参数∶to、from、next\n beforeRouteEnter∶ 进入组件前触发 beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用 beforeRouteLeave∶ 离开组件被调用  注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：\n1 2 3 4 5 6 7  beforeRouteEnter(to, from, next) { next(target =\u0026gt; { if (from.path == \u0026#39;/classProcess\u0026#39;) { target.isFromProcess = true } }) }   二、Vue路由钩子在生命周期函数的体现\n 完整的路由导航解析流程（不包括其他生命周期）   触发进入其他路由。 调用要离开路由的组件守卫beforeRouteLeave 调用局前置守卫∶ beforeEach 在重用的组件里调用 beforeRouteUpdate 调用路由独享守卫 beforeEnter。 解析异步路由组件。 在将要进入的路由组件中调用 beforeRouteEnter 调用全局解析守卫 beforeResolve 导航被确认。 调用全局后置钩子的 afterEach 钩子。 触发DOM更新（mounted）。 执行beforeRouteEnter 守卫中传给 next 的回调函数   触发钩子的完整顺序  路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶\n beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。 beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。 beforeEnter：路由独享守卫 beforeRouteEnter：路由组件的组件进入路由前钩子。 beforeResolve：路由全局解析守卫 afterEach：路由全局后置钩子 beforeCreate：组件生命周期，不能访问tAis。 created;组件生命周期，可以访问tAis，不能访问dom。 beforeMount：组件生命周期 deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。 mounted：访问/操作dom。 activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。 执行beforeRouteEnter回调函数next。   导航行为被触发到导航完成的整个过程   导航行为被触发，此时导航未被确认。 在失活的组件里调用离开守卫 beforeRouteLeave。 调用全局的 beforeEach守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnteY。 解析异步路由组件（如果有）。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。 导航被确认。 调用全局的 afterEach 钩子。 非重用组件，开始组件实例的生命周期：beforeCreate\u0026amp;created、beforeMount\u0026amp;mounted 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。 导航完成  7. Vue-router跳转和location.href有什么区别  使用 location.href= /url 来跳转，简单方便，但是刷新了页面； 使用 history.pushState( /url ) ，无刷新页面，静态跳转； 引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。  8. params和query的区别 用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。\nurl地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示\n注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。\n9. Vue-router 导航守卫有哪些  全局前置/钩子：beforeEach、beforeResolve、afterEach 路由独享的守卫：beforeEnter 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave  10. 对前端路由的理解 在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。\n后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。\nSPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：\n SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。 由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息  为了解决这个问题，前端路由出现了。\n前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。\n那么如何实现这个目的呢？首先要解决两个问题：\n 当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。 单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？  从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：\n 拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。 感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。  五、Vuex 1. Vuex 的原理 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。  Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。\n（1）核心流程中的主要功能：\n Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions; 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中; 然后 Mutations 就去改变（Mutate）State 中的数据; 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。  （2）各模块在核心流程中的主要功能：\n Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch∶操作行为触发方法，是唯一能执行action的方法。 actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。  2. Vuex中action和mutation的区别 mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n1 2 3 4 5 6 7 8 9 10  const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { state.count++ // 变更状态 } } })   当触发一个类型为 increment 的 mutation 时，需要调用此函数：\n1  store.commit(\u0026#39;increment\u0026#39;)   而Action类似于mutation，不同点在于：\n Action 可以包含任意异步操作。 Action 提交的是 mutation，而不是直接变更状态。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(\u0026#39;increment\u0026#39;) } } })   Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。\n所以，两者的不同点如下：\n Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。 Mutation：必须同步执行；Action：可以异步，但不能直接操作State。 在视图更新时，先触发actions，actions再触发mutation mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters  3. Vuex 和 localStorage 的区别 （1）最重要的区别\n vuex存储在内存中 localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快  （2）应用场景\n Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。 localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。 Vuex能做到数据的响应式，localstorage不能  （3）永久性\n刷新页面时vuex存储的值会丢失，localstorage不会。\n**注意：**对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。\n4. Redux 和 Vuex 有什么区别，它们的共同思想 （1）Redux 和 Vuex区别\n Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可 Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可 Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-\u0026gt;store改变（vue检测到数据变化自动渲染）  通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n（2）共同思想\n 单—的数据源 变化可以预测  本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;\n形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;\n5. 为什么要用 Vuex 或者 Redux 由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。\n所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的\u0026quot;视图\u0026quot;，不管在树的哪个位置，任何组件都能获取状态或者触发行为。\n另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。\n6. Vuex有哪几种属性？ 有五种，分别是 State、 Getter、Mutation 、Action、 Module\n state =\u0026gt; 基本数据(数据源存放地) getters =\u0026gt; 从基本数据派生出来的数据 mutations =\u0026gt; 提交更改数据的方法，同步 actions =\u0026gt; 像一个装饰器，包裹mutations，使之可以异步。 modules =\u0026gt; 模块化Vuex  7. Vuex和单纯的全局对象有什么区别？  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。  8. 为什么 Vuex 的 mutation 中不能做异步操作？  Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。  9. Vuex的严格模式是什么,有什么作用，如何开启？ 在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n在Vuex.Store 构造器选项中开启,如下\n1 2 3  const store = new Vuex.Store({ strict:true, })   10. 如何在组件中批量使用Vuex的getter属性 使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中\n1 2 3 4 5 6  import {mapGetters} from \u0026#39;vuex\u0026#39; export default{ computed:{ ...mapGetters([\u0026#39;total\u0026#39;,\u0026#39;discountTotal\u0026#39;]) } }   11. 如何在组件中重复使用Vuex的mutation 使用mapMutations辅助函数,在组件中这么使用\n1 2 3 4 5 6  import { mapMutations } from \u0026#39;vuex\u0026#39; methods:{ ...mapMutations({ setNumber:\u0026#39;SET_NUMBER\u0026#39;, }) }   然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)\n六、Vue 3.0 1. Vue3.0有什么更新 （1）监测机制的改变\n 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：  （2）只能监测属性，不能监测对象\n 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。  （3）模板\n 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。  （4）对象式的组件声明方式\n vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易  （5）其它方面的更改\n 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 tree shaking 优化，提供了更多的内置功能。  2. defineProperty和proxy的区别 Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。\nObject.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\n但是这样做有以下问题：\n 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。 无法监控到数组下标和长度的变化。  Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：\n Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。 Proxy 可以监听数组的变化。  3. Vue3.0 为什么要用 proxy？ 在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶\n 不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 全方位的数组变化检测，消除了Vue2 无效的边界情况。 支持 Map，Set，WeakMap 和 WeakSet。  Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶\n get 收集依赖 Set、delete 等触发依赖 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。  4. Vue 3.0 中的 Vue Composition API？ 在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：\n 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。 Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。  于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。\n如下，是一个使用了 Vue Composition API 的 Vue3 组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; Count: {{ count }} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数 import { ref, computed, onMounted } from \u0026#39;vue\u0026#39; export default { setup() { // 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数 const count = ref(0) // Vue2中需要在methods option中声明的函数，现在直接声明 function increment() { count.value++ } // 对应于Vue2中的mounted声明周期 onMounted(() =\u0026gt; console.log(\u0026#39;component mounted!\u0026#39;)) return { count, increment } } } \u0026lt;/script\u0026gt;   显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性\n5. Composition API与React Hook很像，区别是什么 从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制\n 不能在循环、条件、嵌套函数中调用Hook 必须确保总是在你的React函数的顶层调用Hook useEffect、useMemo等函数必须手动确定依赖关系  而Composition API是基于Vue的响应式系统实现的，与React Hook的相比\n 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢 Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。  虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。\n七、虚拟DOM 1. 对虚拟DOM的理解？ 从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n2. 虚拟DOM的解析过程 虚拟DOM的解析过程：\n 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。  3. 为什么要用虚拟DOM （1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n看一下页面渲染的流程：解析HTML -\u0026gt; 生成DOM -\u0026gt; 生成 CSSOM -\u0026gt; Layout -\u0026gt; Paint -\u0026gt; Compiler\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新  Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。\n（2）跨平台\nVirtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n4. 虚拟DOM真的比真实DOM性能好吗  首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。  5. DIFF算法的原理 在新老虚拟DOM对比时：\n 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除) 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。 匹配时，找到相同的子节点，递归比较子节点  在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。\n6. Vue中key的作用 vue 中 key 值的作用可以分为两种情况来考虑：\n 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。  key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速\n 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比 中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快  7. 为什么不建议用index作为key? 使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2\u0026hellip;这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。\n","permalink":"https://coderrenxy.github.io/posts/read/13-vue%E7%AF%87/","summary":"author: [\u0026ldquo;小任同学\u0026rdquo;] draft: false # 是否为草稿 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: flase # 底部不显示分享栏 showbreadcrumbs: true #顶部显示","title":"vue"},{"content":"这周进度 还不错吧，一直在动。\n英语六级 有点困难。\nredis 结束了。\nJUC 开始了 先黑马的教材，再看电子书。\n写了两天数据库作业。\n算法落下了两天，但是把桶排序搞明白了。\n操作系统复习了一些。\n下周计划  六级。 lc照常。 操作系统+数据库 继续复习。 JUC 优先级 \u0026gt; lc。  others 好好睡觉。学校的课真的好磨人好恶心。\n学习感悟 不要钻牛角尖！\n该摆就摆，能学就学！\n","permalink":"https://coderrenxy.github.io/posts/life/november.no3-weekly-summary/","summary":"这周进度 还不错吧，一直在动。 英语六级 有点困难。 redis 结束了。 JUC 开始了 先黑马的教材，再看电子书。 写了两天数据库作业。 算法落下了两天，但是把桶排序搞","title":"November.No.3 Weekly Summary"},{"content":"最近学习 计网完了，已经 redis了，LC 一直在刷，剑指刷的比 随想录勤快，毕竟剑指是新题。当没时间完成所有任务的时候，new题 \u0026gt; old题，new 知识 \u0026gt; old。 效率真的很一般，经常因为有事完不成任务，但是时长应该少不了太多。\n最近生活 该聚的聚，不想再聚了，买了个洗衣机、电动车。欠了1000了，日子难过。\n生活质量不错，睡眠充足，规律。早上吃两个鸡蛋，中午多吃肉，补充动物蛋白。\n10月 比较 9月 好点了，比刚来天天聚效率当然没话说。但是被蓝桥杯耽误了几天。\n10月任务完成了。随想录四刷了。\n11月计划 redis结束掉，比较困难。起码过一遍。\n英语六级复习。\n剑指offer 拿下。\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\nredis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：四刷 + 剑指offer（一个零十天） \u0026ndash;\u0026gt; 五刷 + hot100（两个月）\u0026ndash;\u0026gt; 算法开始 acm 模式\n","permalink":"https://coderrenxy.github.io/posts/life/10%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 计网完了，已经 redis了，LC 一直在刷，剑指刷的比 随想录勤快，毕竟剑指是新题。当没时间完成所有任务的时候，new题 \u0026gt; old题，ne","title":"10月总结"},{"content":"最近学习 已经断了两个月没更新，至于为什么没更新，原因有如下几点。\n 考英语六级 复习 准备期末考试 逐渐忘记了规划，但是事情还在做。  最近生活 一般\u0026hellip;\u0026hellip;.\n在学校疫情爆发了，还有点小刺激，下一天就好了，又焦灼的选择到底留不留校考六级。\n情绪起伏比较大.\n疫情开放，味觉没了，感冒两周没好，咳嗽，应该是🐏了。\n家人已经阳了，我也跑不了。\n不爱出去但是老出去。\n12月 比较 10月 效率低很多，虽然期末考不重要，但是这些不起眼的东西到时候可能会害了我自己，让我实习中途回来补考。\n所以我要好好准备考试（教考分离）。\nLC 没刷了，因为双非二本专升本刷这个确实性价比低。\n花了一周半做了一个外卖平台 。 redis 解决了，现在在学 JUC ，不打算精学，准备面向面试题学，但是给自己的时间是20天，学得快就把 黑马、尚硅谷（两位老师）都看一遍加深理解。\n1月计划 JUC 15号之前结束。\n开始 JVM。\n尽量一月剩下的15天结束 JVM 再深化简历再去复习。\n关于复习，能专门写一篇文章准备。\n长期计划 juc、jvm。开始复习（大概2个月）再投递。\n","permalink":"https://coderrenxy.github.io/posts/life/12%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 已经断了两个月没更新，至于为什么没更新，原因有如下几点。 考英语六级 复习 准备期末考试 逐渐忘记了规划，但是事情还在做。 最近生活 一般\u0026he","title":"12月总结"},{"content":"这周进度  每天2道以前刷过的 LC+剑指offer 2题。 完成度60%，有时候碰到难题（old/new）花很久或者摆烂了。 每天在学 计网。   计网：效率不错，思维导图做了很多。 算法：三刷LC，摆烂很少，因为上网课时间充裕。周赛日了狗，第一题写了20分钟，第二道题自己没想出来辗转相除，三四都是 hard，不干耗。  下周计划  计网最后一天时间结束，记得做笔记。 开始学习 Redis。 算法接着刷。 算法遗漏：优先队列，TreeMap、十大排序。  XXX  别想的太远。 避免信息洪流中让我有 “快进” 想法的信息。  赖酒攻略  不要空腹喝酒，喝酒前喝浓酸奶。 吃肥肉。 不小心弄掉东西，蹲下去捡 吐掉酒。 多喝水，上厕所排出酒精，喝到还剩一点就喝白酒的时候往里面吐。 手里攥卫生纸，吐在卫生纸里。 开始难受就 装吐，不然酒醒了痛的是自己。  ","permalink":"https://coderrenxy.github.io/posts/life/october.no3-weekly-summary/","summary":"这周进度 每天2道以前刷过的 LC+剑指offer 2题。 完成度60%，有时候碰到难题（old/new）花很久或者摆烂了。 每天在学 计网。 计网：效率","title":"October.No3 Weekly Summary"},{"content":"这周进度  每天2道以前刷过的 LC+剑指offer 2题。 每天在学 刷题 + 计网。   计网：效率不错，开始消化了。 算法：三刷LC，有1天摆烂，另外一天因为前缀和一道题目一直在思考，没有进度。 赖了上周的一篇总结。  下周计划  计网继续啃，做笔记。 算法接着刷。 优先队列，TreeMap，还有十大排序。慢慢来。  ","permalink":"https://coderrenxy.github.io/posts/life/october.no2-weekly-summary/","summary":"这周进度 每天2道以前刷过的 LC+剑指offer 2题。 每天在学 刷题 + 计网。 计网：效率不错，开始消化了。 算法：三刷LC，有1天摆烂，另外一天因为","title":"October.No2 Weekly Summary"},{"content":"最近学习 效率可想而知的烂，开学的第一个月，课程、新朋友、小聚、过节。\n代码随想录二刷完成，但是在推进 剑指offer+代码随想录 时碰到很多困难，难坚持，编码环境的细微差别就不好适应，更别说以后的 acm模式编码，只能硬着头皮冲。\n计网二刷意料之内的未完成，毕竟内容多、抽象、杂。\n最近生活 间断式熬夜，但是整体睡眠比以前要好很多，每天都在8小时以上的睡眠时间，其它都很麻木，一下认识这么多新的人，一个月恍如隔世。新鲜感拉满，让平衡反复摇摆。\n想让自己一切都不过度，开心、难过、兴奋、沮丧 都把握在可掌握的度，因为一切的过度都会引起反噬。\n9月 比较 8月 从家到学校，从一个牢房到另一个牢房，明显这个复杂的牢房效率很低。\n9月计划 计网 二刷 过完 + 代码随想录三刷过半 + 剑指offer过半，（2 old + 1/2 new）模式。\n是1还是2看题目难度，第一题easy就必须要做第二题，每天要保证在算法上有深度思考。\n计网5-10天结束，开始\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\n计网 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 + 剑指offer（一个半月） \u0026ndash;\u0026gt; 四刷 + hot100（两个月）\u0026ndash;\u0026gt; 算法开始 acm 模式\n","permalink":"https://coderrenxy.github.io/posts/life/9%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 效率可想而知的烂，开学的第一个月，课程、新朋友、小聚、过节。 代码随想录二刷完成，但是在推进 剑指offer+代码随想录 时碰到很多困难，","title":"9月总结"},{"content":"这周进度 效率还是一样，shit 常态，天天为了“上课”忙的跟筛子一样，摆了两天，虽然非自愿，但是以结果导向来看，必须遏止。\n想尽办法杜绝，周六也在忙学习，7点就起了(周五9点多就睡了)，周六相当难受，动态规划最后的几道题，让人想哭，想到下周要搞几题新的动态规划就绷不住了，还有单调栈，全是hard。\n计网二刷也是让我相当痛苦，明天又要出去，世界末日！！！\n下周计划  计网继续二刷。 lc照常，周赛走着。  others 现在最想做的事就是每天做的宿舍摆烂也好，学习也好。自己起码是个自由的人，自由到随意思考，随意躺平。\n必须尽快克服别人的目光，让自己在“上课”的时候能以自己最舒服的心态做自己的事情。\n关于以后我是越来越迷茫了，行业风口变来变去。这种不确定性让我很难受，但人生就是靠着不确定维系，最近看到某博主讲：精神内耗符合热力学定律，一定会有内耗这种损耗，有才代表活着，才代表能找到进步。\n既然未来很多事情不可控，那就把可控因素拿捏到最好吧，毕竟不得不承认我也就是个争做中产阶级的普通人。\n不要太在意别人看法了，上周因为别人几句话内耗了一整天，然后有的人已经说到没做到了，那么在意别人的话干什么？\n午饭后冲牙\n睡觉可以听正念催眠\n学习感悟 不要钻牛角尖！\n该摆就摆，能学就学！\n","permalink":"https://coderrenxy.github.io/posts/life/september.no4-weekly-summary/","summary":"这周进度 效率还是一样，shit 常态，天天为了“上课”忙的跟筛子一样，摆了两天，虽然非自愿，但是以结果导向来看，必须遏止。 想尽办法杜绝，周六也","title":"September.No4 Weekly Summary"},{"content":"这周进度 效率跟 shit 一样，上课，课程质量就不描述了，非得走个形式，一天的闲情、精力、时间全都被这套形式组合拳磨灭了，非常 down ，救命吧。\n只想有自己的时间，就算无聊到反复喝水也算不上折磨，就算被计网lc按在地上摩擦也比时间剥夺强一万倍。鬼天气\n下周计划  计网二刷。 lc照常，周赛走着。  长远 越发感觉互联网这条路不能一条路走到黑了，但是现在改变方向未必是及时止损。\n先找到工作，再边工作边提升技术，这样保证自己不淘汰，薪资也在涨，攒点钱。\n30之前存好一笔钱边工作边考公，这时候技术差不多成熟了，空出大部分时间备考江西省直。\n其它城市买不起房，性价比当然高，工资也高，但是考虑家人的低于归属感还是留在江西比较好。\n考研估计是明日黄花了，缩招+就业形势疯狂下滑。三年前的本科生还能找到不错的工作，现在读完研反而找不到了。\n学习感悟 学不下去的时候很容易拧巴，为啥学不进去，然后又去学，反复焦虑，形成一个圈，破这个 circle 就是索性不学，直接摆烂，好听一点就是让自己 at ease。只要 at ease，身体处于舒适状态，看什么都容易思考，静得下来并且愿意慢慢咀嚼。\n到学校14天，完全没感觉到，因为这14天心理历程波动比前两个月明显多了，两个月学下来心理波动不大，两个月如一日，痛苦一下嗖的过去了，是没那么难受，但是会少很多感悟，毕竟做人，不就是 get various feelings 吗?\nno matter that ，anything is my choice，is my way on my life，just like me，accept change and challenge.\nlast but not least, just do it !!!\n","permalink":"https://coderrenxy.github.io/posts/life/september.no3-weekly-summary/","summary":"这周进度 效率跟 shit 一样，上课，课程质量就不描述了，非得走个形式，一天的闲情、精力、时间全都被这套形式组合拳磨灭了，非常 down ，救命吧。 只想有自己的","title":"September.No3 Weekly Summary"},{"content":"这周进度  每天3道以前刷过的 LC。 每天在学 刷题 + 计网。   计网：效率很差，文章太硬核。 算法：二刷LC，周赛 ac两题，刷题一天3题。中秋节没刷，有一天摆烂。  下周计划  计网改变策略，太硬核了，搜常见面经针对性突破。 算法接着刷。 算法多重背包、前缀和、TreeMap、优先队列 ，任重道远。  ","permalink":"https://coderrenxy.github.io/posts/life/september.no2-weekly-summary/","summary":"这周进度 每天3道以前刷过的 LC。 每天在学 刷题 + 计网。 计网：效率很差，文章太硬核。 算法：二刷LC，周赛 ac两题，刷题一天3题。中秋节没刷，有一","title":"September.No2 Weekly Summary"},{"content":"这周进度  每天3道以前刷过的 LC。 每天在学 刷题 + 操作系统。   操作系统：二三遍操作系统过去了，第一遍就很烂，第二篇不错，但是到后面几篇文章着实看不懂。 算法：二刷LC，周末打周赛，一天3题，开学前完成二刷没做到。  下周计划  计网一天2-3篇文章。 算法接着刷。 开学一堆破事。  ","permalink":"https://coderrenxy.github.io/posts/life/september.no1-weekly-summary/","summary":"这周进度 每天3道以前刷过的 LC。 每天在学 刷题 + 操作系统。 操作系统：二三遍操作系统过去了，第一遍就很烂，第二篇不错，但是到后面几篇文章着实看不","title":"September.No1 Weekly Summary"},{"content":"前置知识填充篇：\n满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。\n完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。\n二叉搜索树：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。\n平衡二叉树（AVL）：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。\n二叉树的存储：\n二叉树可以链式存储，也可以顺序存储。\n链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历：\n 深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。 广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）  144.二叉树的前序遍历 \u0026amp; 145.二叉树的后序遍历 \u0026amp; 94.二叉树的中序遍历 递归做法：三个遍历一个方法代码挪一下位置。\n迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。\n注意：\n 迭代中序是复杂点，不断地往左推，到最左再依次弹出，弹出要注意父节点的 right 有没有，就这条思路。 后序 不是 直接 前序 倒转，而是把 前序 的左右孩子入栈顺序倒转再 反转。 前序：中左右。 后序：左右中。前序调转入栈顺序：中右左，反转：左右中=后序。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution {//中序遍历  public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); if(root == null) return list; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()){ if(cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); list.add(cur.val); cur = cur.right; } } return list; } }   102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。\n是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n二刷思路：用 deep 和 list 的 size 来判断是否需要 new 新的 listSon。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { list = new ArrayList\u0026lt;\u0026gt;(); bfs(root,0); return list; } public void bfs(TreeNode root,int deep){ if(root == null) return; deep++; if(list.size() \u0026lt; deep){ List\u0026lt;Integer\u0026gt; item = new ArrayList\u0026lt;\u0026gt;(); list.add(item); } list.get(deep-1).add(root.val); bfs(root.left,deep); bfs(root.right,deep); } }   迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n二刷思路：把 root 放进去队列，poll 出来 add(val)，然后放入左右孩子，poll 出来 add(val)。一层孩子 new 一个 list，而结束条件是 !queue.isEmpty() ，控制层层分离的则是 最初操作的 queue.size() 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); if(root == null) return list; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); TreeNode temp = null; while(!queue.isEmpty()){ List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); int len = queue.size(); while(len \u0026gt; 0){ temp = queue.poll(); listSon.add(temp.val); if(temp.left != null) queue.offer(temp.left); if(temp.right != null) queue.offer(temp.right); len--; } list.add(listSon); } return list; } }   107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n//需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg\u0026hellip;..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..\n226.翻转二叉树 递归：确定参数类型、返回值 —\u0026gt; 确定终止条件 —\u0026gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026amp;\u0026amp;。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n二刷：实在没想到思路，竟然是这样。递归一个求深度方法；\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n二刷：主要就是用左右孩子为空当作依据来操作，先去 List 出来 path ，再去操作字符串，不然append(root.left.val).append(”→”) 这样很难回溯。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 ”左闭右开“ 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n二刷构建树 前序：[root,root.left,root.right]\n中序：[root.left,root,root.right]\n后序：[root.left,root.right,root]\n前序遍历的第一个，后序遍历的最后一个元素就是树的根节点，根据这根节点可以在 中序遍历 中找到 val 相同的节点，也就是这棵树的根节点，这个节点的左边就是左子树的所有节点，右边就是右子树的所有结点。这样我们知道了左右子树各自的节点个数。根据前序数组，root,左子树所有节点，右子树所有节点，可以拿到左子树的所有节点的前序遍历、右子树所有节点的后序遍历，继续递归。后序遍历同理。结束条件是中序 left \u0026gt; right,left == right 时 new这个节点。\n654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if \u0026hellip; else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left \u0026gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\n二刷：类似建树，比建树简单多了。\n617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略\u0026hellip;\u0026hellip;\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子\u0026hellip;\u0026hellip;.）、右子树的最左后代是值最接近根节点的结点。\n二刷：左子树最右子节点的递归方法，右子树最左子节点的递归方法。\n501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List\u0026lt;TreeNode\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;TreeNode\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; i\u0026lt;list1.size(); i++){ for(int j=0; j\u0026lt;list2.size(); j++){ if(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List\u0026lt;TreeNode\u0026gt; list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026amp;\u0026amp; right != null) return root; if(left != null \u0026amp;\u0026amp; right == null) return left; if(left == null \u0026amp;\u0026amp; right != null) return right; return null; } }   二刷：从root向下找如果找到了p||q就return，否则就向下遍历，递归到了最深处还没找到返回值就是null，把左边找到的值用 left 传递，没找到就是 null 返回，然后做判断，左右孩子都是null就返回null，找到 p、q 任意一个都返回，也就是 left、right 会层层传递，左右孩子都不为空就返回 root。\n235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val \u0026gt; p.val \u0026amp;\u0026amp; root.val \u0026gt; q.val) return lowestCommonAncestor(root.left , p, q); if(root.val \u0026lt; p.val \u0026amp;\u0026amp; root.val \u0026lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val \u0026gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 \u0026gt; \\ \u0026lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。\n1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val \u0026gt; root.val) root.right = insertIntoBST(root.right, val); if(val \u0026lt; root.val) root.left = insertIntoBST(root.left , val); return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点左右孩子都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val \u0026gt; key) root.left = deleteNode1(root.left , key); if(root.val \u0026lt; key) root.right = deleteNode1(root.right, key); if(root.val == key){ if(root.right != null \u0026amp;\u0026amp; root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026amp;\u0026amp; root.left == null){ return root.right; }else if(root.right == null \u0026amp;\u0026amp; root.left != null){ return root.left; }else{ return null; } } return root; } }   二刷：root.right 节点当作新的 root，root.left 变成 root.right 的最左节点的孩子\n注意：用 root.left = 递归(root.left , key) 的方式，来传递，这样才能把 key 对应的 node 删除并且 让 node 的父节点去链接 noder.right 节点。找右孩子的最左祖孙时可以 while 循环来找。\n669. 修剪二叉搜索树 思路：分别处理不正常结点，正常的节点。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null) return null; //处理不正常的节点  if(root.val \u0026lt; low) return trimBST(root.right, low, high); if(root.val \u0026gt; high) return trimBST(root.left , low, high); //处理正常节点  root.left = trimBST(root.left , low, high); root.right = trimBST(root.right, low, high); return root; } }   108.将有序数组转换为二叉搜索树 思路：分别递归左右区间\n注意：\n 左右开闭一定要统一起来，我都是都闭着。 左右区间去递归一个方法。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public TreeNode sortedArrayToBST(int[] nums) { return method1(nums, 0, nums.length-1); } public TreeNode method1(int[] nums,int left,int right){ if(left \u0026gt; right) return null; if(left == right) return new TreeNode(nums[left]); int mid = left + (right-left)/2; TreeNode root = new TreeNode(nums[mid]); root.left = method1(nums, left, mid-1); root.right = method1(nums, mid+1, right); return root; } }   538.把二叉搜索树转换为累加树 思路：这道题最难的就是看懂题，如果换成数组看就比较好看出来，从右下角的 right 到 root 到 left。相当于就是一个反转了的中序 dfs。\n二刷：最难的是题意，注意，变化后左子树也变成了左孩子大于右孩子，已经不是二叉搜索树了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { dfs(root); return root; } public void dfs(TreeNode root){ if(root == null) return ; dfs(root.right); sum+=root.val; root.val = sum; dfs(root.left); } }   持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/","summary":"前置知识填充篇： 满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。 完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层","title":"LeetCode 二叉树(二)"},{"content":"232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内元素全 pop 到出栈的栈中。\n注意：想清楚为什么 pop、peek stackIn要判空 Out 栈？因为什么？自己手动模拟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); stackOut = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { stackIn.push(x); } public int pop() { outputIsNull(); return stackOut.pop(); } public int peek() { outputIsNull(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } public void outputIsNull(){ if(!stackOut.isEmpty()) return; while(!stackIn.isEmpty()) stackOut.push(stackIn.pop()); } }   225. 用队列实现栈 思路：挪到其中一个队列只剩一个元素再操作。\n注意：API ：poll 相当于 pop、offer 相当于 push、其他不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class MyStack { Queue\u0026lt;Integer\u0026gt; queueIn; Queue\u0026lt;Integer\u0026gt; queueOut; public MyStack() { queueIn = new LinkedList\u0026lt;\u0026gt;(); queueOut = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { queueIn.offer(x); } public int pop() { while(queueIn.size() \u0026gt; 1) queueOut.offer(queueIn.poll()); Queue\u0026lt;Integer\u0026gt; temp = queueIn; queueIn = queueOut; queueOut = temp; return queueOut.poll(); } public int top() { while(queueIn.size() \u0026gt; 1) queueOut.offer(queueIn.poll()); int num = queueIn.peek(); queueOut.offer(queueIn.poll()); Queue\u0026lt;Integer\u0026gt; temp = queueIn; queueIn = queueOut; queueOut = temp; return num; } public boolean empty() { return queueIn.isEmpty() \u0026amp;\u0026amp; queueOut.isEmpty(); } }   20. 有效的括号 思路：遇见左括号就 push 右括号，否则就看栈是否提前空了、栈顶元素匹配当前括号，否则就 pop。\n栈提前空了会导致后面就算有没匹配上的括号，最后 return 的依然是 true 。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(char ch : s.toCharArray()){ if(ch == \u0026#39;(\u0026#39;) stack.push(\u0026#39;)\u0026#39;); else if(ch == \u0026#39;{\u0026#39;) stack.push(\u0026#39;}\u0026#39;); else if(ch == \u0026#39;[\u0026#39;) stack.push(\u0026#39;]\u0026#39;); else if(stack.isEmpty() || ch != stack.pop()) return false;//判空是为了防止pop异常，也可以说是为了最后数量不匹配。  } if(!stack.isEmpty()) return false; return true; } }   1047. 删除字符串中的所有相邻重复项 思路：不用栈也行，直接 sb 的最后一个字符去匹配。\nTips：StringBuilder的删除是 deleteCharAt(int index)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public String removeDuplicates(String s) { StringBuilder sb = new StringBuilder(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;s.length();i++){ if(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==s.charAt(i)){ sb.deleteCharAt(sb.length()-1); stack.pop(); } else{ sb.append(s.charAt(i)); stack.push(s.charAt(i)); } } return new String(sb); } }   150. 逆波兰表达式求值 Tips：与本题无关：数字（int）转字符（char）要强转( char ) ( 0 + ’ 0 ’ )，字符转数字隐式就可以了不用声明出来 ‘ 2 ’ - ’ 0 ’ ，但是为了书写统一，还是都强转一下。\nAPI：Integer.valueOf( str );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; tokens.length; i++){ if(tokens[i].equals(\u0026#34;+\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b+a); }else if(tokens[i].equals(\u0026#34;-\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b-a); }else if(tokens[i].equals(\u0026#34;*\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b*a); }else if(tokens[i].equals(\u0026#34;/\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b/a); }else stack.push(Integer.valueOf(tokens[i])); } return stack.pop(); } }   239. 滑动窗口最大值 思路：自己用双端队列实现一个队列，add 方法来保证单调（队头始终为最大值），poll 方法保证窗口的滑动。每次取队头给记录窗口最大值的数组赋值就行了。如何设计 add 、poll ？\nadd：一直比较队尾，如果小于要 add 的 val，就杀掉这个队尾，直到上一个元素大于 val，此时 add 这个 val。\npoll：拿到 ”窗口最后一个值” 与 队头（最大值）去比较，如果相等，就杀死队头，因为这个本该从滑动窗口走出的元素影响最大值的判断了。否则就不操作。\n注意：\nDeque 双端队列才可以取队尾（getLast（ ）、removeLast（ ）），Queue 单端队列不可以。\nDeque 双端队列中，add（）才是在队尾添加元素。\npeek、poll 必须保证队列不为空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(nums ==null || nums.length == 0 || nums.length == 1 || k == 1) return nums; int q = 0, max; int [] res = new int[nums.length-k+1]; MyQueue deque = new MyQueue(); //填充前k个  for(int i = 0; i \u0026lt; k; i++) deque.add(nums[i]); res[q++] = deque.peek(); for(int i = k; i \u0026lt; nums.length; i++){ deque.pop(nums[i-k]); deque.add(nums[i]); res[q++] = deque.peek(); } return res; } } class MyQueue{ Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); int peek(){ return deque.peek(); } void pop(int val){ if(!deque.isEmpty() \u0026amp;\u0026amp; val == deque.peek()) deque.pop(); } void add(int val){ while(!deque.isEmpty() \u0026amp;\u0026amp; val \u0026gt; deque.getLast()) deque.removeLast(); deque.add(val); } }   347.前 K 个高频元素 暴力解法：留意语法错误、API。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public int[] topKFrequent(int[] nums, int k) { int p = 0, q = 0; int[] res = new int[k]; Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) if(map.containsKey(nums[i])) map.put(nums[i],map.get(nums[i])+1); else map.put(nums[i],1); int[] temp1 = new int[nums.length]; int[] temp2 = new int[nums.length]; for(int i : map.keySet()) temp1[p++] = i; for(int i : map.keySet()) temp2[q++] = map.get(i); for(int i=0;i\u0026lt;nums.length-1;i++){ for(int j=i+1;j\u0026lt;nums.length;j++) if(temp2[i] \u0026lt; temp2[j]){ int temp = temp2[i]; temp2[i] = temp2[j]; temp2[j] = temp; temp = temp1[i]; temp1[i] = temp1[j]; temp1[j] = temp; } } p = 0; for(int i = 0; i \u0026lt; k; i++) res[p++] = temp1[i]; return res; } }   持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E6%A0%88%E9%98%9F%E5%88%97%E4%BA%8C/","summary":"232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内","title":"LeetCode 栈、队列(二)"},{"content":"344. 反转字符串 1 2 3 4 5 6 7 8 9 10  class Solution { public void reverseString(char[] s) { char temp; for(int i=0;i\u0026lt;s.length/2;i++){ temp = s[i]; s[i] = s[s.length-1-i]; s[s.length-1-i] = temp; } } }   541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字符 .\n判断条件没有很复杂,就是拿到的个数 \u0026gt; k 就操作反转前 k 个, \u0026lt; k 直接全反转.\n就是 ≥2k 和 2k ≥ len ≥ k ,两个区间都是用一操作,融合了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0; i \u0026lt; ch.length; i+=2*k){ char temp ; int begin = i, end = Math.min(i+k-1,ch.length-1); while(begin \u0026lt; end){ temp = ch[begin]; ch[begin] = ch[end]; ch[end] = temp; begin++; end--; } } return new String(ch); } }   剑指Offer 05.替换空格 注意 : 只有 String 转换为了 StringBuffer or StringBuilder 才能用 append \u0026amp;\u0026amp; toString 方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public String replaceSpace(String s) { int count = 0,i = 0; for(char c : s.toCharArray()) if(c == \u0026#39; \u0026#39;) count++; char[] ch = new char[s.length()+2*count]; for(char c : s.toCharArray()){ if(c == \u0026#39; \u0026#39;){ ch[i++] = \u0026#39;%\u0026#39;; ch[i++] = \u0026#39;2\u0026#39;; ch[i++] = \u0026#39;0\u0026#39;; } else ch[i++] = c; } return new String(ch); } }   151. 翻转字符串里的单词 思路：先全部反转、再依次反转各个 word。\n记住几个 API ： charAt、setChatAt，操作 String 先转换成 StringBuilder or StringBuffer 再操作。\n注意要移除开头结尾的 space、word 间连续的 space。\n其中去除连续的 space 注意判断条件 当前 char != space || sb最后一个 char 不为 space（上一个 char 不为 space），两个判断条件反了会短路。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public String reverseWords(String s) { //删除开头结尾中间的空格  StringBuilder sb = removeSpace(s); reverseString(sb,0,sb.length()-1); reverseEachWord(sb); return sb.toString(); } public StringBuilder removeSpace(String s){ int left = 0, right = s.length()-1; StringBuilder sb = new StringBuilder(); while(s.charAt(left) == \u0026#39; \u0026#39;) left++; while(s.charAt(right) == \u0026#39; \u0026#39;) right--; while(right \u0026gt;= left){ if(s.charAt(left) != \u0026#39; \u0026#39; || sb.charAt(sb.length()-1) != \u0026#39; \u0026#39;) sb.append(s.charAt(left)); left++; } return sb; } public void reverseString(StringBuilder sb,int left,int right){ while(left \u0026lt; right){ char temp = sb.charAt(left); sb.setCharAt(left,sb.charAt(right)); sb.setCharAt(right,temp); left++; right--; } } public void reverseEachWord(StringBuilder sb){ int left = 0,right; while(left \u0026lt; sb.length()-1){ right = left+1; while(right != sb.length() \u0026amp;\u0026amp; sb.charAt(right) != \u0026#39; \u0026#39;)//为什么不是len-1？ 因为最后是right-1当右边界操作。并且\u0026amp;\u0026amp;先后顺序乱了就会越界。  right++; reverseString(sb,left,right-1); left = right+1; } } }   剑指Offer58-II.左旋转字符串 思路：把 n 后面的先 append 到 new 的 sb 上，再把 n 之前的 append 到 sb 。\n1 2 3 4 5 6 7 8 9 10  class Solution { public String reverseLeftWords(String s, int n) { StringBuilder sb = new StringBuilder(); for(int i=n;i\u0026lt;s.length();i++) sb.append(s.charAt(i)); for(int i=0;i\u0026lt;n;i++) sb.append(s.charAt(i)); return sb.toString(); } }   28. 实现 strStr() KMP\n459. 重复的子字符串 KMP\n持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%8C/","summary":"344. 反转字符串 1 2 3 4 5 6 7 8 9 10 class Solution { public void reverseString(char[] s) { char temp; for(int i=0;i\u0026lt;s.length/2;i++){ temp = s[i]; s[i] = s[s.length-1-i]; s[s.length-1-i] = temp; } } } 541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字","title":"LeetCode 字符串(二)"},{"content":"242.有效的字母异位词 暴力哈希：map1.put(ch,++map1.get(ch))会报错，+1就不会。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public boolean isAnagram(String s, String t) { Map\u0026lt;Character,Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character,Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); for(Character ch : s.toCharArray()){ if(map1.containsKey(ch)) map1.put(ch,map1.get(ch)+1); else map1.put(ch,1); } for(Character ch : t.toCharArray()){ if(map1.containsKey(ch)) map1.put(ch,map1.get(ch)-1); else return false; } for(Character ch : s.toCharArray()) if(map1.get(ch) != 0) return false; return true; } }   巧用数组：\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public boolean isAnagram(String s, String t) { int[] nums = new int[26]; for(char ch : s.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]++; for(char ch : t.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]--; for(int num : nums) if(num != 0) return false; return true; } }   349. 两个数组的交集 注意：set.add()、set.contains()、map.put()、map.get()、map.containsKey()。结果用 set 来放就不用来回倒腾。剪枝优化一下 length==0 || nums==null.\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set\u0026lt;Integer\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for(int i : nums1) set1.add(i); for(int i : nums2) if(set1.contains(i)) set2.add(i); return set2.stream().mapToInt(x-\u0026gt;x).toArray(); } }   202. 快乐数 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。\n所以进主函数的循环条件为 ≠1 \u0026amp;\u0026amp; !set.contains(?); 只要能进这个循环就进去拿到 nextNumber ，进到该方法里再进行拿到 各数上的平方和。\n注意：res += n % 10 * n % 10; 一定要写成 res += (n % 10) * (n % 10); 因为四则运算的优先级会先 n%10 再 *n 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public boolean isHappy(int n) { int sum = n; Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while(!set.contains(n)){ set.add(n); if(n == 1) return true; sum = 0; while(n != 0){ sum += (n%10) * (n%10); n /= 10; } n = sum; } return false; } }   1. 两数之和 暴力冒泡只要注意初始化： j=i+1即可。\n进阶版本：主要熟悉几个常用 API：map.containsKey(key)、map.get(key)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] array = new int[2]; for(int i = 0; i \u0026lt;= nums.length; i++){ if(map.containsKey(target-nums[i])){ array[0] = map.get(target-nums[i]); array[1] = i; return array; }else{ map.put(nums[i],i); } } return array; } }   454. 四数相加 II 思路：先把前两个数组之和（key），该和出现的次数value 存入map，再遍历后两个数组拿到 0-（c+d）去查map是否存在，存在 count+=value。\n注意：可能有数组传入为 null，计算值的时候默认为 0 就行，如果两个普通的 for循环嵌套，有空数组会被判断条件拦截下来，但如果用的是 foreach 就没问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int count = 0; for(int i : nums1){ for(int j : nums2){ if(map.containsKey(i+j)) map.put(i+j,map.get(i+j)+1); else map.put(i+j,1); } } for(int i : nums3){ for(int j : nums4){ if(map.containsKey(-i-j)) count += map.get(-i-j); } } return count; } }   383.赎金信 思路：长度为26的数组。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] nums = new int[26]; for(char ch : magazine.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]++; for(char ch : ransomNote.toCharArray()) if(nums[ch-\u0026#39;a\u0026#39;] == 0) return false; else nums[ch-\u0026#39;a\u0026#39;]--; return true; } }   15.三数之和 先记住两个 API：Arrays.sort(nums)、``Arrays.asList(nums[i], nums[left], nums[right])\n思路：先排个序，方便很多，测试用例里也是排序号的！再用双指针 left、right 来定位。SUM\u0026gt;0 就right—，反之 left++。\n注意：\n 如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”。 if 要匹配 else，否则进多个 if 就会导致上一条注意失效。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;nums.length;i++){ if(nums[i] \u0026gt; 0) return list;//剪枝  if(i\u0026gt;0 \u0026amp;\u0026amp; nums[i]==nums[i-1]) continue; int left = i+1,right = nums.length-1; while(left \u0026lt; right){ if(nums[i]+nums[left]+nums[right] \u0026lt; 0) left++; else if(nums[i]+nums[left]+nums[right] \u0026gt; 0) right--; else if(nums[i]+nums[left]+nums[right] == 0){ list.add(Arrays.asList(nums[i],nums[left],nums[right])); while(right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right-1]) right--; while(right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; right--; left++; } } } return list; } }   18.四数之和 思路 : 就是三数之和多了一个 for 循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length-3 ; i++){ if(nums[i]\u0026gt;0 \u0026amp;\u0026amp; nums[i] \u0026gt; target) return list;//也可能负的越来越多，第一个是正数才成立。  if(i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; for(int j = i+1; j \u0026lt; nums.length-2; j++){ if(j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) continue;//因为i和第一个j一定是可以用的，而i和其第二个j（与j-1值相同）就导致元组重复。  int left = j+1,right = nums.length-1; while(left \u0026lt; right){ long sum = (long) nums[i]+nums[j]+nums[left]+nums[right]; if(sum \u0026gt; target) right--; else if(sum \u0026lt; target) left++; else{ list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right-1]) right--; left++; right--; } } } } return list; } }   注意:\n1  if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;}    这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 . 还有就是 \u0026gt; target \u0026lt; target == target 绝对 if\u0026hellip;else 而不是单独的多个 if .  持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C/","summary":"242.有效的字母异位词 暴力哈希：map1.put(ch,++map1.get(ch))会报错，+1就不会。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","title":"LeetCode 哈希表(二)"},{"content":"203. 移除链表元素 思路：先处理头结点 null 或者 val ，再去处理移除节点。\n注意：返回值返回 head。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public ListNode removeElements(ListNode head, int val) { //处理头结点为 val 或为 null  while(head != null \u0026amp;\u0026amp; head.val == val) head = head.next; if(head == null) return null; ListNode p = head; ListNode q = p.next; while(q != null){ if(q.val == val){ p.next = q.next; q = p.next; }else{ p = q; q = q.next; } } return head; } }   707. 设计链表 思路：先定义好 class ，然后在已有的 class 定义一个 size 和 头结点 head，然后写出 addAtIndex，其它都可以调用或者抄代码 ；\n注意：size 要变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class ListNode{ int val; ListNode next; ListNode(){} ListNode(int val){this.val = val;} } class MyLinkedList { ListNode head; int size; public MyLinkedList() {//初始化链表  int size = 0; head = new ListNode(0); } public int get(int index) { if(index \u0026gt;= size || index \u0026lt; 0) return -1; ListNode p = head; for(int i = 0; i \u0026lt;= index; i++) p = p.next; return p.val; } public void addAtHead(int val) { addAtIndex(0,val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index \u0026gt; size) return; if(index \u0026lt; 0) index = 0; size++; ListNode Node = new ListNode(val); ListNode p; p = head; for(int i = 0; i \u0026lt; index; i++) p = p.next; Node.next = p.next; p.next = Node; } public void deleteAtIndex(int index) { if(index \u0026gt;= size || index \u0026lt; 0) return; ListNode p; p = head; for(int i = 0; i \u0026lt; index; i++) p = p.next; p.next = p.next.next; size--; } }   206. 反转链表 思路：先写出循环体再思考细枝末节，例如最后一个节点要单独写并返回一个新的头结点，再比如在循环之前要判空 head ，防止 next = cur.next 报异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public ListNode reverseList(ListNode head) { if(head == null) return null; ListNode pre = null; ListNode cur = head; ListNode next = cur.next; while(next != null){ cur.next = pre; pre = cur; cur = next; next = cur.next; } cur.next = pre; return cur; } }   24. 两两交换链表中的结点 思路：创建一个虚拟头结点再用 pre 指向它，最后返回的是 虚拟头结点.next 这个新的头结点，额外加一个 temp 节点缓存 pre.next.next 其实也就相当于 next ，head 节点已经可以自由使用了，因为返回的头结点与 head 无关，head 用来缓存 pre.next 相当于 cur ，三个节点都缓存了，这三个节点相互操作就很容易，先把三个节点外的节点操作完成。然后去操作里面，再在循环中移动这几个节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public ListNode swapPairs(ListNode head) { if(head == null) return null; ListNode pre,temp; ListNode dummyNode = new ListNode(0); dummyNode.next = head; pre = dummyNode; while(pre.next != null \u0026amp;\u0026amp; pre.next.next != null){ temp = head.next; head.next = temp.next; pre.next = temp; temp.next = head; pre = head; head = head.next; } return dummyNode.next; } }   19.删除链表的倒数第N个节点 暴力解法：注意考虑传入的值的合法性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null) return null; ListNode cur; cur = head; int i = 0; while(cur != null){//计算长度  cur = cur.next; i++; } if(i == n) //删除的是头结点（单独讨论），也避免只有一个节点时 cur.next.next 为 null  return head.next; i = i-n; cur = head; while(i \u0026gt; 1){ cur = cur.next; i--; } cur.next = cur.next.next; return head; } }   进阶版本：首先一边扫描肯定无从下手，想想，倒数第 n 个结点，是正着数的第几个 ?\n显而易见：size-n 个，那如何拼凑出 size ？那是肯定要扫描一遍完整的链表结点的。\n如果扫描 size++ 出长度那必然要再操作一遍，落入了扫描多次的圈套，so what？\n定义一个 fast 指针、一个 slow 指针，fast 扫描全文，而 slow 指向要被删除的结点的上一结点。如何凑出 size -n？先让 fast 走 n 次，再让 fast 和 slow 一起走剩下的 size-n 次，此时 fast 指向了最后一个元素，slow 指向了删除的结点的上一结点。用 虚拟头结点 会减少很多麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null || head.next == null) return null; ListNode fast,slow,pre; ListNode dummy = new ListNode(0); dummy.next = head; pre = slow = fast = dummy; int i = 1; while(i \u0026lt; n){ fast = fast.next; i++; } while(fast.next != null){ pre = slow; fast = fast.next; slow = slow.next; } pre.next = slow.next; return dummy.next; } }   面试题 02.07. 链表相交 暴力：两层循环遍历，注意有的在 A 链表的位置不一定对应 B 链表的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode node1 = headA; ListNode node2 = headB; while(node1 != null){ node2 = headB; while(node2 != null){ if(node2 == node1) return node2; else node2 = node2.next; } node1 = node1.next; } return null; } }   巧解：AB一定在某一点会相遇并且之后的链表重合，后面重合有个特点，节点数相等。也就是说要在某点相遇必定要链表后半段节点数相等，也就是前面可以有一个长度差不去扫描，从 “剩余共同长度“ 的位置开始，也就是跳过前一小段。两条链表一起扫描，避免了双层扫描。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode node1 = headA, temp; ListNode node2 = headB; int lenA = 0, lenB = 0, gap = 0; while(node1 != null){ lenA++; node1 = node1.next; } while(node2 != null){ lenB++; node2 = node2.next; } node1 = headA; node2 = headB; if(lenA \u0026lt; lenB){ node1 = headB; node2 = headA; } gap = Math.abs(lenA-lenB); while(gap-- \u0026gt; 0) node1 = node1.next; while(node1 != null \u0026amp;\u0026amp; node1 != node2){ node1 = node1.next; node2 = node2.next; } return node1; } }   142.环形链表II 两个重要点\n 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 快指针永远走的是慢指针的两倍长度。  解释一下：\n先判断有没有环，while 下 快指针走 2 步，慢指针走 1 步，如果两个结点 位置一致，即为有环，否则无环则一定会 fast.next || fast.next.next ==null。\n从头节点到环入口结点距离为 A，环入口节点到相遇结点正向距离为 B，相遇节点正向到入口节点距离为 C。一定是在环内相遇，且 A == C。\n~~为什么 (x + y) * 2 = x + y + n (y + z)，其中没必要纠结 y ≥ b+c 即圈长与否，也就是说走了多少圈的 y 都可以，因为 y+z 一定是整圈，因为 y 要么是 环入口到相遇点的距离 要么是 ~~ n*(y+z)+y ，总之会多余一个 y ，再加上 c 一定是整圈。\nfast在slow前面一步，那么下一步追上。\nfast在slow前面两步，那么下一步变成只差一步。\nslow 进 环入口走不到一圈一定会被追上，这种走一圈的极端条件 fast 走了两圈，而即使第一圈擦肩而过，第二圈也一定会相遇。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class Solution { public ListNode detectCycle(ListNode head) { if(head == null) return null; ListNode fast = head ,slow = head; while(fast.next != null \u0026amp;\u0026amp; fast.next.next != null){ fast = fast.next.next; slow = slow.next; if(slow == fast){//必定有环  fast = head; while(slow != fast){ slow = slow.next; fast = fast.next; } return slow; } } return null; } }   ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E9%93%BE%E8%A1%A8%E4%BA%8C/","summary":"203. 移除链表元素 思路：先处理头结点 null 或者 val ，再去处理移除节点。 注意：返回值返回 head。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode removeElements(ListNode head,","title":"LeetCode 链表（二）"},{"content":"最近学习 这个月效率不错，但也只是不错。反复有几天是真的厌恶自己学的东西，太tm抽象了。\n好在坚持下来了，操作系统 过完了，等轮询复习过来到时候再看。\n最近生活 anxious，麻木，幸福指数乱七八糟，疫情连续做25天核酸。\n在家确实可以安心好好学习，不会出去玩不会有人找，但是生活幸福指数还是乱七八糟，上个月经常出去觉得不出去学习就会很舒服。 现在仍然是天天醒来不愿意面对学习的东西，晚上潜意识想玩手机，但已经在逼自己睡觉了，想睡睡不着是真难受，听点相声真的会想起小时候捧着《XX动漫》的电视台看动漫版的相声，生活味十足，刚开始听能睡着，后来听着听着就跟着笑就睡不着， 听那种听不大懂的，连贯性强的《三体》能睡着，喜马拉雅 我真的是爱了。争做早睡早起好青年，杜绝熬夜，熬夜太伤了，自己脑子变笨都发现不了。\n8月 比较 7月 随想录二刷进度中规中矩，回溯马上刷完了，就是贪心、动归了，周赛都还行，2次1题，一次2题，一次ac三题，能稳定2题偶尔冲三题我就开心死了。\n操作系统整完了，细的地方真细，不懂的地方是真不懂，看10遍也不懂。效率比7月应该算稳健提高。\n9月计划 计网（两遍） 过完 + 代码随想录二刷彻底结束，并且开始（2 old + 1/2 new）模式。\n是1还是2看题目难度，第一题easy就必须要做第二题，每天要保证在算法上有深度思考。\n计网半个月过完第一遍（平均一天两篇）、第一遍适当快，第二遍必须深度思考。\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\n计网 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 + hot 100 \u0026ndash;\u0026gt; 四刷 + 剑指 offer（ACM模式）\n","permalink":"https://coderrenxy.github.io/posts/life/8%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 这个月效率不错，但也只是不错。反复有几天是真的厌恶自己学的东西，太tm抽象了。 好在坚持下来了，操作系统 过完了，等轮询复习过来到时候再","title":"8月总结"},{"content":"这周进度 都还好，操作系统上周定的目标太高了，也不算高，只是方向变了，想详细的再看一遍这一遍才是真正的学懂，才真正的静下心吸收进去了，以后学东西也要先大概过一遍再 detail，二叉树刚好刷完，没有超额没有未完成。\n下周计划  看完操作系统。 二刷刷完回溯（有点难，一天三题）。 周赛，明天周末打周赛。  本月  到结尾了已经，那就给下周开个好头吧。  ","permalink":"https://coderrenxy.github.io/posts/life/augest.no4-weekly-summary/","summary":"这周进度 都还好，操作系统上周定的目标太高了，也不算高，只是方向变了，想详细的再看一遍这一遍才是真正的学懂，才真正的静下心吸收进去了，以后学东","title":"Augest No.4 Weekly Summary"},{"content":"这周进度 都还好，有时候题目刷多一点，有时候操作系统看多一点，每天侧重点不同。\n有一点收获：前几天看操作系统都不顺利，突然有一天茅塞顿开，学的很专注。这种专注真的是可遇不可求，只能说边学边做笔记，带着自己大脑的索引能力去主动获取一个知识的相关信息，这样就算以后不看笔记，至少在学的这一刻，他让我印象深刻，也让我有了更好的理解。 文件系统、设备管理、调度算法都看了一遍，LC有时候一天5题有时候一天2题，还不错。还超额看了网络系统，这周看完了。\n下周计划  看完Linux命令。 二叉树刷完。 周赛，明天周末打周赛。 看视频的《操作系统》再复习书面知识。  本月 1. 一定要结束操作系统，开始计网的学习。 ","permalink":"https://coderrenxy.github.io/posts/life/augest.no3-weekly-summary/","summary":"这周进度 都还好，有时候题目刷多一点，有时候操作系统看多一点，每天侧重点不同。 有一点收获：前几天看操作系统都不顺利，突然有一天茅塞顿开，学的很","title":"Augest No.3 Weekly Summary"},{"content":"这周进度  每天2-3道以前刷过的 LC，有一天 hard 当天没写出来也没看懂题解，下一天写出来了，还写出一道 一刷 没写出来的题，但是是 暴力解 ，因为用大小顶堆的优先队列有的 API 不熟悉，而且不常用，用过一次又忘记，死循环。 Linux命令过完了，操作系统的面经看了进程管理，这周完成进程管理。  下周计划  完成内存管理、调度算法、文件系统。 二叉树刷一半以上。 周赛，明天周末打周赛，进程管理多过几遍。  本月 1. 一定要结束操作系统，开始多线程。发现操作系统进程管理和线程联系很深。\r2. 再来看操作系统和 jvm、redis、计网 哪个联系深。 ","permalink":"https://coderrenxy.github.io/posts/life/augest.no2-weekly-summary/","summary":"这周进度 每天2-3道以前刷过的 LC，有一天 hard 当天没写出来也没看懂题解，下一天写出来了，还写出一道 一刷 没写出来的题，但是是 暴力解 ，因为用大小顶","title":"Augest No.2 Weekly Summary"},{"content":"关于总结 周总结不谈生活，只谈学习进度，月总结、年度总结全维度谈。\n这周进度  每天2-3道以前刷过的 LC。 每天在学 Linux、刷题、以及学车。   Lunix：大概有了个框架，知道什么操作 属于 什么模块，然后对应去查命令，也安装了相关东西：centOs、VMWare、jdk、tomcat、mysql、xShell（据说finalShell更好）、xftp，明天是本周最后一天，完结 shell 编程。 算法：二刷LC，周末打周赛，一天2-3题，开学前完成二刷。  下周计划  Linux 刷完视频 并浏览相应的面经 并记录 Blog 。 11号考科二。 算法接着刷。  ","permalink":"https://coderrenxy.github.io/posts/life/augest.no1-weekly-summary/","summary":"关于总结 周总结不谈生活，只谈学习进度，月总结、年度总结全维度谈。 这周进度 每天2-3道以前刷过的 LC。 每天在学 Linux、刷题、以及学车。 Lu","title":"Augest No.1 Weekly Summary"},{"content":"最近学习 最开始学习效率有点低，后来非常重视这件事，白天学新知识，晚上刷 leetcode ，每天大概 2h-3h 的 leetcode，3h 左右的 Linux。\n最近生活 科二练的特别好，加了老顾的技术群，希望以后能擦出一点不一样的火花。\n学习的枯燥又无精打采的时候，就睡一觉，睡醒就好了。\n7月 比较 6月 随想录二刷进度中规中矩，学习Linux的速度没有想象那么快，但是也还好，总算开始学了点新东西。\n六月前半段都在 考升本 + 摆烂 + 回家 + 焦虑，后半段才刷题。\n七月考科目1练科目二 + Linux + 刷题。 效率比6月明显高了，大概每天有效学习时长 5-6h ，加上中间穿插摆烂看手机斗地主吃饭看b站的时间大概是10h，是个人看到这里都会想如果 10h 都在学习那效率多高啊。但人不是永动机啊，不保养就会消磨殆尽。\n8月计划 Linux 过完 + reids 过完基础篇进入到高级篇。\n长期计划 首先 去做 \u0026raquo; 计划。\n操作系统 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; 计网 \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 \u0026ndash;\u0026gt; hot 100 \u0026ndash;\u0026gt; 剑指 offer\n","permalink":"https://coderrenxy.github.io/posts/life/7%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 最开始学习效率有点低，后来非常重视这件事，白天学新知识，晚上刷 leetcode ，每天大概 2h-3h 的 leetcode，3h 左右的 Linux。 最近生活 科二练","title":"7月总结"},{"content":"704. 二分查找 思路：首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-1，不然有的用例会超时，循环条件则是 right ≥ left 不然藏在边界的 target 就查不到了。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length-1, mid; while(right \u0026gt;= left ){ mid = (right-left)/2+left; if(target == nums[mid]) return mid; else if(target \u0026gt; nums[mid]) left = mid+1; else right = mid-1; } return -1; } }    27. 移除元素 暴力解法：需要注意，i\u0026ndash;；是因为既然当前值为 val 的点的右边所有点一切都左移了一位，所以现在的 i 指向的是已删除（被覆盖）的位置，该位置补了后面那位没被扫描的数字，而该次循环结束就要 i++了，所以会指向这个没扫描的下一个进行扫描，就漏掉一个了。还有一个就是无限循环容易发生是因为 for 循环条件不能是 \u0026lt; length。而应该是 \u0026lt; len 这个自定义的，会随着更新而更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public int removeElement(int[] nums, int val) { int len = nums.length; for(int i = 0; i \u0026lt; len; i++) if(nums[i] == val){ for(int j = i; j \u0026lt; len-1; j++) nums[j] = nums[j+1]; len--; i--; } return len; } }   快慢指针法：fast 位置是 val 值，就 fast++，不是 val 值就 nums[slow] = nums[fast]，slow 后移一位，为了不影响 非val 的值，并且slow可以计数（非 val 个数）。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int removeElement(int[] nums, int val) { int slow = 0, fast = 0; for(; fast \u0026lt; nums.length; fast++) if(nums[fast] != val){ nums[slow] = nums[fast]; slow++; } return slow; } }    977. 有序数组的平方 思路：暴力就是先平方再 arrays.sort( ); 但是时间复杂度为 O(n)+nlogn; 所以这么解不行，用双指针的方法要注意，一定要从两头找最大的放入新数组的最右侧，因为两头只能找最大，最小的有可能类似：{-3，0，3}，最小在中间。注意循环条件是 left ≤ right，而不是 left \u0026lt; right，因为有边界要处理。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int[] sortedSquares(int[] nums) { int left = 0, right = nums.length-1,i=nums.length-1; int[] array = new int[nums.length]; while(left \u0026lt;= right) if(nums[left]*nums[left] \u0026gt; nums[right]*nums[right]) array[i--] = nums[left]*nums[left++]; else array[i--] = nums[right]*nums[right--]; return array; } }    209. 长度最小的子数组 思路：滑动窗口，这样写法虽然时间复杂度是 O(n)，但是效率比另一种 O(n^2) 要低很多，另一种在 for 循环嵌套一个 while 循环，让达到 ≥ target 的 sum 一直减去 nums[left] ，而 sum 不需要反复初始化为 0. 注意循环自增 end。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //双指针 class Solution { public int minSubArrayLen(int target, int[] nums) { int begin = 0, end = 0, sum = 0, min = Integer.MAX_VALUE; for(; end \u0026lt; nums.length; end++){ sum += nums[end]; if(sum \u0026gt;= target){ min = Math.min(min,end-begin+1); sum = 0; end = begin; begin++; } } return min == Integer.MAX_VALUE ? 0 : min; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  //滑动窗口 class Solution { public int minSubArrayLen(int target, int[] nums) { int begin = 0, end = 0, sum = 0, min = Integer.MAX_VALUE; for(; end \u0026lt; nums.length; end++){ sum += nums[end]; while(sum \u0026gt;= target){ min = Math.min(min,end-begin+1); sum -= nums[begin++]; } } return min == Integer.MAX_VALUE ? 0 : min; } }    59. 螺旋矩阵 II 思路：\n 先模拟整个一圈的流程，再去写外层循环，循环次数可以由 n/2 来确定，但此时有个问题，n 为奇数则中间 array[n/2][n/2] 需要单独赋值，而 n 为偶数不需要。 还有在判断的时候很容易搞混什么适合走的是 x ，什么时候走的是 y。 在往内圈走的时候很容易碰到一个问题就是：n 需不需要 n\u0026ndash; ？其实设置一个偏移量 offset 就行了，因为如果 n— 那么在第三、四个循环解决不了少走一个格子的问题。 设置 startX、startY 是为了走下一圈的时候能顺利切换。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int[][] generateMatrix(int n) { int[][] array = new int[n][n]; int x, y, startX = 0, startY = 0, num = 1, circle = n / 2, offset = 0; while(circle-- \u0026gt; 0){ x = startX; y = startY; for(; y + offset \u0026lt; n-1; y++){ array[x][y] = num++; } for(; x + offset \u0026lt; n-1; x++){ array[x][y] = num++; } for(; y - offset \u0026gt; 0; y--){ array[x][y] = num++; } for(; x - offset \u0026gt; 0; x--){ array[x][y] = num++; } startX++; startY++; offset++; } if(n % 2 == 1)array[n/2][n/2] = num; return array; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E6%95%B0%E7%BB%84%E4%BA%8C/","summary":"704. 二分查找 思路：首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-","title":"LeetCode 数组(二)"},{"content":"01背包 509. 斐波那契数 1 2 3 4 5 6 7 8 9 10 11  class Solution { public int fib(int n) { if(n\u0026lt;2) return n; int[] dp = new int [n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } }    70.爬楼梯 思路：走第i层时，从i-1到i只有一种方法，从i-2到i也只有一种方法，所以从0到i-1到i有dp[i-1]种方法，从0到i-2到i有dp[i-2]种方法。所以从0到dp[i]有dp[i-2]+dp[i-1]种方法，所以dp[i]=dp[i-1]+dp[i-2]。其实也能转换为完全背包来做，物品分别是1，2。都可以无限次用。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int climbStairs(int n) { if(n\u0026lt;=2) return n; int [] dp = new int[n+1]; dp[1]=1;dp[2]=2; for(int i=3;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } }    746. 使用最小花费爬楼梯 思路：主要是dp数组如何构建。dp数组的含义是，从 i 跳走必须花 dp[i] 的钱，所以最后是只有三个数的话，要跳出这三个数：dp[2]=( dp[2-1] , dp[2-2] )+ cost[i] ；dp 数组初始化好直接返回就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public int minCostClimbingStairs(int[] cost) { if(cost == null || cost.length == 0) return 0; if(cost.length == 1) return cost[0]; int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for(int i = 2; i \u0026lt; cost.length; i++){ dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i]; } return Math.min(dp[cost.length - 1], dp[cost.length - 2]); } }    62.不同路径 思路：每个格子 i,j 都是从 i-1,j 或 i,j-1 走过来，所以 dp[ i ] [ j ] = dp[ i-1 ] [ j ] + dp[ i ] [ j - 1 ] ;上面、左边两行都要初始化为1，只能唯一，因为只有右移或者下移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int uniquePaths(int m, int n) { if(m \u0026lt;= 0 || n \u0026lt;= 0) return 0; if(m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for(int i=0;i\u0026lt;n;i++) dp[0][i]=1; for(int i=0;i\u0026lt;m;i++) dp[i][0]=1; for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++) dp[i][j] = dp[i-1][j]+dp[i][j-1]; } return dp[m-1][n-1]; } }    63. 不同路径 II 这次只出了一个越界，其它全对，思路也是自己的，直接AC，兴奋。\n思路：初始化要注意，只能向右👉，下👇走，所以在初始化第一行、第一列的时候如果遇见障碍物，该位置与后面所有直线位置dp[i][j] 都为0，注意初始化完成第一行、第一列，所以从 (1,1) 坐标开始初始化dp，否则就越界了。在其他位置遇见障碍物就直接 dp[i][j] = 0 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length,n = obstacleGrid[0].length; int[][] dp = new int[m][n]; int flag = 1; for(int i=0;i\u0026lt;m;i++){ if(obstacleGrid[i][0] == 1) flag = 0; dp[i][0] = flag; } flag = 1; for(int i=0;i\u0026lt;n;i++){ if(obstacleGrid[0][i] == 1) flag = 0; dp[0][i] = flag; } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } }    343. 整数拆分 思路：拆分成两个、两个或两个以上个、并更新以便取得最大值。初始化 dp[2]=1 .为什么？dp 数组是记录 i 值对应的最大《拆分积》。为什么内循环的条件是 j≤i-j ? 相当于剪枝操作， [ i-j , i ] 的数在 [0，i-j ] 已经乘过了，比如数字4， 1~4 是在1~2和2~4相乘，而不是两者相加=4。1~4和1~4会越界。\n主要代码：\n1  dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));   为什么需要dp[i]、j*(i-j)、jdp[i-j]取最大值，dp[i] 是为了取得最大值，因为dp[i]是多个比较的结果。而j(i-j)是两个数的乘积，经过循环就是求得其分为两数的最大值，jdp[i-j] 是拆分为两个以上，dp是i-j拆分为2+个数最大的积，那么是可能拆分为n个数的，会涵盖所有拆分可能，并剩余值。\n 96. 不同的二叉搜索树 思路：很抽象，先把0、1个节点只有一种可能确定好，再是从dp[2]、dp[3]来找递推公式。\ndp[2]在1为头结点时，只能2挂在右边这种可能，2为头结点时，只能1挂在左边，dp[2]=1+1=2 。\ndp[3]在1为头结点时，可以2、3依次深度排序，也可以1、3、2，所以两种可能。\ndp[3]在2为头结点时，只能左右分别挂一个，所以只有一种可能。\ndp[3]在3为头结点时，.类似1为头结点，两种可能。sum=2+1+2=5种可能。\ndp[3] 递推公式：\n1为头 sum+=dp[0]*dp[2]=2左孩子0个节点，右孩子2个节点。\n2为头 sum+=dp[1]*dp[1]=1，左右孩子分别1个。\n3为头 sum+=dp[2]*dp[0]=2，左孩子2个，右孩子一个。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int numTrees(int n) { int[] dp = new int[n+1]; dp[0]=dp[1]=1; for(int i=2;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;=i-1;j++) dp[i]+=dp[i-j-1]*dp[j]; } return dp[n]; } }    416. 分割等和子集 思路：以01背包背包的思路，dp[ i ][ j ] 的 i 代表从0到i选择，j代表背包容量为j，dp[i][j] 代表这样的前置条件下最大能装下的值。\n主要还是数学逻辑：当背包容量为 sum/2 时，能在nums找到和为sum/2，也就是dp[ i ][ j ] =sum/2。就找到了，为什么？因为只要有和能为 sum 的一半，那么一定剩下的数字和一定也为 sum/2 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public boolean canPartition(int[] nums) { int sum = 0,target; for(int i=0;i\u0026lt;nums.length;i++) sum += nums[i]; if(sum % 2 == 1) return false; target = sum/2; int[][] dp = new int[nums.length][target+1]; for(int j = nums[0]; j \u0026lt;= target;j++) dp[0][j] = nums[0]; for(int i = 1;i \u0026lt; nums.length;i++){ for(int j = 1;j \u0026lt;= target;j++){ if(j \u0026gt;= nums[i]) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else dp[i][j] = dp[i-1][j]; } } return dp[nums.length-1][target] == target; } }    1049. 最后一块石头的重量 II 思路：还是跟上题一样，就是数学逻辑。用sum/2的容量来看最大能拿到多大，然后sum-max，也就是另一半的值，这两个值相减就出来了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int lastStoneWeightII(int[] stones) { int sum=0,target; for(int i:stones) sum += i; target=sum/2; int[][] dp = new int[stones.length][target+1]; for(int i=stones[0];i\u0026lt;target+1;i++) dp[0][i] = stones[0]; for(int i=1;i\u0026lt;stones.length;i++) for(int j=1;j\u0026lt;target+1;j++) if(stones[i] \u0026gt; j) dp[i][j] = dp[i-1][j]; else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]); return sum-dp[stones.length-1][target]-dp[stones.length-1][target]; } }   一维数组（滑动数组）：相当于二维 dp[ i ] [ j ] = dp[ i-1 ] [ j ] 直接省去这一步骤，而是直接把上一层拷贝下来。\n1 2 3 4 5 6  dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]); //变化 dp~~[i]~~[j] = Math.max(dp~~[i]~~[j],dp~~[i]~~[j-stones[i]]+stones[i]);把多行放在一行里面滑动操作了。 //简化 dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);   代码变为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i : stones) { sum += i; } int target = sum \u0026gt;\u0026gt; 1; //初始化dp数组  int[] dp = new int[target + 1]; for (int i = 0; i \u0026lt; stones.length; i++) { //采用倒序  for (int j = target; j \u0026gt;= stones[i]; j--) { //两种情况，要么放，要么不放  dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - 2 * dp[target]; } }   在内循环直接条件限制为 j ≥ stones 其实是像第一层初始化这样理解：装不下就不装，就不变，保持等于原来的dp[ j ]，也就是现在的dp[ j-1 ]。直接把二维数组时候的 if-else 省略了。\n 494. 目标和 思路：将这个数组分为两个子集：left、right，left+right=sum，left-right=target。两个方程相加2 * left=（sum+target）—\u0026gt; left=（sum+target）/ 2 。确定了左边就确定了右边，所以找到left 为总和的组合数为 n，整体组合数就是n。\n区别：与以前不同在于，求可能可能性的总数，前几道题是最大价值。都是01背包问题。主要区别在于循环体、初始化。\n  特殊情况1：容量为nums[0]：不放、放入nums[0]一共两种情况对吧? 错了，只能直接nums[0]\u0026ndash;\u0026gt;nums[0],在0-0这个区间只有 nums[i] 能放进去，那么只有恰好nums[0]=size时候这种放法。\n  特殊情况2：size为0时（初始化），此时就有“一种方法”就是“不放入”。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0, leftBagSize; for(int i:nums) sum += i; if( (sum + target) % 2 == 1) return 0; leftBagSize = Math.abs( (sum + target) / 2 ); //考虑负数  int[] dp = new int[leftBagSize+1];//这里不是最大价值，是组合个数。  //初始化  dp[0] = 1; for(int i = 0; i \u0026lt; nums.length; i++){ for(int j = leftBagSize; j \u0026gt;= nums[i]; j--){ //求的是总和（所有可能性）要把不+nums[i]的也算上  dp[j] += dp[j-nums[i]]; } } return dp[leftBagSize]; } }    474.一和零 思路：理解题意！找出并返回 strs 的最大子集的长度，最大子集指的是最长的子集长度，即最多可以包含几个字符串作为子集。那么dp[i][j] 也就是个三维的01背包，进一个字符串先判断几个 0 几个 1 。然后逆序遍历来更新值，从m，n开始，i≥one，是为了至少有这个容量来装，防止 max 里面 index = -1 越界，Math.max里面更新很巧妙，如果是去掉当前串的 01 个数，就是看此时（去当前串01）容量是否已经初始化过，即是否装过了，装过了还能装就是1+1=2次。如果没装过就是0+1，相当于初始化了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int [m+1][n+1]; for(String str:strs){ int zero = 0, one = 0; for(char ch:str.toCharArray()){ if(ch == \u0026#39;0\u0026#39;) zero++; else one++; } for(int i = m; i \u0026gt;= zero;i--) for(int j = n; j \u0026gt;= one; j--) dp[i][j] = Math.max(dp[i][j], dp[i-zero][j-one]+1); } return dp[m][n]; } }    完全背包 指的是物品可以无限次被使用，此时就是正序遍历，先遍历“物品”还是“背包”要看是 排列 还是 组合 ，组合 先 遍历 物品，因为这种遍历方式物品有先后顺序，而排列没有，则会打乱顺序还有结果。\n518. 零钱兑换 II 思路：完全背包问题（组合：无序）每个物品可以用无限次，正向遍历。容量为0的时候不放入也是一种方法。这样在以后j=coins[i]时可以dp[j]+=dp[j-coins[i]] 即dp[0] 即1；\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int change(int amount, int[] coins) { int[] dp = new int[amount+1]; dp[0] = 1; for(int i = 0; i \u0026lt; coins.length; i++){ for(int j = coins[i]; j \u0026lt;= amount; j++){ dp[j] += dp[j-coins[i]]; } } return dp[amount]; } }    377. 组合总和 Ⅳ 思路：求的是排列（强调顺序，不同顺序为不同排列），排列先遍历背包，再遍历物品。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; dp[0] = 1; for(int i = 0; i \u0026lt;= target; i++) for(int j = 0; j \u0026lt; nums.length; j++) if(i \u0026gt;= nums[j]) dp[i] += dp[i-nums[j]]; return dp[target]; } }    322. 零钱兑换 思路：满足条件的，最小硬币个数。无限使用 == 完全背包，求的是组合（不强调顺序）所以是先遍历物品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; int max = Integer.MAX_VALUE; int[] dp = new int[amount+1]; dp[0] = 0; for(int i=1; i\u0026lt;=amount; i++)//初始化  dp[i] = max; for(int i = 0; i \u0026lt; coins.length; i++) for(int j = coins[i]; j \u0026lt;= amount; j++) if(dp[j-coins[i]] != max) dp[j] = Math.min(dp[j-coins[i]]+1,dp[j]); return dp[amount] == max ? -1 : dp[amount]; } }    279.完全平方数 思路：完全背包，自己构建一个长度为 (int) Math.sqrt(n) 的物品数组，为什么？因为target最多被 sqrt(target) 平方出 target，而自己也要构建物品数组，i对应i*i ;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int numSquares(int n) { int max = Integer.MAX_VALUE; int len = (int)Math.sqrt(n); int[] dp = new int[n+1]; dp[0] = 0; for(int i = 1; i \u0026lt;= n; i++) dp[i] = max; for(int i = 1; i \u0026lt;= len; i++) for(int j = i*i; j \u0026lt;= n; j++) if(dp[j-i*i] != max) dp[j] = Math.min(dp[j],dp[j-i*i]+1); return dp[n]; } } // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 2 3 1 2 3 4 2 3 4 5 3 // 0 1 2 3 1 2 3 4 2 1 2 3 3    139.单词拆分 思路：用字符串截取、List的contains方法来判断是否存在该截取的子串，存在且 d[j] 为 true 就 dp[i] = true .这样做的好处是每个位置每个子串都处理到了，而如果只移动i，等存在 并且 dp[i] = true 时，才移动j，那么在[\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;aaaa\u0026rdquo;] , s=\u0026ldquo;aaaaaaa\u0026rdquo; 这个测试用例就过不去，因为走的是两个aaa，剩下aa就走不动了。\n1 2 3 4 5 6 7 8 9 10  class Solution { public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { boolean[] dp = new boolean[s.length()+1]; dp[0] = true; for(int i = 1; i \u0026lt;= s.length(); i++) for(int j = 0; j \u0026lt; i; j++) if(wordDict.contains(s.substring(j,i)) \u0026amp;\u0026amp; dp[j]) dp[i] = true; return dp[s.length()]; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","summary":"01背包 509. 斐波那契数 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int fib(int n) { if(n\u0026lt;2) return n; int[] dp = new int [n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } } 70.爬楼梯 思路：走第i层时，从i-1","title":"LeetCode 动态规划"},{"content":"455.分发饼干 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count=0; for(int i=0,j=0;i\u0026lt;s.length \u0026amp;\u0026amp; j\u0026lt;g.length;i++){ if(s[i] \u0026gt;= g[j]){ count++; j++; } } return count; } }    376. 摆动序列 我的思路：直接改变数组比如4，3，4，5.只保留，4，3，5而把第三个4去掉，因为保留最高或者最低的那个更容易出现转折，最后保留下来的数组的长度就是返回值。不过这样坑多，可复用性差，下一次拿到题目抠细节抠到哭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public int wiggleMaxLength(int[] nums) { int len=nums.length; boolean flag1=true,flag2=true; for(int j=0;j\u0026lt;len-1 \u0026amp;\u0026amp; len\u0026gt;1;j++){ int t = nums[j+1]-nums[j]; if(t == 0){ cutArray(nums,j); len--; j--; continue; }else if(j%2 == 1){ if(t\u0026gt;0) flag1 = true; if(t\u0026lt;0) flag1 = false; }else{ if(t\u0026gt;0) flag2 = true; if(t\u0026lt;0) flag2 = false; } if(j == 0) continue; else if(flag1 == flag2){ cutArray(nums,j); len--; j--; } } return len; } public void cutArray(int[] nums,int index){ for(int i=index;i\u0026lt;nums.length-1;i++) nums[i] = nums[i+1]; } }   题解思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int wiggleMaxLength(int[] nums) { if(nums.length \u0026lt;= 1) return nums.length; int cur=0,pre=0,count=1; for(int i=0;i\u0026lt;nums.length-1;i++){ cur = nums[i+1]-nums[i]; if(cur\u0026gt;0\u0026amp;\u0026amp;pre\u0026lt;=0 || cur\u0026lt;0\u0026amp;\u0026amp;pre\u0026gt;=0){//总之cur必须!=0，pre可能是初始化的0，因为所有的cur都!=0，所以后面赋值到的pre也!=0  //这样比较就算持续3,7,4,5,6在最后比较的也是最后面那个偏差幅度最大的值6，最后有效是3，7，4，6.相比我之前的思想化繁为简。  pre = cur; count++; } } return count; } }    53.最大子序和 如果多个数相加\u0026lt;0，那就是累赘，和后面任何数相加只会让sum更小。所以从这个数后面的第一个数就要从0重新计算sum 。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int maxSubArray(int[] nums) { if(nums.length==1) return nums[0]; int sum = 0,max=nums[0]; for(int i=0;i\u0026lt;nums.length;i++){ sum+=nums[i]; if(sum\u0026gt;max) max=sum; if(sum\u0026lt;=0) sum=0; } return max; } }    122.买卖股票的最佳时机II nums[j+1]\u0026gt;nums[j]时就可以买卖了，局部最优，否则就移到下一位置。\n可能会有疑惑，5，3，7这样不就5，7也是盈利啊，但是3，7盈利更大呀，就算是3，5，7，在3买5卖，5买7卖其实结果也是一样。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int maxProfit(int[] prices) { int sum=0,t; for(int i=0;i\u0026lt;prices.length-1;i++){ t=prices[i+1]-prices[i]; if(t\u0026gt;0) sum+=t; } return sum; } }    55.跳跃游戏 局部最优这句话怎么利用？\n覆盖范围，在第一个位置的覆盖范围内可到达的最远地方。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public boolean canJump(int[] nums) { if(nums.length==1) return true; int range = nums[0]; for(int i=0;i\u0026lt;=range;i++){ if(nums[i]+i \u0026gt; range) range=nums[i]+i; if(range \u0026gt;= nums.length-1) return true; } return false; } }    45.跳跃游戏II 这道题我有个疑问就是，当前最远、下一步最远 如何保证下一步到最远不是到一个为0的数，到了为0是不是就动不了，其实不是的，这是《当前范围》《可能的下一步的所有最远范围》然后 curRange = nextRange ，这样nextRange又在更新，局部最优转换为了全局最优。\n主要链路是不断比较计算总结出curRange可以到达的最远距离。coding时注意在curRange最后一位：curRange=nextRange；还有循环终止条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int jump(int[] nums) { if(nums.length==1) return 0; int curRange=nums[0],nextRange=nums[0],count=1; for(int i=0;i\u0026lt;=curRange\u0026amp;\u0026amp;curRange\u0026lt;nums.length-1;i++){ if(nums[i]+i\u0026gt;nextRange) nextRange=nums[i]+i; if(i==curRange) { curRange=nextRange; count++; } } return count; } }    1005.K次取反后最大化的数组和  绝对值排序 0-len将负数取反，如果全是正书，不管一开始就是还是处理完才是，在绝对值最小位置反复取反。 求和  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int largestSumAfterKNegations(int[] nums, int k) { int sum=0,temp; for(int i=0;i\u0026lt;nums.length;i++)//给绝对值排序  for(int j=i+1;j\u0026lt;nums.length;j++) if(Math.abs(nums[j])\u0026gt;Math.abs(nums[i])){ temp=nums[j]; nums[j]=nums[i]; nums[i]=temp; } for(int i=0;k\u0026gt;0;i++){//处理k次  //先判断是否到最末位置，再判断当前位置是否为负数。不然可能最末尾为负数，那就越界。 因为i没有-1.  if(i==nums.length-1){ nums[i]=-nums[i]; i--; k--; } if(nums[i]\u0026lt;0){ nums[i]=-nums[i]; k--; } } for(int i=0;i\u0026lt;nums.length;i++)//求和  sum+=nums[i]; return sum; } }    134.加油站 暴力解法（我的）：双重for，外层控制开始的位置，内层判断是否能成功走一圈。\n注意：要在外循环内进行剪枝，不然会超时，但是效率尽管如此，双重循环效率依旧很低。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { for(int i=0;i\u0026lt;cost.length;i++){//起始位置全轮一遍  int sum=gas[i],count=1; if(gas[i]==0) continue; for(int j=i;cost[j]\u0026lt;=sum;j++){ if(j==cost.length-1){ sum=sum+gas[0]-cost[j];//s=8+1-2=7,  count++; j=-1; }else{ sum=sum+gas[j+1]-cost[j]; count++; } if(count\u0026gt;cost.length) return i; } } return -1; } }    135.分发糖果 注意：评分更高的糖果多（\u0026gt;），如果相等就算\u0026lt;\n两次循环，第一次从左到右，第二次从右到左。\n第一次处理逻辑：从1开始，如果a[i]\u0026gt;a[i-1]，那么a[i]=a[i-1]+1，否则就a[i]=1\n第二次处理逻辑：从length-2开始，如果a[i]\u0026gt;a[i+1]那就比较sweet[i]、sweet[i+1]+1，取大的赋值给a[i]，以此保证规则。\n左—\u0026gt;右 ：\n 如果评分是1,2,3 糖果分别是1，2，3 如果评分是2,1,3 糖果分别是1，1，2 （有问题） 如果评分是3,2,1 糖果分别是1，1，1 （有问题） 如果评分是3,1,2 糖果分别是1，1，3 （有问题）  右—\u0026gt;左：\n 如果评分是1,2,3 糖果分别调整为1，2，3 如果评分是2,1,3 糖果分别调整为2，1，2 如果评分是3,2,1 糖果分别调整为3，2，1 如果评分是3,1,2 糖果分别调整为2，1，2  整体过程分别从左到右、从右到左保证评分的规则性，第一遍可能使得做边不规则（a[len-1]肯定规则），第二遍可能使得右边不规则（a[0]肯定规则）。一个是从1开始，和i-1比较，一个是len-1开始，和i+1，分别向左和向右比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int candy(int[] ratings) { if(ratings.length\u0026lt;=1) return ratings.length; int count=0; int[] sweet = new int[ratings.length]; sweet[0]=1; for(int i=1;i\u0026lt;ratings.length;i++){ if(ratings[i]\u0026gt;ratings[i-1]) sweet[i]=sweet[i-1]+1; else sweet[i]=1; } for(int i=ratings.length-2;i\u0026gt;=0;i--){ if(ratings[i]\u0026gt;ratings[i+1]) sweet[i]=Math.max(sweet[i],sweet[i+1]+1); } for(int i:sweet) count+=i; return count; } }    406.根据身高重建队列 先按照身高来排（高—\u0026gt;低），再按照前面比他高的人数（少—\u0026gt;多），遵循这两个规律来排序，再依次按照“前面有几个人”来当索引插入到LinkedList。\nlamada表达式排序的写法：Arrays.sort(数组名,(a,b)→{return \u0026gt;0的值就交换，反之则不})；\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int[][] reconstructQueue(int[][] people) { Arrays.sort(people,(a,b)-\u0026gt;{ if(a[0]==b[0]) return a[1]-b[1]; return b[0]-a[0]; }); LinkedList\u0026lt;int[]\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); for(int[] p:people) linkedList.add(p[1],p); return linkedList.toArray(new int[people.length][]); } }    452.用最少数量的箭引爆气球 主题思路：先按左/右排序好，然后在循环里判断：\n 如果第二个数组的左边界 ≤ 第一个数组的右边界，则这两个有重合，就不需要++一支箭，而且这里一个关键就是：把此时的第二个数组的右边界换成两数组交集的右边界，不然下一次判断如果是和上一个数组重合，那么还需判断是否和上上个数组重合。否则就是count++；  注意：排序过程不能用Arrays.sort( points,(a,b)→{return a-b;} ); 因为最近先加的测试用例差值太大。所以用Arrays.sort( points,(a,b) → Integer.compare(a,b) );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int findMinArrowShots(int[][] points) { if(points.length==0) return 0; Arrays.sort(points, (o1,o2) -\u0026gt; Integer.compare(o1[0],o2[0])); int count=1; for(int i=1;i\u0026lt;points.length;i++){ if(points[i][0]\u0026lt;=points[i-1][1]){ points[i][1]=Math.min(points[i][1],points[i-1][1]); }else count++; } return count; } }    435.无重叠区间 跟上一题类似，都是更新边界值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals,(a,b)-\u0026gt;{ if(a[0]==b[0]) return a[1]-b[1]; return a[0]-b[0]; }); int count=0; for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026lt;intervals[i-1][1]){ count++; intervals[i][1]=Math.min(intervals[i][1],intervals[i-1][1]);//更新右边界，避免反复比较死去的区间（右补集）  } } return count; } }    763.划分字母区间 思路：把每个字符最后出现的索引位置放在一个数组，如果在某个字符区间出现一个字符的右区间超过该字符的右区间，则刷新右区间，如果当前索引达到了右区间，就add，再把计数器归0；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public List\u0026lt;Integer\u0026gt; partitionLabels(String s) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); char[]ch=s.toCharArray(); int[] count= new int[26]; for(int i=0;i\u0026lt;s.length();i++){ count[ch[i]-\u0026#39;a\u0026#39;]=i; } int first=0,sum=1; //为什么额外定一个sum？因为first可能碰到这个情况：  //一个字符区间内的一个字符超出这个区间，那么 first 就变了，随之 last-first+1 的数值也变了。sum来计数是一个补救措施  for(int i=0;i\u0026lt;s.length();i++){ if(count[ch[first]-\u0026#39;a\u0026#39;]==i){ list.add(sum); first=i+1; sum=0;//初始化是1，这里是0因为后面也会++；  }else if(count[ch[i]-\u0026#39;a\u0026#39;]\u0026gt;count[ch[first]-\u0026#39;a\u0026#39;]){ first=i; } sum++; } return list; } }    56.合并区间 思路：先按边界排序，把其add到linkedlist中，然后每次都判断最后一个元素和当前循环到的节点是否有交集，如果有就把他们的并集顶替掉list中的最后那个元素，否则就add。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int[][] merge(int[][] intervals) { if(intervals.length\u0026lt;=1) return intervals; LinkedList\u0026lt;int[]\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); Arrays.sort(intervals,(a,b)-\u0026gt;{ // if(a[0]==b[0]) return a[1]-b[1];  return a[0]-b[0]; }); list.add(intervals[0]); int[] temp=new int[2]; for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026lt;=list.getLast()[1]){ temp=list.removeLast(); list.add(new int[]{Math.min(intervals[i][0],temp[0]),Math.max(temp[1],intervals[i][1])}); }else{ list.add(intervals[i]); } } return list.toArray(new int[list.size()][2]); } }    738.单调递增的数字 思路：先将其转换为字符数组，不要按数字来遍历，而是利用字符，如果4512，那么4499就是最大，规律就是，当前位置如果\u0026lt;上一位，即这两个位置非递增，那左边的应该-1，其右边全要变成9，因为全部要变9，所以先记录并更新最前变9的位置，最后一次性改变。但是必须将非递增的左边位置一直-1，不然比如332，会变成329，因为332中33两位置相等，右边的3并未更新为2，更新完了就可以了。\n注意：另外避免标识的last未使用误用导致错误（定义在【0，len-1】），或者太小(-1)导致越界，所以应将last定义为 ≥len 。\nString str = String.valueOf(任何类型); ：将任何类型转换为字符串类型；\nInteger.parseInt(字符串) ：字符串类型—\u0026gt;基本数据类型int\n类似的：Double.parseDouble(字符串)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int monotoneIncreasingDigits(int n) { String str = String.valueOf(n); char[]ch=str.toCharArray(); int last=ch.length; for(int i=ch.length-2;i\u0026gt;=0;i--){ if(ch[i+1]\u0026lt;ch[i]){ ch[i]--; last=i+1; } } for(int i=ch.length-1;i\u0026gt;=last;i--) ch[i]=\u0026#39;9\u0026#39;; return Integer.parseInt(String.valueOf(ch)); } }    714.买卖股票的最佳时机含手续费 主体思路都在注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int maxProfit(int[] prices, int fee) { int sum=0,buy=prices[0]+fee; for(int p:prices){ if(p\u0026gt;buy){ sum += p-buy;//交易状态中有fee会减掉（得到纯利润）。交易完成状态：是把上一次交易提高利润的情况下就不减掉fee；  buy = p;//交易状态：留出这次交易卖出价格以便下次可以在交易完成状态提高利润。  } if(p+fee\u0026lt;buy){//交易状态：如果买入比上一次买入便宜，就重新买入。 交易完成状态：  buy=p+fee; } } return sum; } }    968.监控二叉树 摆烂卒\u0026hellip;\u0026hellip;\n二刷见\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E8%B4%AA%E5%BF%83/","summary":"455.分发饼干 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count=0; for(int i=0,j=0;i\u0026lt;s.length \u0026amp;\u0026amp; j\u0026lt;g.length;i++){ if(s[i] \u0026gt;= g[j]){ count++; j++; } } return count; } } 376. 摆动序列 我的思路：直接改变数组比如4","title":"LeetCode 贪心"},{"content":"最近的生活 科目一一把过，科目二练完了。都忘了更新blog，学习状态很一般，一天大概4小时的集中学习时间，其他时间都在一些琐事，摆烂。\n最近的学习 代码随想录一刷结束。\n近期计划 7.26，7.27 两天迅速过完 操作系统 基础部分，再三天迅速过完 redis 基础。总之这个月结束这两门的基础部分。\n长期计划列表 redis、操作系统、JVM、并发、计网、设计模式。\n算法持续刷。\n","permalink":"https://coderrenxy.github.io/posts/life/july.no2-weekly-summary/","summary":"最近的生活 科目一一把过，科目二练完了。都忘了更新blog，学习状态很一般，一天大概4小时的集中学习时间，其他时间都在一些琐事，摆烂。 最近的学","title":"July No.2 Weekly Summary"},{"content":"最近的生活 6.28查到自己成绩，就知道稳稳的升本上岸了，随之而来的喜悦没有想象的那么多，而是更多对未来的焦虑，路比以前宽了，选择性更多导致不确定也越多了。\n报名了驾考，12号考科一，现在大概是被考试到疲倦了，总觉得自己必挂。\n最近的学习 知道升本成功，在5号正式出了预录取名单，也算是没停一直在刷题，现在终于刷到了动态规划，被动态规划狠狠的摩擦了，这段明明我在努力反复尝试他，打败它这段时间明明在努力，但感觉没有进度但是又有在努力，相当于一个缓冲期，这段时间更焦虑。\n这件事引出一个话题：关于焦虑，有一句话是这么说的：世界上最美妙最值得挑战却最让人胆怯的就是不确定性，焦虑正是对不确定的恐惧。\n关于焦虑 其实我一直在焦虑，只是一直在换焦虑的目标，容貌焦虑，对未来的焦虑，对任何主观问题或者不确定性都焦虑，而每每这个时刻来临，我选择摆烂，有时候我也选择过去面对，但是还没坚持到有所研究，就走出来了，然后是周而复始的 焦虑\u0026ndash;\u0026gt;摆烂\u0026ndash;\u0026gt;走出焦虑\n很难去真正看一些相关的书去和它“握手”，我知道适度的焦虑可以带给我进步，而过度焦虑会造成精神内耗。但任何事情不都是这个度掌握不了吗。\n近期计划 本月做完动态规划，完成代码随想录一刷，考过科一。\n暑假计划 计网、操作系统、Redis、并发、JVM 学点皮毛，为以后深入学习打基础，并二刷代码随想录。\n","permalink":"https://coderrenxy.github.io/posts/life/july.no1-weekly-summary/","summary":"最近的生活 6.28查到自己成绩，就知道稳稳的升本上岸了，随之而来的喜悦没有想象的那么多，而是更多对未来的焦虑，路比以前宽了，选择性更多导致不","title":"July No.1 Weekly Summary"},{"content":"最近 没更新的两个月一直在准备升本，复习，写题，考试。\n考完之后一直在焦虑万一没考上怎么办，其实并没必要，没考上立马出去找工作就行了，挂个成人本科，准备专升硕，没上岸就等2.5年后本科证下来再考研，不要985、211，只要上岸摆脱专科学历我就知足，年龄大也没办法，专科身份毕竟难走远， 我也不是什么技术强到炸裂的大牛。\n说回根本我焦虑的起因是想得太长远，没出分数怕自己考的差，出了分怕自己没被录取，考上了又要拼死学几年而且又得伸手问家里要钱，没考上压力大，进入社会并没有准备好。\n考上后计划 1刷代码随想录 \u0026ndash;\u0026gt; 边二刷边学计网 \u0026ndash;\u0026gt; 边二刷边学操作系统 \u0026ndash;\u0026gt; 边二刷边学redis \u0026ndash;\u0026gt; 边二刷边学JVM、多线程、设计模式 \u0026ndash;\u0026gt; 边刷题边做项目\n落榜后计划 去深圳找工作 \u0026ndash;\u0026gt; 边学上面的东西边工作（很辛苦）\n总结 其实两种都有好处，现在的心态在学校也不适合，在学校也会课太多不适合学习，出来攒两年经验升硕毕业，硕士毕业两年工作经验直接无敌。还能攒点钱自己交学费，但是很辛苦。又要学专业课又要学考研课，各种没学过的高数、政治、计组。\n直接升本再出来工资可能能翻专科出来2-3倍，而且没有后续的考研压力。直接面对生活，也不赖。\n","permalink":"https://coderrenxy.github.io/posts/life/6%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近 没更新的两个月一直在准备升本，复习，写题，考试。 考完之后一直在焦虑万一没考上怎么办，其实并没必要，没考上立马出去找工作就行了，挂个成人本","title":"6月总结"},{"content":"77. 组合 思路：分为终止条件、单层逻辑两层。\n 终止条件：当长度为 k 就 new 这个 List 并 add 进去并 return。 单层逻辑：for 嵌套 add、递归、remove。  question：\n 为什么要 for：如果没有，找到第一个符合条件的组合就层层 remove 了。 for 的结束条件控制的是什么：控制当前层的可选个数。i \u0026lt; n - (k - path.size()) + 1 可以当作 i \u0026lt; n - k + 1看待，在第一层可选择的个数就是 n-k+1，因为考虑到后面要跟元素，所以要留 k-1 个位置，第二层要为下一层留位置，所以可选项反而多了，预留 k-2个位置就行，可选项为 n-(k-1)+1。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { if(k \u0026gt; n) return null; dfs(1,n,k); return list; } public void dfs(int start,int n,int k){// n 个里面取 k 个  //终止条件  if(k == path.size()){//层数/深度限定在此  list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(; start \u0026lt;= n-(k-path.size())+1; start++){//循环才能出多个结果，不然直接找到就remove多层。  path.add(start); dfs(start+1,n,k); path.remove(path.size()-1); } return; } }    216.组合总和III 思路：回溯做法，集合就是 1-9 九个数字里面取，递归终止条件是 size == k \u0026amp;\u0026amp; sum == n\n注意：一定要加一个 if（sum\u0026gt;n || path.size()\u0026gt;k）return; 不然会超时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { if(k\u0026gt;n) return list; dfs(1,k,n,0); return list; } public void dfs(int start,int k,int n,int sum){ if(sum == n \u0026amp;\u0026amp; k == path.size()){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } if(sum \u0026gt;= n || k \u0026lt;= path.size()) return; for(;start\u0026lt;=9-(k-path.size())+1;start++){ sum += start; path.add(start); dfs(start+1,k,n,sum); sum -= start; path.remove(path.size()-1); } return; } }    17.电话号码的字母组合 思路：递归层数（深度）就是号码字符串长度，递归层度由递归终止条件控制，for 循环控制的次数是当前号码字符串中数字对应的字母映射。把一个数组的 index 和 content 作为 号码数字 和 字母的映射。用到 Stringbuilder、charAt、deleteCharAt、toString、append.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String nums[] = {\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;,\u0026#34;pqrs\u0026#34;,\u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;}; StringBuilder sb = new StringBuilder(); public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if(digits.length() == 0 || digits == null) return list; backTracking(digits,0); return list; } public void backTracking(String digits,int index){ //深度由递归终止条件控制  if(sb.length() == digits.length()){ list.add(sb.toString()); return; } for(int i=0;i\u0026lt;nums[digits.charAt(index)-\u0026#39;0\u0026#39;].length();i++){ sb.append(nums[digits.charAt(index)-\u0026#39;0\u0026#39;].charAt(i)); backTracking(digits,index+1); sb.deleteCharAt(sb.length()-1); } return; } }    39. 组合总和 莽夫思路：直接回溯。\n优化思路：先排序，在 for 中 add 之前判断如果要 add的数 + sum \u0026gt; target，就 break，因为后面只会越来越大。\n注意：循环条件赋初值给上次用完的数，这样就是把上次用的重复用了，如果赋初值为 0，那么会出现同一个组合的不同排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int sum = 0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); if(candidates == null || candidates.length == 0) return list; getPaths(candidates,target,0); return list; } public void getPaths(int[] candidates, int target,int index){ //终止条件  if(sum == target){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(int i=index;i\u0026lt;candidates.length;i++){ if(sum + candidates[i] \u0026gt; target) break; path.add(candidates[i]); sum += candidates[i]; getPaths(candidates,target,i); path.remove(path.size()-1); sum -= candidates[i]; } return; } }    40.组合总和II 思路：和39差的就是要去重，这里的去重指的是同一递归层的去重，绝不能和其他层关联，否则会少结果集。\n注意：千万不要把去重的 if 里的 i\u0026gt;index 写作 i\u0026gt;0，这样只会保证不越界，但是每次都会把两层之间的数去重，而 i\u0026gt;index 则恰好不越界不影响其他层。还有传入递归的 index 位置的不是 index+1，而是 i+1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int sum = 0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { if(candidates == null || candidates.length == 0) return list; Arrays.sort(candidates); getPaths(candidates,target,0); return list; } public void getPaths(int[] candidates, int target,int index){ //结束条件  if(target == sum){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(int i=index;i\u0026lt;candidates.length \u0026amp;\u0026amp; sum + candidates[i] \u0026lt;= target;i++){ if(i \u0026gt; index \u0026amp;\u0026amp; candidates[i-1] == candidates[i]) continue; path.add(candidates[i]); sum += candidates[i]; getPaths(candidates,target,i+1); path.remove(path.size()-1); sum -= candidates[i]; } return; } }    131.分割回文串 思路：\n 写出判断回文串的方法（把字符串，首尾切割位置传过去最优）。 递归单层逻辑：外层 for 循环囊括所有可能第一切割位置、第n次切割位置，递归切下去，如果是回文串就 add 否则 continue以确保每个 add 的都是回文串。 终止条件：当切割起始位置 index == 长度（末尾索引+1）  代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { backTracking(s,0); return list; } public void backTracking(String s,int begin){ if(begin == s.length()){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); return; } for(int i=begin;i\u0026lt;s.length();i++){ if(isPalindrome(s,begin,i)) listSon.add(s.substring(begin,i+1)); else continue; backTracking(s,i+1); listSon.remove(listSon.size()-1); } return; } public boolean isPalindrome(String s,int begin,int end){ for(int i=begin,j=end;i\u0026lt;j;i++,j--) if(s.charAt(i)!=s.charAt(j)) return false; return true; } }    93.复原IP地址 这题主要是\u0026quot;.\u0026quot;、如何确保是四串，这两个问题可以合成一个，就是通过\u0026quot;.\u0026ldquo;的数量来知道是否已经4串。\n还有就是：怎么才是合法的串？0不能开头，除非它是一个独立的0，范围要在0-255，而且只能是数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Solution { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { if(s.length() \u0026gt; 12) return result; backTrack(s,0,0); return result; } public void backTrack(String s,int startIndex,int pointNum){ if(pointNum == 3){ //.的个数  if(isValid(s,startIndex,s.length()-1)) {result.add(s);} return; } for(int i=startIndex;i\u0026lt;s.length()-3+pointNum;i++){ if(isValid(s,startIndex,i)){ s = s.substring(0,i+1)+\u0026#34;.\u0026#34;+s.substring(i+1); pointNum++; backTrack(s,i+2,pointNum); s = s.substring(0,i+1)+s.substring(i+2); pointNum--; } else {break;} } } public Boolean isValid(String s,int begin,int end){ if(begin \u0026gt; end) return false; int num = 0; if(s.charAt(begin) == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; begin != end) return false;//0不能开头，可当一个数字单独存在；  for(int i=begin;i\u0026lt;=end;i++){ if(s.charAt(i)\u0026gt;\u0026#39;9\u0026#39; || s.charAt(i)\u0026lt;\u0026#39;0\u0026#39;) return false; num = (s.charAt(i)-\u0026#39;0\u0026#39;)+num*10; if(num \u0026gt; 255) return false; } return true; } }    78.子集 主要是每一次进回溯都new一个List，反正集合没有重复元素，正常回溯足够解题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backTrack(nums,0); return list; } public void backTrack(int nums[],int begin){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); for(int i=begin;i\u0026lt;nums.length;i++){ listSon.add(nums[i]); backTrack(nums,i+1); listSon.remove(listSon.size()-1); } return; } }    90.子集II 跟上一个子集差别就是List\u0026lt;List\u0026gt;去重以及还有一个在用nums前先sort，因为乱序可能导致[1,4] 和 [4,1] 无法去重。比如nums={4，1，4}，就会出现这种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); backTrack(nums,0); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(List i:set) list.add(i); return list; } public void backTrack(int[] nums,int begin){ set.add(new ArrayList\u0026lt;\u0026gt;(listSon)); for(int i=begin;i\u0026lt;nums.length;i++){ listSon.add(nums[i]); backTrack(nums,i+1); listSon.remove(listSon.size()-1); } return; } }    46.全排列 主要是每次从0开始，用LinkedList作子list方便使用contains方法，当子list包含该元素时就continue，否则就正常回溯。或者用used数组来标识是否已经存在当前元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; listSon = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { backTrack(nums); return list; } public void backTrack(int[] nums){ if(nums.length == listSon.size()){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); return; } for(int i=0;i\u0026lt;nums.length;i++){ if(listSon.contains(nums[i])) continue; listSon.add(nums[i]); backTrack(nums); listSon.remove(listSon.size()-1); } } }    47.全排列 II 和 全排列I 一样的处理逻辑，但是用used数组做，因为有重复元素，数组只看下标是否被使用，而contains看包不包含这个元素值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); boolean[] used; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { if(nums.length == 0) return null; used = new boolean[nums.length]; backTrack(nums); return new ArrayList\u0026lt;\u0026gt;(set); } public void backTrack(int[] nums){ if(list.size() == nums.length){ set.add(new ArrayList\u0026lt;\u0026gt;(list)); return; } for(int i=0;i\u0026lt;nums.length;i++){ if(used[i]) continue; used[i] = true; list.add(nums[i]); backTrack(nums); list.remove(list.size()-1); used[i] = false; } } }    图论 hard 332.重新安排行程 \u0026amp;\u0026amp; 37. 解数独 \u0026amp;\u0026amp; 第51题. N皇后\n不太清楚图，不大理解题意。卒\u0026hellip;\u0026hellip;\n 持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%9B%9E%E6%BA%AF/","summary":"77. 组合 思路：分为终止条件、单层逻辑两层。 终止条件：当长度为 k 就 new 这个 List 并 add 进去并 return。 单层逻辑：for 嵌套 add、递归、remove","title":"LeetCode 回溯"},{"content":"抽象类 抽象类是特殊的类，只是不能被实例化，天生就是要被继承的；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们 抽象方法必须用abstract关键字进行修饰。\n抽象类的特点  不能被直接实现，只能先被继承再间接实现。 子类必须实现父类的抽象方法，除非子类也是抽象类。 其中的方法只能是被 public（默认）、protected 声明。 含有抽象方法一定是抽象类，但抽象类不一定含有抽象方法。  接口 接口其实也是一种抽象，比抽象更抽象，其中的方法被隐式的指定为了 abstract 就有体现，接口是对行为的抽象。在 JDK1.8 前都是不能有任何具体方法实现，所以其中是抽象方法。\n接口的特点  支持多继承，一个接口可以 extends 多个接口，间接解决了 Java 单继承的问题。 一个类可以实现多个接口。 接口中的变量被隐式的指定为了public static final，方法隐式指定为public abstract（JDK1.8之前）。 JDK1.8 之前不能有静态方法和具体实现的方法，但是 JDK1.8 开始就可以有静态方法和具体的实现方法（默认方法 default）。 JDK1.8 后 static 可以单独修饰一个方法，也就是接口静态方法，接口名.方法名() 调用。  业务场景下的选择  如果使用接口的业务下，需要不断改变基本功能，那么就需要改变所有实现了该接口的类，但如果使用抽象类，可以达到解耦目的，因为 抽象类定义你是什么，接口定义你能做什么。 如果想实现多继承，那么必须使用接口。由于Java不支持多继承，即一个类 只能有一个超（父）类。但是，可以实现多个接口，因此可以使用接口来解决它。  版本变化 Java语言的版本升级过程中，接口和抽象类都有了一些变化。以下是主要的一些变化：\n  默认方法（default method）：从Java 8开始，接口可以定义默认方法，也称为扩展方法或带有默认实现的方法。这些方法具有默认的实现代码，可以被接口的所有实现类共享。默认方法可以通过在接口中使用default关键字来定义，实现类可以选择性地重写默认方法。\n  静态方法（static method）：从Java 8开始，接口可以定义静态方法。这些方法与类的静态方法类似，不依赖于接口的实现类，可以直接通过接口名调用。\n  私有方法（private method）：从Java 9开始，接口可以定义私有方法。这些方法只能在接口内部调用，无法被实现类或其他类调用。\n  非抽象方法（non-abstract method）：从Java 9开始，抽象类可以定义非抽象方法。这些方法可以有具体的实现代码，不再需要在子类中实现。\n   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"抽象类 抽象类是特殊的类，只是不能被实例化，天生就是要被继承的；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的","title":"接口和抽象的区别"},{"content":"我的进度 已完成 Spring \u0026mdash;\u0026mdash;-\u0026gt; Mybatis \u0026mdash;\u0026mdash;-\u0026gt; Spring MVC \u0026mdash;\u0026mdash;-\u0026gt; 异常 \u0026mdash;\u0026mdash;-\u0026gt; Java基础 \u0026mdash;\u0026mdash;-\u0026gt; 集合 \u0026mdash;\u0026mdash;-\u0026gt; 进行中 MySQL\n待完成  \u0026mdash;\u0026mdash;-\u0026gt; Redis \u0026mdash;\u0026mdash;-\u0026gt; 计网、操作系统、多线程\n","permalink":"https://coderrenxy.github.io/posts/life/%E5%87%86%E5%A4%87%E8%BF%9B%E5%BA%A6/","summary":"我的进度 已完成 Spring \u0026mdash;\u0026mdash;-\u0026gt; Mybatis \u0026mdash;\u0026mdash;-\u0026gt; Spring MVC \u0026mdash;\u0026mdash;-\u0026gt; 异常 \u0026mdash;\u0026mdash;-\u0026gt; Java基础 \u0026mdash;\u0026mdash;-\u0026gt; 集合 \u0026mdash;\u0026mdash;-\u0026gt; 进行中 MySQL 待完成 \u0026mdash;\u0026mdash;-\u0026gt; Redis \u0026mdash;\u0026mdash;-\u0026gt; 计网、操作系统、多线程","title":"进度"},{"content":"前言 每个人都有适合自己的作息，不用随大流，找到自己的生活、学习节奏就好。\n第一更 我的一天 第一次找到不用依靠外界环境逼迫性学习的时间规律是：23点-次日5点学习，一觉睡到13点，躺着刷会手机就15点，然后慵懒的起床吃饭，这里有个习惯就是，一定是看剧下饭！\n白天总是不想学习，在晚上昏暗、安静、手机不可能弹出会话框的时候是最适合我的学习时间。\n再之后就是回到学校，不能再阴间作息于是逼迫自己白天学习，晚上摆烂+睡觉，出现很严重的效率问题：静不下来。\n对我来说，白天很难学下去，白天的学习只能有外界压迫。但是最近发现一件事：刚起床那会很容易进状态，只要起床不看手机不刷快餐短视频，一天的节奏还没有被加速。\n所以我现在每天起床，什么都不管不干，只学习，学到吃午饭就是分水岭了，午饭一吃，心思全无，状态低迷，什么都没有心思一样，等天暗下去慢慢就好了。\n我的期望 找到办法让自己白天能更好的进入状态。\n我的进度 准备面试中\u0026hellip;\u0026hellip;\n第二更 新的节奏 其实是走了实习休息期的老路：晚上学习，白天睡觉，实在改变不了一到下午疯狂焦虑、内耗，所以只能适配自己。\n中午醒来的仍然是学习状态好的时候，然后一过19：00（昼长夜短的夏天），又是好的状态。效率指数倍提升。\n可以尝试的方法 因为醒来比较适合学习，如果一定要规律白天学习的作息，可以中午睡午觉，一觉起来在学习，可能可以解决焦躁的问题。\n但是本人白天睡觉一醒来就emmm\u0026hellip;总之感觉很不好，而且午睡不能太长，睡眠浅导致醒来没有好的学习状态。所以一直没尝试。\n","permalink":"https://coderrenxy.github.io/posts/life/%E4%BD%9C%E6%81%AF%E6%90%AD%E9%85%8D/","summary":"前言 每个人都有适合自己的作息，不用随大流，找到自己的生活、学习节奏就好。 第一更 我的一天 第一次找到不用依靠外界环境逼迫性学习的时间规律是：23","title":"作息搭配"},{"content":"\nMybatis是什么 Mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC、加载驱动、创建连接、创建statement等一系列与数据库交互的繁杂步骤。\n Mybatis优缺点 优点\n 灵活，sql写在xml中与程序代码解耦，便于统一管理，支持动态sql，并可重用。 与JDBC相比，减少了至少50%的代码量，消除了JDBC大量冗余代码，不需要手动开关连接。 与各种数据库兼容。（因为内部封装了JDBC，所以JDBC支持的所有数据库都和Mybatis兼容） 与Spring能够很好的集成。  缺点\n SQL语句编写工作量大，尤其字段多，关联表多时对开发人员编写SQL功底有一定要求。 SQL语句依赖数据库，导致数据库可移植性差，不能随意更换数据库。   JDBC：是一个用于执行SQL的Java API，可为多种关系型数据库提供统一访问。\n Hibernate特点 是一个ORM（Object Relation Mapping：对象关系映射）框架，只需要操作对象，处理好了映射关系后不怎么需要操作数据库。但是缺点有：\n Hibernate的完全封装导致无法使用数据的一些功能。 对代码的耦合度高。 找bug难，因为封装完美。 批量操作数据需要大量内存空间而且执行过程对象太多。   Mybatis的使用 mybatis-config略过，写一个dao接口但是不用实现，在对应的xml文件写sql，创建一个实体类对应xml中的字段，在mapper.xml中namespace就是对应dao的路径，mapper文件里面写sql语句、resultType、id等参数。 在mapper.xml中sql里面 #{name}的字段是由上层（service层）对实体类对象调用setName方法传进来的，实体类做一个中转站。\n在使用Mybatis时，时常实体类属性名和表字段名不匹配，那我们就封装一个结果集，如果能一一对应，系统就相当于自动封装了一个结果集。也可以as取别名。\n 动态 sql 小问题 动态sql在本人工作过程中使用出现的问题：\u0026lt;if xx != null\u0026gt;内一直把and或or写在句尾，但是最后一个为null时，上一个 if 末尾的 and 或 or 会导致报错。\n解决方法：在整体 if 外嵌套一个 where 标签会自动去除所有 if 语句的整体的开头的 and 或 or，但是注意必须写在开头而不是像未使用 where 标签时一样写在末尾。\n sqlSession：与数据库的会话\n 一些属性 flushCache：用来表示当前sql语句的结果是否进入二级缓存;\nstatementType：用于选择执行sql语句的方式\n statement：最基本的jdbc操作，用来表示一个sql语句，不能防止sql注入。 prepared：采用预编译方式，能防止sql注入，设置参数的时候需要该对象来进行设置。 callback：调用存储过程。  resultType：用的不多，因为只能返回一个实体类的类型，多数使用reslutMap自定义结果集\n 预编译 预编译定义：SQL预编译指的是数据库驱动在发送SQL语句和参数给DBMS之前对SQL语句进行编译，这样DBMS执行SQL时，就不需要重新编译。\n为什么需要预编译：预编译阶段可以优化SQL的执行。预编译之后的SQL多数情况下可以直接执行，DBMS不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。\n #{}与${}的区别   #{}的处理方式使用了参数预编译，被解析为一个参数占位符 。\n获取数据：使用 #{} 获取必须用对象的属性名，多个参数时用arg0、arg1\u0026hellip;..原因是mybatis在传入多个参数时，会将这些参数的结果封装到map结构中，在map中key就是{arg0，arg1\u0026hellip;.}。如果想使用参数别名，可以用@param(\u0026ldquo;别名\u0026rdquo;) Integer empAge在dao的interface中。\n  ${}是直接拼接 sql语句得到对应的 sql语句，仅仅为一个纯碎的 string 替换，会有 sql注入的危险，所以推荐 #{}的方式。\n${}的使用场景：动态传入表名，order by ${列名}。注意：这是动态传值，所以必须用 @param。\n注意：sql注入：传入的参数始终为true，密码验证就无效了。\n   Mybatis缓存机制  一级缓存：表示sqlSession级别的缓存，每次查询的时候会开启一个会话，此会话相当于一次连接，该连接关闭之后对应的一级缓存自动失效。 二级缓存：全局范围内的缓存，sqlSession关闭之后才会生效。 第三方缓存：继承第三方的组件，来充当缓存的作用。    一级缓存：表示将数据存储在sqlSession中，关闭之后自动失效，默认情况下是开启的。在同一个会话之内，如果执行了多个相同的sql语句，那么除了第一个之外，所有的数据都是从缓存中进行查询的。在某些情况下一级缓存可能失效？\n 在同一个方法中，可能开启多个会话，此时注意，会话和方法没有关系，不是一个方法就只有一个会话，所以严格记住，缓存的数据是保存在sqlSession中的 。 当传递同一个对象但是对象属性值不同也不会走缓存。 在同一个连接中，如果修改了数据，那么缓存会失效，不同连接不受影响。 在一个会话过程，手动清除缓存，也会失效。    二级缓存：全局缓存，必须等到sqlSession关闭之后才会生效。默认不开启，如果开启需要如下设置。\n 修改全局配置文件，在setting中添加 \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; 指定在哪个映射文件中使用缓存的配置：加上 \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt;。 对应的Java实体类必须实现序列化接口。    二级缓存属性：\n eviction：缓存淘汰机制：  LRU（默认）：最近最少使用。 FIFO：先进先出，按照添加缓存的顺序执行。 SOFT：软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK：弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。   flushInterval：设置多长时间进行缓存刷新 size：引用的条数，是一个正整数，缓存中可以存储多少个对象，一般不设置，如果设置的话不要太大，会导致内存溢出。 readonly：只读属性  true：只读缓存，会给所有的调用方法返回该对象的实例，不安全。 false：读写缓存，只是返回缓存对象的拷贝，比较安全。    一二级缓存会不会同时存在数据?\n不会，一级缓存存在sqlSession，二级缓存是全局缓存，必须等到sqlSession关闭之后才会生效。 查询数据时，先查询一级缓存，还是二级缓存？\n二级缓存 \u0026ndash;\u0026gt; 一级缓存 \u0026ndash;\u0026gt; 数据库\n   Mybatis工作原理 工作原理如下： 大致分为：读取配置文件、解析Mapper配置文件、创建SqlSession、执行SQL语句、处理结果集和关闭SqlSession\nMybatis分页方式 逻辑分页：使用Mybatis自带的RowBounds进行分页，他会一次性的查出多条数据，然后检索分页中的数据，具体一次查出多少条数据，由封装的JDBC的fetch-size决定。\n物理分页：大家都在用的分页方式，一般用的是pagerHelper实现的就是物理分页。\n Mybatis的Executor执行器 Mybatis有三种基本的Executor执行器，都作用在SqlSession生命周期范围内。\n SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map\u0026lt;String, Statement\u0026gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。    持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/mybatis/","summary":"Mybatis是什么 Mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC、加载驱动、创建连接、创建statement等一系列","title":"Mybatis"},{"content":"关于我 英文名： 暂无 职业： 程序员 运动： 跑步、乒乓球、羽毛球、游泳、足球、篮球、桌球、排球、跳绳\n","permalink":"https://coderrenxy.github.io/about/","summary":"关于我 英文名： 暂无 职业： 程序员 运动： 跑步、乒乓球、羽毛球、游泳、足球、篮球、桌球、排球、跳绳","title":"🙋🏻‍♂️关于"},{"content":"Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 [) 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n Tuesday 654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if \u0026hellip; else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left \u0026gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\nWednesday 617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略\u0026hellip;\u0026hellip;\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子\u0026hellip;\u0026hellip;.）、右子树的最左后代是值最接近根节点的结点。\n Thursday 501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List\u0026lt;TreeNode\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;TreeNode\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; i\u0026lt;list1.size(); i++){ for(int j=0; j\u0026lt;list2.size(); j++){ if(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List\u0026lt;TreeNode\u0026gt; list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026amp;\u0026amp; right != null) return root; if(left != null \u0026amp;\u0026amp; right == null) return left; if(left == null \u0026amp;\u0026amp; right != null) return right; return null; } }     Friday 235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7 8  class Solution { TreeNode node = null; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val \u0026gt; p.val \u0026amp;\u0026amp; root.val \u0026gt; q.val) return lowestCommonAncestor(root.left , p, q); if(root.val \u0026lt; p.val \u0026amp;\u0026amp; root.val \u0026lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val \u0026gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 \u0026gt; \\ \u0026lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。\n1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val \u0026gt; root.val) root.right = insertIntoBST(root.right, val); if(val \u0026lt; root.val) root.left = insertIntoBST(root.left , val); return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val \u0026gt; key) root.left = deleteNode1(root.left , key); if(root.val \u0026lt; key) root.right = deleteNode1(root.right, key); if(root.val == key){ if(root.right != null \u0026amp;\u0026amp; root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026amp;\u0026amp; root.left == null){ return root.right; }else if(root.right == null \u0026amp;\u0026amp; root.left != null){ return root.left; }else{ return null; } } return root; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/","summary":"Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后","title":"LeetCode 一周小记 No.5"},{"content":"Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n Tuesday 429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg\u0026hellip;..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..\n Wednesday 226.翻转二叉树 递归：确定参数类型、返回值 —\u0026gt; 确定终止条件 —\u0026gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026amp;\u0026amp;。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n Thursday 110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n Friday 113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n 持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/","summary":"Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +","title":"LeetCode 一周小记 No.4"},{"content":"Monday 18.四数之和 思路 ：就是昨天三数之和多了一个 for 循环。 注意 ：if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;}\n 这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 。 还有就是 \u0026gt; target \u0026lt; target == target 绝对 if\u0026hellip;else 而不是单独的多个 if 。  344. 反转字符串 双指针做法\n541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字符 。\n判断条件没有很复杂,就是拿到的个数 \u0026gt; k 就操作反转前 k 个, \u0026lt; k 直接全反转。\n就是 ≥2k 和 2k ≥ len ≥ k ,两个区间都是用一操作,融合了。\n剑指Offer 05.替换空格 注意 : 只有 String 转换为了 StringBuffer or StringBuilder 才能用 append \u0026amp;\u0026amp; toString 方法。\n151. 翻转字符串里的单词 大体思路：先全部反转、再依次反转各个 word。\n记住几个 API ： charAt、setChatAt，操作 String 先转换成 StringBuilder or StringBuffer 再操作。\n注意要移除开头结尾的 space、word 间连续的 space。\n其中去除连续的 space 注意判断条件 当前 char != space || sb最后一个 char 不为 space（上一个 char 不为 space），两个判断条件反了会短路。\nTuesday 剑指Offer58-II.左旋转字符串 思路：把 n 后面的先 append 到 new 的 sb 上，再把 n 之前的 append 到 sb 。\n28. 实现 strStr() KMP原理：通过前缀表记录每个对应字符串下的每个相同前后缀的长度（即：免匹配的子串的下一位置 index ），当模式串和原文匹配中断时直接跳到上一字符的前缀表位置对应前缀表内容对应的模式串位置。so，实现分为两块：匹配、更新前缀表。\nKMP实现：目前还只能通过印象 + 实践调 bug得出，并不能很好的理解代码，等刷完动态规划回来二刷再看。\n459. 重复的子字符串 KMP卒，二刷见\u0026hellip;\u0026hellip;\u0026hellip;.\nWednesday day 13 232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内元素全 pop 到出栈的栈中。\n225. 用队列实现栈 思路：一个队列用于暂存、一个用于操作，和两个栈实现一个队列不大相同。\n注意：API ：poll 相当于 pop、offer 相当于 push、其他不变。\n20. 有效的括号 思路：遇见左括号就 push 右括号，否则就看栈是否提前空了、栈顶元素匹配当前括号，否则就 pop。\n栈提前空了会导致后面就算有没匹配上的括号，最后 return 的依然是 true 。\n注意：在匹配栈顶元素时，切记不要用 pop，而是用 peek，否则比较一次 少一个栈顶元素就导致空栈异常。\n1047. 删除字符串中的所有相邻重复项 思路：栈为空 or 匹配栈顶元素为 flase 就 stack.push( )，sb.append( )，否则就是匹配成功 就直接 stack.pop( )，sb.deleteCharAt( sb.length( )-1 )\n150. 逆波兰表达式求值 150. 逆波兰表达式求值 Tips：与本题无关 ：数字（int）转字符（char）要强转( char ) ( 0 + ’ 0 ’ )，字符转数字隐式就可以了不用声明出来 ‘ 2 ’ - ’ 0 ’ ，但是为了书写统一，还是都强转一下。\nAPI：Integer.valueOf( str );\n思路：拿到每一个数组索引下的字符串去比较，是运算就 pop 出两个元素运算并 push 结果，否则直接 push。\nThursday 239. 滑动窗口最大值 思路：自己用双端队列实现一个队列，add 方法来保证单调（队头始终为最大值），poll 方法保证窗口的滑动。每次取队头给记录窗口最大值的数组赋值就行了。如何设计 add 、poll ？\nadd：一直比较队尾，如果小于要 add 的 val，就杀掉这个队尾，直到上一个元素大于 val，此时 add 这个 val。\npoll：拿到窗口最后一个值与队头（最大值）去比较，如果相等，就杀死队头，因为这个本该从滑动窗口走出的元素影响最大值的判断了。否则就不操作。\n注意： Deque 双端队列才可以取队尾（getLast（ ）、removeLast（ ）），Queue 单端队列不可以。\nDeque 双端队列中，add（）才是在队尾添加元素。\npeek、poll 必须保证队列不为空。\n347.前 K 个高频元素 大小顶堆：卒\u0026hellip;\u0026hellip;\nFriday 二叉树的深度优先遍历 (知识填充) 前置知识填充：\n满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。\n完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。\n二叉搜索树：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。\n平衡二叉搜索树（AVL）：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。\n二叉树的存储：\n二叉树可以链式存储，也可以顺序存储。\n链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。\n如果父节点的数组下标是 i，那么它的左孩子就是 i × 2 + 1，右孩子就是 i × 2 + 2。\n二叉树的遍历：\n 深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。 广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）  144.二叉树的前序遍历 \u0026amp; 145.二叉树的后序遍历 \u0026amp; 94.二叉树的中序遍历 递归做法：三个遍历一个方法代码挪一下位置。\n迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.3/","summary":"Monday 18.四数之和 思路 ：就是昨天三数之和多了一个 for 循环。 注意 ：if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;} 这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 。 还有就是 \u0026gt; target \u0026lt; target == target 绝对","title":"LeetCode 一周小记 No.3"},{"content":"​ 集合的概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。\n和数组的区别：\n 数组长度固定，集合长度不固定。 数组可以存储基本数据类型、引用数据类型，集合只能存储引用数据类型。所以看到的 Map都是 Map\u0026lt;Integer,Integer\u0026gt;，而不是 Map\u0026lt;int,int\u0026gt; 。 相比于集合，数组没有删除方法，开辟连续空间。   Collection体系下两个接口 List接口 List 特点：有序、有下标、元素可重复。\nList 实现类： ArrayList、LinkedList、Vector。\n ArrayList：是一个古老的实现类，底层是 Object[] ，vector 底层也是一样，线程不安全，容量是动态的、但是牺牲效率，DEFAULT_CAPACITY = 10; 默认容量为10；若未添加元素，容量 0；扩容每次是原来的1.5倍，下文详解。ArrayList.add() 不带索引则默认从 0 开始。 Vector、ArrayList：都是数组结构实现，但是 Vector 是线程安全的，ArrayList 线程不安全，而 LinkedList 是链表结构实现。笼统来说，ArrayList 查询快、插入慢， LinkedList 查询慢、插入快，因为 ArrayList 要把插入位后面的值全都后移一位，但是有特殊情况，下文详解。 LinkedList ：存储结构为双向链表。 无需开辟连续空间，查询慢，增删快。具体下文再比较效率 。   注意：ArrayList 是并发不安全的，vector 是线程安全的。\n解决 ArrayList 线程安全问题的方法有：Collections.synchronizedList、CopyOnWriteArrayList。  ArrayList、LinkedList 比较  ArrayList 底层基于数组实现，LinkedList 底层基于链表实现，确切的说是循环双向链表（JDK 1.7 之前是双向循环链表、JDK 1.7 开始取消了循环），LinkedList 链表由一系列表项连接而成， 一个表项包含 3 个部分：元素内容、前驱表、后驱表。LinkedList 链表内部还有一个 header 表项，既是链表的开始也是链表的结尾。header 的后继表项是链表中的第一个元素，header 的前驱表项是链表中的最后一个元素。\nArrayList 的增删未必比 LinkedList 慢：\n1. 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。 数据量达到百万级的时，速度是会比 LinkedList 要快的。\n2. 删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上， ArrayList 的消耗主要是在移动和复制上（底层调用的是 arrayCopy() 方法，是本地方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度， 数据量达到百万级的时，还是 ArrayList 要快。\nArrayList 扩容 起初 empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当使用 add 方法的时候首先调用 ensureCapacityInternal 方法， 源码中的 Capacity 是容量，size 是当前the number of elements it contains（当前包含的元素数）， 传入 size+1 进去，检查是否需要扩充 elementData 数组的大小，再传入值；具体扩容过程如下（不拿 add（） 的重载举例）：\n1 2 3 4 5  public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; }   若 add() 第一个元素，则传入 DEFAULT_CAPACITY = 10，默认容量为10，注意很多博主讲到扩容，minCapacity 、newCapacity、oldCapacity、size 名词组合拳就把人整晕了，其实传入的 size+1 就是 ensureCapacityInternal 方法中的 minCapacity。\n1 2 3  private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); }   可以看到判断扩容的方法里调用了ensureExplicitCapacity和 calculateCapacity ，方法体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   calculateCapacity 方法传入 elementData （即当前存 “元素数据引用” 的地址）, minCapacity（即size+1），意思当第一次调用add(E e)方法的时候， 判断是不是无参构造函数创建的对象，如果是， 将 DEFAULT_CAPACITY 即 10 作为 ArrayList 的容量，此时 minCapacity = 1。返回的容量作为ensureExplicitCapacity的参数传入， 此时 modCount++；是fail-fast iterators 相关，先不用管，而 DataElement 是现在用于存储的数组，当 size+1 大于这个值，意味着要扩容了，然后调用grow（）方法扩容 ：\n1 2 3 4 5 6 7 8 9 10 11  private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   其中 oldCapacity 是原来的容量大小，oldCapacity \u0026raquo; 1 为位运算的右移操作，右移一位相当于除以 2，所以这句代码就等于 int newCapacity = oldCapacity + oldCapacity / 2；\nnewCapacity = 扩充数组为原来的 1.5 倍(不能自定义)，然后判断 minCapacity 是否大于MAX_ARRAY_SIZE(Integer.MAX_VALUE – 8) ，如果大于数组最大容量，就取 Integer.MAX_VALUE；后回到 grow（）方法，调用 Arrays.copyof 方法， 即复制原数组内容到一个新容量的大数组里。这里Arrays.copyof 方法实际是调用 System.arraycopy方法。\n与 Vector 不同的是，Vector 每次扩容容量是翻倍，即为原来的 2倍，而 ArrayList 是 1.5倍。看似 1.5倍增长的很慢，那经常增加大量元素会不会导致经常扩容，数组重新分配导致效率低下呢？ 其实不然，每次增长为原来的 1.5倍实际增长的量会越来越大的。当然，如果一开始知道数据量很大的话，可以在初始化时预先指定容量。\n为什么扩容因子是 1.5\n因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。\n为什么不取固定长度\n扩容固定容量，很难决定到底取多少值合适，取任何具体值都不太合适，因为所需数据量往往由数组的客户端在具体应用场景决定。\n Set接口 Set 特点：无序、无下标、元素不能重复\nSet 实现类：HashSet、SortedSet 接口（TreeSet 实现类）\n TreeSet：基于排列顺序实现元素不重复。实现了 SortedSet 接口，对集合元素自动排序。元素对象的类型必须实现 Comparable 接口，指定排序规则方法的返回值为 0，则认为是重复元素。 HashSet：储存结构为哈希表（数组+链表+红黑树）。   注意：HashSet 是线程不安全的，解决方法是使用 CopyOnWriteHashSet。  HashSet 存储过程：\n 根据 hashcode 计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。 再执行 equals 方法，如果 equals 方法为 true ，则认为是重复，否则，形成链表。  HashSet、TreeSet的实现原理: HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。\nTreeSet 的实现基于 TreeMap。\n Map 集合体系 Map 父接口特点：存储一对一数据，无序、无下标，键不可重复，值可以重复。\n HashMap ：存储结构（哈希表：数组+链表+红黑树）允许 null key、value。\nHashTable：不允许 null key、value。线程安全。\nTreeMap：实现了 SortedMap 接口（Map 的子接口），可以对 key 自动排序。\n 注意：HashMap 是线程不安全的，解决方法是使用 ConcurrentHashMap 。  HashMap底层原理 jdk 1.7 的数据结构是 “ Entry数组+链表 ”，jdk 1.8 的数据结构是 ” Node 数组+链表/红黑树 “。当链表的深度达到 8 并且 HashMap 容量 \u0026gt;= 64 时自动转化成红黑树，节点变成树节点，\t以提高搜索效率和插入效率到 O(logN)。Entry 和 Node 都包含 key、value、hash、next 属性。\nHashMap 默认容量为 16（数组长度），通过 hashcode 查询的时候是要先 ” hashcode % 数组长度 “ 进行运算才能找到数组对应位置下的链表。该数组只存引用的地址，其对象存在堆里。\n在 jdk 1.7 时插入元素是头插法，jdk 1.8 时是尾插法，头插法的插入很快（插完要移动一下，让该结点在原来头节点在数组中的槽位），尾插法要遍历再插入（jdk1.8）。\nput 时先会判断是否空数组，是空就会先初始化，put 一对 key-value 时，系统会根据 key 的hashcode\t来确认其在 “数组” 的存储位置，若没有元素则直接插入，否则会遍历该处的链表并依次比较其 key 的 hashcode，如果两个 key 的 hashcode 相同且 key 值相同，新的 value 会覆盖旧的 value 并返回旧的 value（不覆盖返回的是 NULLl）。如果 hashcode 相同但 key 值不同，则会进行插入操作，并且该链表的 size++。\n那么 key 值如何比较呢？ equals 方法。这里涉及 哈希碰撞：\n输入数据长度不固定，而输出的哈希值却是固定长度的，这意味着哈希值是一个有限集合，而输入数据则可以是无穷多个，那么建立一对一关系明显是不现实的。所以“碰撞”是必然会发生的。 HashMap 解决 hash冲突用的是拉链法，就是在对应的数组元素存链表头节点。还有开放寻址法、再哈希法，开放寻址是往数组索引++找空位置，再hash法就是再次用其他hash方法得到hashcode。 那既然 equals 方法这么有效，为什么还要用 hashcode ？\n因为 hashcode 快！\n如果现在有大量的对象需要比较，每个都用 equals() 效率是很低的，但 hashCode() 效率很高。\n所以有这种设计：先用 hashCode() 判断，如果 hashCode() 不同，则对象不等，如果 hashCode() 相同，再比较 equals() ，大大提高了效率。\nkey 可以等于 null，源码对 Entry 的两个约束：\n 数组每个槽位下都不为空。 所有结点平均分布在每一个槽位下的链表。  也正因如此，HashMap 的长度必须为 2 的次幂。讲到长度，就跑不掉 HashMap扩容了：\nHashMap 扩容条件 HashMap 扩容的加载因子默认为 0.75 ，阈值为 ” 0.75 * 数组长度 “，意思是每当 ”HashMap当前元素数“ 到达 ”当前容量 * 0.75“ 时 且 “插入位置不为 NULL” 就判断是否符合 “ 数组长度是否最大 ”。最大就不扩容，否则就是扩容到原容量的 2倍。\n0.75的负载因子的意义\n通常，默认负载因子（0.75）在时间和空间成本之间提供了一个很好的折中方案，负载因子控制存放数据的疏密程度。\n较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put），而且容易引发哈希冲突。\n16 * 0.75 = 12 除0.5与1以外唯一一个能得到整数的负载因子就是0.75。\n负载因子的大小决定了HashMap的数据密度，因子越大，越容易发生发生哈希碰撞，数组中的链表越容易长，造成查询或插入时比较次数增多，性能会下降。\n越小就越容易触发扩容，既影响性能又浪费空间。\nHashMap 扩容原理 new 一个两倍长度的 Entry/Node 数组，然后内容转移新的数组，扩容后链表会倒序。因此，多线程同时 put（）时，如果同时触发了 rehash（） 操作会导致 HashMap 中的链表中出现循环节点，进而使得后面 get（） 的时候，会死循环。\n另外，扩容之后链表可能减短，提高 get（） 时的效率。\n为什么HashMap扩容每次是2倍\n 找到 hash索引的方式是hashcode%length 取模操作，但设计得到 hash索引的 hash函数是：hashcode无符号右移16位再异或hashcode再按位与（length-1），为什么这么做?\n因为2进制操作远远快于取模，length 为 2次幂时，又恰好 (length - 1) \u0026amp; hash ≈ hash % length。而且我们可以看到它求hash的过程，将32位的hashCode值向右移动16位，高位补0，也就是只要了高16位，这是为什么呢？\n因为hashcode的计算方法导致哈希值的差异主要在高位，而 (n - 1) \u0026amp; hash是忽略了容量以上的高位的，所以 使用h \u0026raquo;\u0026gt;16就是为了避免类似情况的哈希冲突 在扩容迁移的时候不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原脚标位+扩容长度这么一个位置.是否移位，由扩容后表示的最高位是否1为所决定，由于移动的方向只有一个，即向高位移动。 因此，可以根据对最高位进行检测的结果来决定是否移位，从而可以优化性能，不用每一个元素都进行移位，因为为0说明刚好在移位完之后的位置，为1说明需要移动 oldCap.  哈希表底层怎样计算hash值  Object的hashcode方法算出h1。 h1无符号右移16位得到h2。 h1与h2异或运算得到最终的hash值h3。 h3与（length-1）按位与（\u0026amp;）运算得到hash表索引。 hashmap理论上是用取模得出在哪个hash桶，但是位运算会更快，在hashmap容量为2次幂时，取模结果会近似于以上四个步骤的结果。  HashMap死循环、ConcurrentHashMap HashMap\n在 JDK1.7 是采用的头插法，所以扩容过程转移到新的 HashMap 会逆置链表顺序，而当在并发环境下两个线程同时插入会导致死循环，原因就是顺序 A-B-C 变成了 C-B-A ，一个线程扩容完了之后另一个线程并不知道，因为此时两个线程都指向该槽位第一个节点， next 都是指向 B，而非扩容的线程的 B.next 还是 C，没有察觉到变化。在 JDK1.8 HashMap 采用的尾插法很好的规避了这个问题。\nConcurrentHashMap\n在 JDK1.7 下，ConcurrentHashMap 采用的是 segment 锁分段解决的并发问题，相比较 HashTable 降低了锁粒度。\n在 JDK1.8 下，ConcurrentHashMap 采用的是 CAS + synchronized + LockSupport 等阻塞手段实现的高效并发，和 JDK1.7 最大的区别在于 JDK1.8 的锁粒度更细，理想情况下 table 数组元素的大小就是其支持并发的最大个数，在 JDK7 里面最大并发 个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的， 简化了并发设计，不足之处在于并发的粒度稍粗，所以在 JDK1.8 里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的 table 元素的读写，好处在于并发的粒度更细， 影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像 JDK1.7 中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点，好在Doug lea大神对扩容 做了优化，本来在一个线程扩容的时候，如果影响了其他线程的数据，那么其他的线程的读写操作都应该阻塞，但Doug lea说你们闲着也是闲着，不如来一起参与扩容任务，这样人多力量大，办完事你们该干啥干啥，别浪费时间，于是在 JDK1.8 的源码 里面就引入了一个 ForwardingNode 类，在一个线程发起扩容的时候，就会改变 sizeCtl 这个值。\n  对于get读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。\n如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。\n  对于put/remove写操作，如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。\n  HashTable 和 HashMap 的区别  HashTable 不允许 key 和 value 为 null；HashMap 遇到 key 为 null 的时候，调用 putForNullKey（）进行处理，而对 value 没有处理；Hashtable 遇到 null，直接返回 NullPointerException。 HashTable 线程安全，但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只 能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。  ConcurrentHashMap 实现原理 JDK 1.7 中的实现：\n就是对HashMap加上个分段式锁，put和HashMap类似，先通过hashCode找到位置如果该处为null就new一个segment对象，segment 对象中有个 hashEntry 构成的链表，而每个 HashEntry 元素都是一个链表结构的节点，HashEntry 和 HashMap 非常类似，唯一的区别就是其中的核心数据 value 以及 next 都被 volatile 修饰，以此保证了多线程读写过程中对应变量的可见性。\nHashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的。ConcurrentHashMap 采用锁分段技术，将整个Hash桶进行了分段segment ，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁，这样做明显减小了锁的粒度.比HashTable效率高。 put过程：先根据 key 找到 segment 中对应的 HashEntry，遍历该 HashEntry ，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等就覆盖旧的 value，为空则需要新建一个 HashEntry 并加入到 segment 中，在加入之前会先判断是否需要扩容，最后解除 segment 锁。\nJDK 1.8 中的实现：\n将 JDK 1.7 中存放数据的 HashEntry 改为了 Node JDK 1.8 的 ConcurrentHashMap 取消了 Segment 分段锁，采取 CAS 和 synchronized 来保证并发的安全性。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发问题。\nConcurrentMap的put过程\n首先，根据传入的key，通过哈希函数确定key应该被放置在哪个段（Segment）中。 然后，获取该段的锁，保证在该段中进行操作时是线程安全的。 在获取到段的锁之后，检查是否需要进行扩容操作，如果需要，则进行扩容。扩容过程会重新计算每个元素的哈希值，重新分配到新的段中。 接着，在当前段中，查找是否已经存在相同的key。如果存在相同的key，则用新的value替换旧的value，并返回旧的value。 如果当前段中不存在相同的key，则将key-value对插入到当前段中。 最后，释放段的锁。\nConcurrentMap扩容\n是挨个把所有 segment 扩容，而不是整个 hashMap。所以扩容期间不耽误其它 segment 的 put、get。\nHashtable 扩容时将容量翻倍，而 ConcurrentHashMap 扩容时将只扩大一个 Segment，这样可以减少扩容时的并发冲突，提高性能。\nLinkedHashMap实现原理：\nLinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry，并添加两个属性 Entry\u0026lt;K,V\u0026gt; before，Entry\u0026lt;K,V\u0026gt; after 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。\n 迭代 Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 可以双向遍历。ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。\n与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出\tConcurrentModificationException 异常。这其实就是 fail-fast 机制。具体区别有三点：\n Iterator 的方法名比 Enumeration 更科学； Iterator 有 fail-fast 机制，比 Enumeration 更安全； Iterator 能够删除元素，Enumeration 并不能删除元素。  持续更新中\u0026hellip;\u0026hellip; 如有错误，敬请斧正\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/blog/%E9%9B%86%E5%90%88%E6%B5%85%E5%8E%9F%E7%90%86%E7%AF%87/","summary":"​ 集合的概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。 和数组的区别： 数组长度固定，集合长度不固定。 数组可以存储基本","title":"集合浅原理篇"},{"content":"有点感觉了，一直持续刷下去！各位看官跟我一起成长啊！\nMonday 面试题 02.07. 链表相交 注意：暴力循环一定要注意边界条件：A or B 链子为空，只有这一个边界！！！边界只有《0 - 1》，没有《1 - 2》。\nTuesday 142.环形链表II 两个重要切入点 :\n 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 快指针永远走的是慢指针的两倍长度。  解释 ：\n 先判断有没有环，while 下 快指针走 2 步，慢指针走 1 步，如果两个结点 位置一致，即为有环，否则无环则一定会 fast.next || fast.next.next == null。 从头节点到环入口结点距离为 A，环入口节点到相遇结点正向距离为 B，相遇节点正向到入口节点距离为 C。一定是在环内相遇，且 A == C。  Wednesday 242.有效的字母异位词 大体思路：定义一个 26 长度的数组，遍历第一个字符串，每次 -’a’ ，得到了在数组中的索引，把该处自增就好了，再遍历另一个字符串自减操作。再 foreach 一下数组 if( 1≠0 ) 就 return flase;\n注意：foreach 用法：for( int arr[i] ： 数组名)。\nThursday 349. 两个数组的交集 注意：不能重复、无序：HashSet，记住几个常见 API 例如 set.contains(??)、set.size() 。\n202. 快乐数 解题思路：\n 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。 所以进主函数的循环条件为 ≠1 \u0026amp;\u0026amp; !set.contains(?); 只要能进这个循环就进去拿到 nextNumber ，进到该方法里再进行拿到 各数上的平方和。  注意：res += n % 10 * n % 10; 一定要写成 res += (n % 10) * (n % 10); 因为四则运算的优先级会先 n%10 再 *n 。\n1. 两数之和 暴力冒泡只要注意初始化： j=i+1即可。\n进阶版本：主要熟悉几个常用 API：map.containsKey(key)、map.get(key)。 思路：这个思路就是先挨个 map.put() ，然后 target-nums[i] 这个数字在 map 中查找是否有符合项，有就 break;\n注意：第二次循环（寻找符合项时）循环 n-1 次，因为第 n 次循环就是反转的第 n-1 次循环。再次操作同一循环会导致顺序倒转，一定要注意顺序，然后就是 当 target-nums[i] == temp 时，两者相等导致输出的数组两个内容相同。所以在进第二次循环后要把这种情况单独 if 判断并 continue;\nFriday 454. 四数相加 思路：先把前两个数组之和（key），该和出现的次数value 存入map，再遍历后两个数组拿到 0-（c+d）去查map是否存在，存在 count+=value。 注意：可能有数组传入为 null，计算值的时候默认为 0 就行，如果两个普通的 for循环嵌套，有空数组会被判断条件拦截下来，但如果用的是 foreach 就没问题。\n383.赎金信 类似242.有效的字母异位词的傻瓜式操作，但是要注意这里是可不可构成，字母可以多，不能少，而242是必须不多不少刚刚好。\n15.三数之和 先记住两个 API：Arrays.sort(nums)、Arrays.asList(nums[i], nums[left], nums[right])。\n思路：先排个序，方便很多，测试用例里也是排序号的！再用双指针 left、right 来定位。SUM\u0026gt;0 就right—，反之 left++。 注意：如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”：如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”。\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.2/","summary":"有点感觉了，一直持续刷下去！各位看官跟我一起成长啊！ Monday 面试题 02.07. 链表相交 注意：暴力循环一定要注意边界条件：A or B 链子为空，只有这一个边界！！！","title":"LeetCode 一周小记 No.2"},{"content":"刷的脑壳疼，在螺旋矩阵卡了很久，其他的 easy 题都也被卡，目前进度为 2-3 medium / day。\nMonday （科普知识） 反码、补码 二进制的第一位是符号位，0是+，1是-，如果是1，怎么得到具体数字？ 二进制数全都取反，再+1就是对应结果的的绝对值 。 例如-1的二进制数全为1，则将后31个1全取反并+1，得到 000\u0026hellip;1 的十进制数就是1 。\n如何把随机出现从 x 概率变为 x^3 概率？ Math.Max(Math.Random(),Math.Max(Math.Random(),Math.Random()));\n注意：Random生成一个[0,1)\n如何在 1-5（int）随机函数上生成1-7的随机函数？ 直接把1-5改成随机生成0、1的函数，1、2返回0，3就return重来，4、5就返回1 。\n再根据读书器返回0、1的函数处理:\n1  return （f（）\u0026lt;\u0026lt; 2）+ （f（）\u0026lt;\u0026lt; 1）+（f（）\u0026lt;\u0026lt; 0）; //0或4 + 0或2 + 0或1   注意：\n 如果直接 相乘 是不行的，因为只返回 0、1 乘了 7 就变成 0、7 。会缺失中间的数。 0-7 有了，我们要 1-7 ，那只能 0-6 随机再+1 。1-7 只要遇 7 重来就行了。或者直接 0 重来。就不用再 +1。  为什么不能直接 (f() \u0026laquo; 2) + (f() \u0026laquo; 1) 呢？直接得到 0-6\n 因为左移两位得到要么是0要么是4，左移一位是0或2，不移动0、1 。得到的具体数字不是范围，再将其相加，产生的和才是一个范围。  如何改变一个任一固定概率的随机0、1函数变为产生0、1都为50%的函数？ 运行两次该函数，两次得到0的概率为 p^2 ,两次得到 1 的概率为 (1-p)^2 ;而一次 0 一次 1 的概率是 p*(1-p); 所以只要两次返回一次为 0 一次为 1 就行。不然就重新执行。\nTuesday 206. 反转链表 这题一定要按清楚头指针 pre、next 指针只是指针，不是一个结点指向另一个结点的指针。定义出这两个指针、画好图就很容易操作。这是单链表的反转，至于双链表就是多加了一个 last 指针指向上一个，只需要在存 next 时多存一个 last ，其他无需改动。\n704. 二分查找 首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-1，不然藏在边界的 target 就查不到了。\n27. 移除元素 暴力解法：需要注意，i\u0026ndash;；是因为既然当前值为 ？的点的右边所有点一切都左移了一位，所以现在的 i 指向的是已删除（被覆盖）的位置，该位置补了后面那位没被扫描的数字，而该次循环结束就要 i++了，所以会指向这个没扫描的下一个进行扫描，就漏掉一个了。再一个注意溢出边界问题，还有一个就是无限循环容易发生是因为 for 循环条件不能是 \u0026lt; length。而应该是 \u0026lt;size 这个自定义的，会随着更新而更新。\nWednesday 977. 有序数组的平方 这一题犯了一个总是犯的错误，总是忘记写返回值，以后第一步确定返回值，不明则？？表示。\n该题暴力解法就是平方再排序美滋滋~，但是时间复杂度为O(n^2)，有O(n)的解法：双指针。\n双指针解法一定要注意边界。\n209. 长度最小的子数组 暴力解法要注意必须双层循环。为了避免要判断第一次 \u0026gt;target，把 len 初始值设为Interger.MAX_VALUE。滑动窗口：注意循环条件的边界。\nThursday 59. 螺旋矩阵 II 该题一定要注意别自己瞎套，while 的条件按照（循环次数）来。偏移量每次+2，从左到右，从上到下的循环条件要-offset。\n203. 移除链表元素 先把头的 val 确定 ≠ val、≠null 再去定义 cur 等等其他结点，记得依次讨论头不为空（头的 val 为 val）、头为空（return head把整个链表有可能为空的情况删除整个链表了直接提前退出）。\n不为空 \u0026amp;\u0026amp; 头的 val == val 一定要把 ≠null 写在 \u0026amp;\u0026amp; 前面，不然先判断 head.val 如果说 head == null ，那就直接报错了。\n删除一定要 XXX.next = XXX.next 这样操作，自己定义的 cur 、 next 都只存一个地址，cur = nextNode 就是 cur 指针走到了 nextNode 这个位置。\nFriday 707. 设计链表 只要把get、addIndex、delete写出来就行了，另外两个addHead、addTail直接调用这个addIndex就行了，至于get、delete都是用addIndex里面for查找的逻辑找到，主线就是写出addIndex，注意在addIndex里面 size++ 就够了，不要反复 ++ ；\n另外自己定义一个 ListNode 的 class ，构造方法只要空参。成员变量 int val、 ListNode next；\n24. 两两交换链表中的结点 非必要情况下，不要定义那么多 next、cur 结点，不然判空很头大，如果是在 while 内，cur、next、pre 都在变换，判空繁琐，在初始化时也要判空，还是尽量只定义一个 pre 结点，反正操作链表的元素有个 pre 就够了。\n19.删除链表的倒数第N个节点 暴力解法：注意考虑传入的值的合法性。\n进阶版本：首先一边扫描肯定无从下手，想想，倒数第 n 个结点，是正着数的第几个 ?\n 显而易见：size-n 个，那如何拼凑出 size ？那是肯定要扫描一遍完整的链表结点的。  如果扫描 size++ 出长度那必然要再操作一遍，落入了扫描多次的圈套，so what？\n 定义一个 fast 指针、一个 slow 指针，fast 扫描全文，而 slow 指向要被删除的结点的上一结点。如何凑出 size -n？先让 fast 走 n 次，再让 fast 和 slow 一起走剩下的 size-n次，此时fast 指向了最后一个元素，slow 指向了删除的结点的上一结点。   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.1/","summary":"刷的脑壳疼，在螺旋矩阵卡了很久，其他的 easy 题都也被卡，目前进度为 2-3 medium / day。 Monday （科普知识） 反码、补码 二进制的第一位是符号位，0是+，1是-，","title":"LeetCode 一周小记 No.1"},{"content":"Spring MVC的优点有哪些？   可以支持各种视图技术,而不仅仅局限于JSP；\n  与Spring框架集成（如IOC容器、AOP等）；\n  清晰的角色分配：\n 前端控制器(dispatcherServlet) ； 请求到处理器映射（handlerMapping)； 处理器适配器（HandlerAdapter)； 视图解析器（ViewResolver）；    支持各种请求资源的映射策略；\n  DispatcherServlet处理流程 Spring MVC框架的控制器（Controller）解析用户输入并将其转换为一个由视图呈现给用户的模型。\n控制器的核心DispatcherServlet处理请求和响应，处理流程如下：\n DispatcherServlet向处理器映射器（HandlerMapping）请求获取Handler。 返回Handler给DispatcherServlet。 DispatcherServlet向处理器适配器（HandlerAdapter）请求执行Handler并返回视图ModelAndView给DispatcherServlet。 向视图解析器（ViewResolver）通过视图名称查找视图并返回给DispatcherServlet真正的视图对象。 进行视图的渲染并返回给DispatcherServlet渲染后的视图。相当于给了controller控制器。以上png为转载，如有侵权，请联系本人。  常见注解 @PathVariable 和 @RequestMapping 和 @RequestParam：\n@PathVariable和@RequestParam不要混淆，\n区别是用法上不同：\n@PathVariable在 @RequestMapping请求路径后接”/{参数名}“，多个参数就再接多个“/{路径中的参数名}”，在对应的参数列表的参数前加上 @PathVariable 注解。该请求路径中参数名和参数列表 @PathVariable 注解的 value，再在网页路径上传入参数。\n而@RequestParam取参读取 /路径？后的name=”参数“，@RequestParam注解有三个参数，\n1、value：参数名。\n2、required：表示当前属性值是否必须存在（默认是true）。\n3、defaultValue：如果value传递参数了，使用参数，如果没有，使用默认值。\n@RequestHeader、@CookieValue也是一样的这三个参数。\n@RequestBody： 注解实现接收http请求的json数据，将json转换为java对象。\n注：@ResponseBody ＋ @Controller == @RestController\n例如：前台Ajax传递到controller的json格式数据绑定到后台方法的参数列表的某个参数上。\n1 2 3 4 5 6 7 8 9  $.ajax({ url:\u0026#34;/login\u0026#34;, type:\u0026#34;POST\u0026#34;, data:\u0026#39;{\u0026#34;userName\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;pwd\u0026#34;,\u0026#34;admin123\u0026#34;}\u0026#39;, content-type:\u0026#34;application/json charset=utf-8\u0026#34;, success:function(data){ alert(\u0026#34;request success ! \u0026#34;); } });   1 2 3 4 5 6  @requestMapping(\u0026#34;/login\u0026#34;) public void login(@requestBody String userName,@requestBody String pwd){ //也可换做是user对象来绑定，会根据属性名赋值， //但是必须属性名和json的key对应上，否则请求不过去。 　System.out.println(userName+\u0026#34; ：\u0026#34;+pwd); }   @ResponseBody： 该注解实现将controller方法返回的java对象转化为json对象响应给客户。 换句话说：表示当前请求的内容直接作为响应体，用于接收。\n注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如前台异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public User login(User user){ return user; } User字段：userName pwd; 那么在前台接收到的数据为：\u0026#39;{\u0026#34;userName\u0026#34;:\u0026#34;xxx\u0026#34;,\u0026#34;pwd\u0026#34;:\u0026#34;xxx\u0026#34;}\u0026#39; 效果等同于如下代码： @RequestMapping(\u0026#34;/login\u0026#34;) public void login(User user, HttpServletResponse response){ //通过response对象输出指定格式的数据 　response.getWriter.write(JSONObject.fromObject(user).toString()); }   @ModelAttribute：\n@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。说白了就是数据回显。 但远远不仅于此\u0026hellip;..\n在方法参数上使用 @ModelAttribute 注解:\n可以描述为数据绑定，注解在方法参数上说明了该方法的该参数将由 model 中取得，如果model找不到，那么该参数会被优先实例化，然后被添加进model，再把请求中所有名称与之匹配的参数填充到该参数中。\n对方法使用 @ModelAttribute ：\n添加该注解的方法会率先其他方法执行。\n如果方法无返回值，就在添加该注解的方法中 model.addAttribute ，在该控制器的其他方法返回的页面可以拿到这个 model。\n有无返回值的 @ModelAttribute 方法区别是，无返回值的是 model.addAttribute(String key,Object value)来向model增加参数，而有返回值的直接将需要增加的参数返回。过程说出来就是赘述，联想一下。\n以上都是在 @ModelAttribute 中不加 value ，这样如果是有返回值的 @ModelAttribute 方法，就会默认返回名称为“返回值类型的小驼峰化的对象名称”，如果指定 value，那就是返回指定的，比如返回值类型是User，那默认名称则为user，指定名称为 pp，那返回参数名称就是pp。\nrest中的get、post、delete、put请求 get是获取资源、post新建资源、put更新资源、delete删除资源。\n在选择method只能发送post和get请求，因此可以用过滤器filter将post请求转化为put、delete请求以达到put、delete的效果。\n编码问题详解 编码问题无外乎两种情况：\n post： 在 web.xml 配置一个 CharacterEncodingFilter 过滤器，设置为 utf-8。 get：在tomcat的 server.xml 文件中，添加 URLEncoding=utf-8。或者对 request、response 参数重新编码。 注意：过滤器顺序：一个应用程序中可能会包含N个过滤器，这N个过滤器一般是没有顺序要求的，但是如果设置了编码过滤器，那么一定要把它放到最上面，保证过滤器的运行。不论是Spring MVC自带的编码器还是自定义的，都要这样。  后端向前端传值的方式 前面都是前端往后端传数据，现在看后端往前端传数据\n前面都是前端往后端传数据，现在看后端往前端传数据\n1、map.put(”msg”,”hello data”)，在参数列表加Map。return 的是页面路径。\n2、model.addAttribute(”mac”,”hello mac”)，在参数列表中加Model 对象名。return 的是页面路径。\n1 2 3 4 5 6 7  @RequestMapping(\u0026#34;/testModel\u0026#34;) public String testModel(Model model){ model.addAttribute(\u0026#34;name\u0026#34;,\u0026#34;赵六\u0026#34;); model.addAttribute(\u0026#34;age\u0026#34;,12); model.addAttribute(\u0026#34;address\u0026#34;,\u0026#34;上海\u0026#34;); return \u0026#34;user\u0026#34;; }   3、modelMap.addAttribute(”mac”,”hello mac”)，在参数列表中加ModelMap 对象名。return 的是页面路径。\n4、也可以用ModelAndView传递数据，方法内new一个modelAndView对象并且“该对象”.setViewName(”页面路径”)，再addObject(”mac”,”hello mac”);return的是“该对象”，上述三种返回的是页面路径。\n1 2 3 4 5 6 7 8 9 10 11  @RequestMapping(\u0026#34;testModelAndView\u0026#34;) public ModelAndView testModelAndView(){ ModelAndView modelAndView = new ModelAndView(); //设置跳转页面名称 \tmodelAndView.setViewName(\u0026#34;user\u0026#34;); //设置携带的参数 \tmodelAndView.addObject(\u0026#34;name\u0026#34;,\u0026#34;赵六\u0026#34;); modelAndView.addObject(\u0026#34;age\u0026#34;,12); modelAndView.addObject(\u0026#34;address\u0026#34;,\u0026#34;上海\u0026#34;); return modelAndView; }   以上都可以用于数据回显，前3种方式的回显数据保存在哪个作用域？\n1、page：当前页面\n2、request ：当前请求 （保存在这）\n3、session：当前会话\n4、application：当前应用\n当使用上述（map、model、modelMap）参数传递数据时会把数据都放置到Request作用域。\n如果要存在session中：在类名上+@SessionAttributes(”msg”);该注解表示每次向request中设置属性值时顺带向session中保存一份。\n转发、重定向 转发：在返回值前面加\u0026quot;forward:\u0026quot;，譬如\u0026quot;forward:user.do?name=method4”\n重定向：在返回值前面加\u0026quot;redirect:\u0026quot;，譬如\u0026quot;redirect:http://www.baidu.com\u0026quot;\n处理静态资源 在处理静态资源时（例如图片），不做处理的话所有请求都会交由dispatcherServlet来处理，但是dispatcherServlet中没有处理静态资源的逻辑，所以访问不到，添加mvc默认配置后就可以了，由\n1  \u0026lt;mvc:default-servlet-hanlder/\u0026gt;\u0026lt;mvc:annotation-driven\u0026gt;   SpringMVC和struct2的区别  SpringMVC的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter） SpringMVC是基于方法开发（一个url对应一个方法），请求参数传递到方法的形参，可以设计为单例、多例。struct2是基于类开发，传递参数通过类的属性，只能设计为多例。  SpringMVC异常处理  可以抛给Spring框架来处理。 可以配置简单的异常处理器，在异常处理器中添加视图页面即可。  SpringMVC的控制器是不是单例模式？如果是，有什么问题？怎么解决？ 是单例模式。 在多线程访问的时候有线程安全问题。 解决方案是在控制器里面不能写可变状态量，如果需要使用这些可变状态，可以使用ThreadLocal机制解决，为每个线程单独生成一份变量副本，独立操作，互不影响。\nSpringMVC 里面拦截器是怎么写  实现 HandlerInterceptor 接口； 继承适配器类，接着在接口方法当中，实现处理逻辑，然后在 SpringMVC 的配置文件中配置拦截器即可。  注意 自定义类型转化器的时候一定要注意对应的属性值 跟 方法中的参数的值要对应起来。\n","permalink":"https://coderrenxy.github.io/posts/blog/spring-mvc%E5%B0%8F%E7%BB%93/","summary":"Spring MVC的优点有哪些？ 可以支持各种视图技术,而不仅仅局限于JSP； 与Spring框架集成（如IOC容器、AOP等）； 清晰的角色分配： 前端控制","title":"Spring MVC小结"},{"content":"讲到Spring就一定绕不开IOC、AOP两个概念了，在我看来Spring的一切都基于IOC，所以先聊IOC吧。\nIOC 什么是 IOC 首先看看 IOC 的作用，我们可以试着写一个从 service 层到 dao 层的用例，会发现如果是一层一层实现了这个用例，将来要修改就要一层层改， 这样耦合度极高，而把控制权交给第三方（ Test 中 new 一个 serviceImpl 来 set 一个 userDao），能达到解耦目的。此时，主动去 new 一个 dao 对象叫正向获取，而等着 serviceImpl 来 set 是等着别人给我这个对象，是反向获取。就像自己找对象（正向）和婚介公司分配对象（反向）。\nIOC 的两种容器及异同 对于 IOC 最重要的是容器，容器管理着 Bean 的生命周期，控制着 Bean 的 DI（依赖注入），那 Spring 是怎么设计的容器？\nSpring 提供两个接口用以表示容器，一个是 BeanFactory，一个是 ApplicationContext，咱们就聊聊异同吧。\n BeanFactory 粗暴简单，可以理解为一个 HashMap，key是BeanName，value 是 Bean 实例，通常只提供注册（put），获取（get）功能，我们称为低级容器。BeanFactory 是 Spring 底层 IoC 容器，ApplicationContext 是 BeanFactory 的子接口。在该接口中利用反射创建对象。 ApplicationContext称为高级容器，因为他比BeanFactory多了更多功能，他继承了多个接口。因此具备更多功能，例如资源的获取、支持多种消息（例如jsp tag的支持）、对比BeanFactory多了工具级别的支持等等。所以名字也不是BeanFactory之类的工厂了，而是“应用上下文”，代表整个大容器的所有功能，该接口定义了一个refresh方法（刷新整个容器，即重新加载所有的bean）。 隶属 ApplicationContext 的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer模式），而低级容器只负责加载Bean、获取Bean。值得一提的还有两个容器之间的区别。了解区别之前必须明白IOC在启动过程做了些什么操作，IOC启动过程分为两个阶段：\n1. 容器的启动：加载配置信息，分析配置信息。\n2. Bean的实例：实例化对象，装配依赖，生命周期回调。 两者的区别：BeanFactory 延时加载，只有在使用某个 bean 时（即调用 getBean()方法时），才会对 bean 进行实例化，而 ApplicationContext 在容器启动的时候，一次性完成两个阶段，因此BeanFactory在启动过程不能在容器启动阶段发现配置问题，而 ApplicationContext 可以，但是由于一次性实例化所有的 Bean，启动花费的时间也长。  Bean的生命周期 其实吧，上面的 IOC 启动过程都与 Bean 的生命周期有关，聊到这里就避不开这个话题了。Bean 的生命周期：\n Bean 的定义：beanDefinitionReader（抽象接口约束）加载配置文件（xml、properties、注解、yaml）读取bean的定义信息并包装成BeanDefinition。 执行BeanFactoryPostProcessor 准备 BeanPostProcessor、广播器、监听器。（注：beanfactorypostprocessor 完成对 beanfactory 相关信息的修改和拓展(容器运行需要的对象)。beanpostprocessor 完成对bean的修改或拓展（用户自定义对象））。 Bean 的实例化：在 ioc 中利用反射实例化所有的非懒加载的单例 bean。 Bean 的初始化：\n1. Bean 的属性赋值：实例化后的对象还是一个空对象，根据 Bean 的元信息对该对象的所有属性进行赋值。即 PopulateBean 方法。\n2. 执行 Aware 接口的方法。Bean 分为两种，一种是用户 bean 对象，一种容器对象 bean（environment、applicationContext、beanFactory），aware 接口是为了使某些用户 bean 对象能够方便的获取容器bean对象。\n3. 执行 BeanPostProcessor（增强器）的 before 方法。“增强 Bean（AOP）”。\n4. 执行 init-method 方法。\n5. 执行 BeanPostProcessor（增强器）的 after 方法。 对应过程 before，这样就获得了完整对象。如果一个对象需要生成代理对象来增强 bean，会进行反射的普通创建一个实例化的对象，所以叫拓展。不是所有的 bean 都会增强，所以一定是会创建新的（代理）对象。 Bean 的调用：有三种方式可以得到 Bean 并进行调用：  使用 BeanWrapper。 使用 BeanFactory 。 使用 ApplicationContext。   Bean的销毁：  使用配置文件中的 destory-method 属性。 实现 org.springframwork.bean.factory.DisposebleBean接口。    Spring 中可以出现两个 ID 相同的 bean 吗，如果不行会在什么时候报错 分情况，同一个 spring 配置文件里不能存在 id 相同的 bean，会在解析 xml 文件转换为 BeanDefinition 阶段报错。\n不同的 spring 配置文件里可以存在 id 相同的两个 bean，默认会把多个 id 相同的 bean 进行覆盖。\nspring 3.x 版本后使用 @Configuration 进行配置的时候：\n 同一个配置类中使用 @Bean 声明多个相同名字的 bean 默认只会注册第一个。 使用 @Autowired 可能会提示找不到未注册的类。 使用 @Resource 注解会在 bean 初始化之后依赖注入的时候可能会提示类型不匹配错误  IOC常见的实现方式 IOC是个原理（基于工厂模式+反射机制），是把以前在工厂方法中写死的对象生成代码，改由配置文件来定义，真正的实现方式常见的有两种： 1、依赖注入。 2、依赖查找。\n两者都是调用相关接口获取bean对象，区别在于DI（依赖注入）是IoC容器启动时由容器帮你实现，DL（依赖查找）要手动。目前用到DL（依赖查找）的非常少了，所以来聊聊DI（依赖注入），依赖注入从XML配置上来说就是ref标签，对应的是Spring中的RuntimeBeanReference对象，实现方法如下。\nDI（依赖注入）的实现方式  构造器注入：构造器依赖注入通过容器触发一个类的构造器来实现的，通过构造器的参数注入相关依赖对象。用xml文件配置就是property中通过construct-arg来指定构造器的参数，用注解配置就是在构造方法上加上@Autowire注解。这种方式好比学渣从一开始就赖上了一个学霸，并且和这个学霸建立了长期合作关系。 setter注入：通过 setter 方法注入依赖对象，也可以理解为字段注入。通过Xml配置就是property中指定name=”age”或Age；ref=”\u0026hellip;..”。因为Spring会自动的将首字母大写再在前面加上set，这里也可以看到，有关的是set方法后的名称，而与属性（成员变量无关）。用注解来写就是在setter方法上加上@Autowire注解。这种方式学霸和学渣只是暂时的合作关系，如果学渣赖上了另一个学霸（调用set()方法传入了另一个对象），那么学渣和上一学霸的合作关系就结束了。 属性注入（方法参数注入）：定义成员变量来添加@Autowire注入。这种方式不建议使用，但是工作中用的最多，因为真的方便。这么方便为什么不推荐？如果是IOC以外的环境，除了使用反射来提供他需要的依赖，无法复用该实现类。  那setter注入和构造器注入用哪个？看上面我的描述，构造器不是有点强买强卖的意思？所以构造器参数实现强制依赖，setter方法实现可选依赖。构造器注入可以保证有序的被注入，而setter方法注入是通过反射机制注入，无法保证注入顺序。构造器注入不允许出现循环依赖，因此被注入的对象需要保证能实例化，构造器依赖初始化时对象才注入依赖对象，保证了bean初始化后就是不变的对象。setter方法的循环依赖Spring已经解决了，先聊聊循环依赖吧。\n这里多嘴提一句Autowired：@Autowired默认是byType，类型一样时会根据id查找，默认的id为类名（自动改为首字母小写）。找到了直接注入，找不到报错。如果指定id（别名）就是用@Qualifier。如果@Autowired添加在方法上时，此方法在创建对象的时候会默认调用，同时方法中的参数会自动进行装配。@Autowired也能用在方法的参数上指定当前属性的别名。Jdk提供了@Resource和@Autowired一样的功能。Resource可以在其他框架中用，是按照id进行装配的，id找不到就用type。Autowired通过反射来注入。\n循环依赖 （只有单例Bean才会出现循环依赖）\n如果一段依赖关系为beanA\u0026ndash;\u0026gt;beanB\u0026ndash;\u0026gt;beanC\u0026ndash;\u0026gt;beanA，这就是循环依赖。如果没有最后一个beanA而是beanA\u0026ndash;\u0026gt;beanB\u0026ndash;\u0026gt;beanC，此时Spring将创建beanC，然后创建beanB（并将beanC注入beanB）然后创建beanA（并将beanB注入beanA），但是在有两次beanA时，Spring无法决定应该首先创建哪个bean（注意：这里是创建，不是初始化，初始化在上文Bean的生命周期有记载，是根据用户xml中对bean定义的顺序来加载，若有依赖，先用占位符_代替，那为什么不在加载Bean的时候直接注入呢？因为我们并不能要求用户按照顺序定义Bean，这样是不人道的！可能A依赖于B，但是B还没有加载好），因为他们彼此依赖，这个情况下Spring将在加载上下文时引发BeanCurrentlyInCreationException。使用构造方法注入时，他可能在Spring中发生，其他类型应该无此问题（setter注入的循环依赖已经被Spring解决）。\n 那在构造器注入中如何解决循环依赖呢?其实方法很多，当然我们只讲流行的，况且最好的方法就是重新设计或者用setter注入，简单了解一下吧。   使用@Lazy放在构造方法参数列表的参数前，意思就是懒洋洋的初始化其中一个bean。它不是完全初始化bean，而是创建一个代理将它注入到另一个bean。注入的bean只有第一次需要时才会完全创建。用人话来讲就是第一次被需要才创建，之后在需要这个bean就是创建它的代理对象。\n  在其中一个bean上加@AutoWired，其他依赖项上使用@PostConstruct。\n那我们肯定还是要了解一下setter注入中Spring是怎么解决循环依赖的吧！\n   先透个实底：Spring通过提前暴露对象的方式解决循环依赖问题，即 对“半成品对象”（实例化后、初始化前的对象叫做“半成品对象”）设置缓存来预存对象，等后续再根据A对象的引用来完成赋值操作，实例化后、初始化前的对象叫做“半成品对象”。这里缓存有三级。了解三级缓存前，先了解spring常用的6个方法：\t1  getBean--\u0026gt;doGetBean--\u0026gt;createBean--\u0026gt;doCreateBean--\u0026gt;createInstance--\u0026gt;populateBean   \t那三层分别什么作用? 一级缓存singletonObjects：存放成品对象。 二级缓存earlySingletonObjects：存放半成品对象。 三级缓存singletonFactories：存放lamdb表达式。  为何要有三级？只用第一级行不行？只用一、二级行不行? 别着急，小任细细道来。\n如果只有一级缓存：那么意味着半成品对象和成品对象都要放到一级缓存，那就有可能获取到对象的非完整状态，此时不可以使用。\n如果只有一二级缓存：没有AOP的时候就可以，三级缓存是解决代理过程中的循环依赖。\n 总结一下以上：每次我们在获取对象的时候，是通过对象的name来获取bean的，如果原始对象和代理对象同时存在的话，那么我通过名字再进行获取的时候应该选择哪个？无法选择的，其实还有最核心的点，你怎么能够确认对象什么时候需要被引用呢？使用lambda表达式其实代表了一种回调机制，当需要使用当前对象的时候，通过lamdba表达式来最终返回一个确定的最终版本对象，而不需要判断几个对象，因为是替换的过程，所以只能有一个。接下来给IOC留个结尾干巴的面试题吧，干就完了！  Spring核心类  BeanFactory：产生一个新的实例，可以实现单例模式。 BeanWrapper：提供统一的get及set方法。 ApplicationContext:提供框架的实现，包括BeanFactory的所有功能。  Spring中的设计模式  工厂模式：Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象。 单例模式：Bean默认为单例模式。 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。 模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate, JmsTemplate, JpaTemplate。 适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式，Spring MVC中也是用到了适配器模式适配Controller。 策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略。 观察者模式：Spring事件驱动模型就是观察者模式的一个经典应用。 桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库。  Bean的作用域  singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。 prototype：原型范围与单例范围相反，为每一个bean请求提供一个实例。 request：在请求Bean范围内会对每一个来自客户端的网络请求创建一个实例，在请求完成以后，Bean会失效并被垃圾回收器回收。 session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。（不知所云）  ApplicationContext 通常的实现  FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。 WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。  AOP 温馨提示：上面IOC没捋顺就别往下看AOP了\n通知 大家都是怎么描述AOP和其中各种名词呢? 听听小任的见解。\n想象一下：方法是纵向的，而各种打印的日志信息就都是横向的，横纵向的交汇点就是连接点，通俗来讲一个方法中可以填入额外的代码的地方都叫做连接点，而实际填充了代码的叫做切入点，切入点是连接点的子集。切面类就是存放打印日志方法的logUtil类，每一个切面类对应的方法都是横切面，使用AOP的话就在切面类上加@Aspect。 通知注解的几种类型：\n @Before前置通知：方法执行前执行。 @After后置通知：方法执行后执行。 @AfterReturing返回通知：结果返回后运行。 @AfterThrowing异常通知：出现异常时使用。 @Around环绕通知：其他四个注解都是方法被调用就会根据情景来执行的，比如异常了就执行@AfterThrowing，其他四个注解都是被方法绑死，而环绕通知比较特殊，他能决定一个类是否需要返回对象，能决定该方法是否被调用。它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。  执行顺序：环绕前置通知\u0026ndash;\u0026gt;before\u0026ndash;\u0026gt;环绕后置通知\u0026ndash;\u0026gt;after\u0026ndash;\u0026gt;afterReturing或者：环绕前置通知\u0026ndash;\u0026gt;before\u0026ndash;\u0026gt;环绕后置通知\u0026ndash;\u0026gt;after\u0026ndash;\u0026gt;afterThrowing。\n这些通知都需要指定方法的权限修饰符、方法的返回值类型、方法的全限定名。在方法的参数的列表中不要随便添加参数值，会异常，如果需要参数就在参数列表加上joinpoint来getArgs（获取参数列表），返回值在注解中指定（returning=”result”）之后才能从在方法的参数列表指定。execution精确匹配的方式其实并不友好，一般用的是通配符（*和.）的方式也可以多个execution来进行逻辑运算（与或非）。\n需要注意的是，一个通知只能针对一个特定的连接点（即切点）。因此，如果需要在不同的切点上应用不同的通知，就需要定义多个切面类。 在一个切面中放置多类通知是正常的，并且常用。\n代理 讲到AOP一定逃不掉的一个东西：动态代理的实现\n有动态，那静态呢？ 动态代理的代理类是动态生成的 ，静态代理的代理类是我们提前写好的。 那为什么要有动态代理呢？且先看看静态代理的优劣：\n静态代理的好处是：我们的真实角色更加纯粹 . 不再去关注一些公共的事情 ，公共的业务由代理来完成， 实现了业务的分工，公共业务发生扩展时变得更加集中和方便。说白了就是（动态、静态）代理类的好处。\n静态代理的缺点是：类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 。 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n动态代理的核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理。 两种实现方式：\n JDK代理：基于接口的动态代理。 CGlib代理：基于类的动态代理。 二者区别是：JDK代理只能对实现接口的类生成代理，利用反射机制生成一个匿名类，CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，但是这种通过继承类的实现方式不能代理final修饰的类。  如何实现JDK动态代理？\t（JDK 动态代理最核心的一个接口和方法如下）\n InvocationHandler 接口：使用方法首先是需要实现该接口，并且我们可以在 invoke方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法的前后去做一些额外的事情，从而实现动态代理。传入的参数如下：\n1. proxy：被代理的类的实例；\n2. method：调用被代理的类的方法；\n3. args：该方法需要的参数； Proxy 类中的 newProxyInstance 方法：该方法会返回一个被修改过的类的实例，从而可以自由的调用该实例的方法。传入参数如下：\n1. loader：被代理的类的类加载器；\n2. interfaces：被代理类的接口数组；\n3. invocationHandler：调用处理器类的对象实例；  Spring的事务 事务分为两种：声明式事务、编程式事务。一一介绍一下，先来精简的。\n 编程式事务：在代码中直接加入处理逻辑，可能需要在代码中显式调用beginTransaction、commit、rollback方法。 声明式事务：方法外部添加@Transational注解或在配置文件中直接定义，将事务代码和业务方法分离，以声明的方式实现事务管理。AOP恰好能完成，通过AOP方法模块化，进而实现声明式事务。其中，声明式事务用法值得一提其中的属性：\n1. isolation：隔离级别。（大写不方便本人认读，所以还是小写）事务应该不会陌生吧?跟着MySQL/Oracle走，如果是MySQL，那隔离级别默认为RR（可重复读Read Repeated）Oracle则是默认RC（读已提交Read Commited)。\n2. timeout：超过时间。\n3. readonly：设置为只读事务。\n4. noRollBackfor：设置为发生该异常也不回滚（指定异常类的类名.class）只对特定异常类起作用。\n5. rollBackfor发生指定异常回滚（指定异常类的类名.class）只对特定异常类起作用。   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/spring%E6%9D%82%E8%AE%B0/","summary":"讲到Spring就一定绕不开IOC、AOP两个概念了，在我看来Spring的一切都基于IOC，所以先聊IOC吧。 IOC 什么是 IOC 首先看看 IOC 的作用，","title":"Spring杂记（顺着链条自上往下看）"},{"content":"​\n首先了解关于数据库一个误区，我们用的 MySQL、Oracle 都是 DBMS（数据库管理系统），用来操作数据的，而数据库是用来存数据的，而 sql 是结构化查询语言。程序员来写 sql 语句，DBMS 来执行 sql 语句。再一个，数据库是存储数据，数据库实例才是操作数据。\n三大范式 数据库表设计的三大范式：\n避免数据冗余、空间浪费。但有时候需要空间换时间的反范式优化，具体情况根据业务具体分析。比如父表冗余一些数据到子表中是为了排序。\n第一范式：要求任何一张表必须有主键，每一个字段具有原子性（不可再分）。\n第二范式：建立在第一范式之上，要求所有的非主键字段完全依赖主键，不要部分依赖主键。\n第三范式：建立在第二范式之上，要求所有的非主键字段直接依赖主键，不要传递依赖主键。\n理解1NF：考虑这样一个表：【联系人】（姓名，性别，电话） 如果在实际场景中，一个联系人的电话有家庭电话和公司电话。\n那么这种表结构设计就没有达到1NF。 要符合 1NF 我们只需把列（电话）拆分。 即：【联系人】（姓名，性别，家庭电话，公司电话）。 1NF 很好辨别，但是 2NF 和3NF 就容易搞混淆。 理解2NF：当主键为联合主键时，其它字段只依赖于联合字段的一部分就是部分依赖。 理解3NF：也就是非主键字段不能产生依赖。\n事务 事务是一个完整业务逻辑的最小工作单元，只有 DML （增删改）语句和事务有关，操作涉及数据的增删改就要考虑安全。 本质是多条 DML 语句同时成功 or 同时失败。 事务执行过程中，每一条 DML 的操作都会记录到“事务性活动的日志文件”中。 事务的执行过程中我们可以提交事务 or 回滚事务。默认是每执行一条 sql 提交一次，如果要关闭就要使用开启事务命令，这个命令可以理解为关闭每条都自动提交，也可理解为开启事务。\n开启事务的方式有两种：\n begin/start transaction 命令：只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机； start transaction with consistent snapshot 命令：执行了该命令，就会马上启动事务。\n提交事务：清空事务性活动日志，将数据全部彻底持久化到数据库表中。\n回滚事务：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件，回滚事务标志着事务的结束，并且是 失败的结束。 a向b转 1w。 将a的-1w。 将b的+1w。\t这就是一个完整的业务逻辑。 事务四个特性：   A ：原子性：说明事务是最小的工作单元，不可再分。 C ：一致性：所有事务要求，在同一个事务当中，所有的操作必须同时从成功或者同时失败。 I ：隔离性：A 事务和 B 事务必须具有一定的隔离性。 D ：持久性：事务最终结束的一个保障，事务一旦提交就是永久性的。   事务的隔离级别   读未提交（ Read Uncommitted ）：\nA 可以读取到 B 未提交的数据，存在脏读、不可重复读、幻读问题！\n  读已提交（ Read Committed ）:\n事务 A 只能读到事务 B 已提交的数据，解决了脏读！但是存在不可重复读、幻读问题！事务 A 执行到一半，突然事务 B 从头到尾执行完了，在事务 B 执行完到事务 A 结束完这段时间查询数据可能发生了变化。 Orcle 默认是这个级别。 每次读取都是新的快照。\n  可重复读（Repeatable Read）：\n事务A开始之后，不管多久，同一事务内读取到的数据都是一致的，相当于读取的是事务开始执行时拍下的快照。即使A事务执行过程中事务B已insert并提交了，事务A读取到的数据条数仍然没变。解决了不可重复读问题，但是存在幻读问题！ 可能A事务执行到一半，B事务执行完了，在事务中查询到的数据是读到了假象，其实数据条数已经变了，只是在事务中是没有改变，事务后再读取就改变了，改变的如果是事务B插入的就是幻读，如果是事务A插入的就不是幻读。可重复读不允许其他事务 进行update操作，但允许其他事务进行insert操作。这是MySQL默认隔离级别。每次读取都是第一次的快照。\n  序列化读（serializable）：\n表示事务排队，不能并发！\n如何解决幻读   首先我们知道快照读是普通的 select。\n快照读不会加锁，当前读会加锁。\n除了普通 select 操作，其余操作都是当前读。也正因为普通的查询是都快照读，所以当前事务是不会看到别的事务插入的数据的。\n因此，幻读问题在 “当前读”下才会出现。当前读就是读取最新版本数据。\nMySQL 通过加 Next-Lock Key（行锁+间隙锁） 的方式来解决幻读，Next-Lock Key 锁的规则比较复杂，在某些情况会退化为行锁、间隙锁来提高效率。\n通过锁住对应的范围来防止其他事务对该范围内数据进行增删进而防止改变数据条数。但是注意 Next-Lock Key 锁住的是索引，不是数据本身，如果 where 后无索引列，那么相当于整个表都被锁死，直到事务结束。\n对应的 RC\u0026ndash;\u0026gt;RR 当前读的不可重复读是靠行锁解决。\n加锁语法\nselect \u0026hellip; lock in share mode：加共享(S)锁\nselect \u0026hellip; for update：加排他(X)锁\ninsert / update / delete：加排他(X)锁\nNext-Key Lock 的算法 假设索引 a 有1，3，5，8，11，其记录的GAP的区间如下：是一个左开右闭的区间（原因是默认主键的有序自增的特性） （-∞,1]，(1,3]，(3,5]，(5,8]，(8,11]，(11,+∞） select * from t where a = 3 for update; 那么锁住的范围有 (1,3）3，(3,5] 即 当前行+两边的间隙 (1,3]，(3,5]， 这些范围的行数据和索引都被锁住，所以可以防止 insert 或者 delete 带来的幻读。\n但是注意，对于RR默认使用的就是 next key lock，但是对于“唯一索引” ，比如主键的索引，next key lock 会降级成行锁 Record Lock ，即仅锁住索引本身，而不会锁住一个区间。唯一索引的等值条件就是从 next lock key降级成行锁。\n而范围条件如\nselect * from t where a \u0026gt; 3 for update;\n就降级到间隙锁锁住(3,5]。如果条件是\u0026gt;=3那就是行锁+间隙锁都用上了。  锁机制 锁分了乐观、悲观两大类别\n悲观锁和乐观锁区别如下： 悲观锁是在是否能操作数据上就做了处理。假设会发生冲突。\n悲观锁的实现 悲观锁是数据库已实现的，如共享锁、排它锁。\n共享锁 又称为读锁，如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁读取数据——直到该数据对象上的所有共享锁都被释放。修改是唯一的，必须等待前一个事务commit， 才可进行操作，因此，如果同时并发太大可能很容易造成死锁。\n排它锁 又称为写锁或独占锁，如果事务 T1 对数据对象 O1 加上了排他锁，那么在整个加锁期间，只允许事务 T1 对 O1 进行读取和更新操作，其他任何事务都不能再对这个数据对象进行任何类型的操作（读、写）——直到 T1 释放了排他锁， 结果是超时或者等待第一个事务提交后再执行，相当于行锁。\n排它锁和共享锁区别：\n加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。\n误区：对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个认知错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。 排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。MySQL 的 InnoDB 引擎自动的给修改数据语句（update,delete,insert）涉及到的数据加上排他锁，select 语句默认不会加任何锁类型。因此可以说明数据只要不加锁， 普通的 select\u0026hellip;form\u0026hellip; 是没有问题的，而加锁的 select 就读不到，值得一提的是加共享锁、排它锁都是显式的加锁，但是隐式的加锁（insert、delete、update）也读不到数据，原因就是不能加锁。\n手动给查询语句加排它锁：select \u0026hellip; for update。\n手动给查询语句加共享锁：select \u0026hellip; lock in share mode 。\n所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过加排他锁或共享锁的方式查询数据，但可以直接通过select \u0026hellip; from \u0026hellip; 查询数据，因为普通查询没有任何锁机制。\n乐观锁下大家都可以同时写数据只是在提交的时候做了处理。乐观的假设不会发生冲突。\n乐观锁可以避免数据库幻读、业务处理时间过长等问题，适合读多写少，可以提高程序的吞吐量解决了写-写冲突。 而乐观锁要自己实现，如何实现呢？\n乐观锁的实现 CAS Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。\n版本号控制 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时， 若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\nMVCC MVCC其实就是乐观锁的一种实现方式，MVCC只能在读已提交（RC）和可重复读（RR）两种隔离级别下工作，读未提交总是会读到最新的数据行，而不是符合当前事务版本的事务行的快照读，串行化是通过加锁互斥数据，因此不存在隔离问题。\n不好理解？\n那换句话说：\n对于使用Read Uncommitted隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；\n对于使用Serializable隔离级别的事务来说，InnoDB使用加锁的方式来访问记录。 MVCC如何工作：\nMVCC是一种基于版本链的无锁并发控制，即使有读写冲突时，也能做到不加锁，非阻塞并发读。\nMVCC仅在RC、RR下运作，原理就是 Read View（快照读） 四个参数、数据库表的两个隐藏列。 Read View 四个参数：活跃事务列表（m_ids）、最小活跃事务id（min_trx_id）、最大活跃事务id+1（max_trx_id）、创建当前 Read view 的事务 id（**creator_trx_id **）。\n数据库表两个隐藏列：\ntrx_id：当一个事务对某条聚簇索引记录进行改动的事务 id。\nroll_pointer：指向上一版本的 undo 日志。\nMVCC 在 RC、RR 下的工作\n一个事务访问记录时除了自己的更新记录可见（trx_id = creator_trx_id），就是隔离级别分辨哪些版本的记录对当前事务可见。\n分辨 已提交的事务、活跃事务、未开启的事务\n通过 trx_id 比较是否 \u0026lt; min_trx_id 或是 \u0026gt;= max_trx_id，是的话该事务就不在活跃事务列表也就不是活跃事务，小于是已提交事务，大于等于是未开启的事务版本记录。 又或是 min_trx_id \u0026lt;= trx_id \u0026lt; max_trx_id，那么当前记录可能在活跃事务列表，需要判断 trx_id 是否在 m_ids 列表中：存在就是活跃事务版本，否则就是已提交事务。\nRC\n因为每次查询数据都会生成一个 read view 所以其中的四个参数一直在变，因此每一次都可以拿要查询的记录的 trx_id 去查询该事务是否已提交，只要是已提交的事务版本就可见，如果未提交就沿着 undo log 链条往下找旧版本的记录 ，直到找到已提交。\nRR\n因为每次查询都是该事务开启时生成的 read view ，所以每次拿到要找的记录的 trx_id 去和 对应 read view 对比找到已提交的最终版本（和RC一样步骤）。\ntrx_id 如何联系 read view\ntrx_id 隐藏列 与 creator_trx_id 参数。\n事务版本号如何计算 事务版本号随着事务的开启顺序依次递增。 存储引擎 MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。 MySQL默认的存储引擎是InnoDB，默认字符集是UTF-8，建表时指定存储引擎和字符编码方式。 MySQL支持九大引擎，版本不同支持情况不同。 存储引擎表示不同的数据在磁盘中的不同组织形式。\n MyISAM存储引擎？ 它管理的表具有以下特征：只支持表锁、不支持外键、不支持回滚。 格式文件 - 存储表结构的定义（mytable.frm） 数据文件 - 存储表行的内容（mytable.MYD） 索引文件 - 存储表上的索引（mytable.MYI） MyISAM优势：可被转化为压缩、只读表来节省时间。 InnoDB存储引擎 这是MySQL默认的存储引擎，是个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。支持表锁行锁。 InnoDB存储的特点：非常安全。 MEMORY存储引擎 数据存储在内存中，且表的长度固定，这两个特点使得MEMORY存储引擎非常快。不安全，关机数据消失。  InnoDB中存储数据 InnoDB中存储数据是按行存储的，但数据库的读取是以页为单位读取，也就是说当需要读取一条数据时，并不是将这个记录本身从磁盘中读取出来，而是以页为单位，将其整体读入内存。也因此数据库的 I/O 操作的最小单位也是页， InnoDB的数据页默认大小为16KB。也就是说一次至少把 16KB 的内容读取到内存。\n数据页由7个部位\n主从复制 主从复制的作用  读写分离，降低服务器压力实现了负载均衡。 主服务器出现故障时可切换到从服务器，提高性能。 从服务器备份避免备份过程影响主服务器服务，确保数据安全。  主从复制的原理 数据库下bin-log二进制文件，记录了所有的sql语句，把主数据库下的bin-log文件的sql语句拷贝过来让其在从数据库的redo-log（重做日志文件）再执行一遍这些sql语句。需要三个线程操作。\n1. binlog线程：每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建下列的两个线程进行处理；\n2. dump线程：主节点为每一个从节点创建一个 dump 线程，当 binlog 有变化，dump 线程就会通知从节点，并将 binlog 传递给从节点的 IO 线程。\n3. Io线程：当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，接收到了内容后写入到 relay log（中继日志），再返回给主库“复制成功”的响应。 4. Sql线程：从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。\n主从复制和主主复制区别 最大区别是： 主从复制是对主数据库操作数据，从数据库会实时同步数据。对从数据库操作，主数据库不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主复制则是无论对哪一台操作，另一个都会同步数据。一般用作高容灾方案 。\nlimit使用  当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量,例如 select * from user limit 1,3; 取到 2，3，4 当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。例如select * from user limit 3 offset 1; 取到 2，3，4  索引 索引是在存储引擎用于提高数据库表的访问速度的数据结构，如果不添加索引查询会加载所有的数据进内存依次检索。\n索引在数据库表的字段上添加，为了提高查询效率。一张表的一个字段可以添加一个索引，也可以多个字段联合。\n索引的使用场景  数据量庞大。 该字段常出现在where后面，以条件形式存在，也就是说这个字段总是被扫描。 经常用于 GROUP BY 和 ORDER BY 的字段。 该字段很少的DML（增删改）操作。因为DML之后，索引需要重新排序。  索引的设计原则  区分度越高越好。 尽量使用短索引，较长字符串进行索引的时候应该指定个较短前缀，因为较小索引 I/O量小查询速度快。 索引不是越多越好，每个索引要花额外的物理空间，维护要需要时间。 利用最左前缀原则。  根据索引查询的原理 例如 select * from t_user where id =101；发现id字段上有索引先通过索引对象idIndex进行树的查找，通过 id=101 得出物理编号0x666 ，此时会转换SQL语句为： select * from t_user where 物理编号 = 0x666；\n索引分类 单一索引、联合索引、主键索引、唯一性索引。（唯一性弱的字段添加索引用处不大）。 MySQL 中如果有 unique 约束也会自动创建索引对象，其实殊途同归，任何数据库的主键都会自动添加索引对象，其实都是为唯一键建立的索引，而主键是唯一且非空。\n在MySQL 中，索引是一个单独的对象，索引在不同的存储引擎以不同形式存在。\nMyISAM 存储引擎中，索引存储在.MYI 文件中。\nInnoDB 存储引擎中索引存储在一个逻辑名 tablespace 的空间当中。\nMEMORY 存储引擎中，索引存储在内存当中。\n不管索引存储在哪里，索引在 MySQL 当中始终都是树的形式存在。\n索引要排序，排序了才有区间查找，并且这个索引的排序和 TreeSet 数据结构相同，一个自平衡的二叉树。\nMySQL的数据存储在磁盘中，查询慢一般卡都是在 I/O 过程，尽可能减少 I/O 的次数和 I/O 的量，可以有效优化查询速度，而这二者之间更重要的又是 I/O 次数。因此“矮胖”型的树结构是性能最高的。\n索引的存储 索引存储的时候需存文件地址、偏移量offset、key，可以用 哈希表，树（二叉树、红黑树、AVL树、B树、B+树）为什么最后用B+树存。\n为什么不用哈希表来存(k-v)\n首先哈希表来存确实有个优点就是：等值查询时，速度很快！但同样它有以下缺点如：\n 哈希冲突导致数据散列不均匀，会产生大量的线性查询，比较浪费时间。 必须等值判断来查询，不支持范围查询，当进行范围查询时必须挨个遍历。 对于内存空间的要求比较高，要把所有数据加载到内存才能操作找到对应的数据。   MySQL 中常见的存储引擎有没有hash索引\n memory 存储引擎使用的是hash索引。 Innodb 支持自适应 hash 索引，key 是索引列的 hashcode，指向行记录的指针是 value 。查找一条数据的时间复杂度O（1），多用于精确查找。   为什么不用普通树的结构 如果用的是普通二叉树，那数据插入是递增的时候就会从二叉树 O（logn）退回成链表 O（n）。但是可以通过左旋或者右旋让树平衡起来弥补这一缺陷，此时形成的是 AVL （平衡二叉树）： 最短子树跟最长子树高度只差1，为了保证平衡，在插入数据的时候必须要旋转，通过插入、删除性能的损失来弥补查询性能（插入、删除会调整节点）。\n但是此时又出现了新的问题：如何 读 \u0026raquo; 写，AVL 是划算的，但是读写差不多甚至 写 \u0026raquo; 读 呢？\n所以就要左旋右旋的次数减少来提高增删的效率。怎样使得它更少的旋转呢？\n为什么不用红黑树 通过变色减少旋转的次数，最长子树只要不超过最短子树的两倍即可，既有旋转又有变色，使得插入和查询性能近似取得平衡。但是随着数据的插入，发现树的深度会变深，树的深度越深，意味着 IO 次数越多， 影响数据的读取效率，而且由于局部性原理（经常被查询的数据有聚集成群的倾向，同时刚被查询的数据有可能很快被再次查询）、磁盘预读，使得它不得不做出改变，做出了在树的横向做文章 的改变，一个头节点对应多个子节点就解决了这个问题，这是采用的数据结构就是 B树 了，树的深度会小很多，一般\u0026lt;=3，深度是算出来的，不是指定的。这种情况下实际存储的数据为：key，完整的数据行。但 是它叶子节点和非叶子节点都存有数据行使得树在每一深度的索引都存的十分有限，不理解？\n举个例子：假设一个磁盘块的大小为 16k ，假设一条行数据 1k ，树深度为三层。\n第一层 16k 最多存 16 个行记录。\n第二层能存 16×16 个行记录。\n第三层 161616条记录 = 4096条。\n这效率太低了吧？\n只让叶子节点存数据，非叶子节点只存 索引 和 key 值，一二层就能存更多的磁盘块索引，这就是 B+ 树。我们来算算，如果没有创建主键约束、唯一键约束、系统会自生成 6字节的 rowId 给它作为聚簇索引 的 key 是 6+6（指针大小在 InnoDB 源码中设置为6字节），这能存多少？大概两千多万。而且 B+树 的叶子节点用指针连接，提高区间访问性能也方便扫库。那索引是用 int 还是 varchar 呢？Varchar超过四 个字节用 int ，小于四个字节用 varchar，因为空间固定是16kb，每个索引*索引个数\u0026lt;= 16kb，占的单个字节越少，存储的字节就可以越多。索引的创建和存储引擎是挂钩的。是否是聚簇索引取决于数据是否和 索引放在一起。Innodb 只能有一个聚簇索引（为了防止数据冗余，如果有多个聚簇索引，就会导致一份数据存多份，多个索引，只能有一个作为 key，如果多个作为 key 就冗余了），但是可以有很多非聚簇索引 ：向 innodb 插入数据时必须要包含一个索引的 key 值，这个索引的 key 值可以是主键，如果没有主键就是唯一值，如果没有唯一值那就是自生成的6字节的 rowId 当聚簇索引 key 。如果一个表中的普通列创 建了索引，那么叶子结点存放的值是聚簇索引的 key 值。 Myisam 全是非聚簇索引，但是与 innodb 中不同的是，innodb 直接放数据行，myisam 放的是数据行地址，根据地址再去找数据。聚簇索引是和数据文件和索引文件放在一起的索引。 *B+树三层怎么算的（n叉查找树） 三层可以存储大约2千万行数据\n InnoDB存储引擎默认最小存储单元是页，默认一个页的存储大小是16K（可以修改，通过设置参数innodb_page_size） InnoDB的所有数据文件（后缀为ibd的文件）它的大小始终是16K的整数倍 页可以存储数据也可以存储键值+指针，在B+树叶子节点存放数据，非叶子节点存放键值+指针 如果这一页存储的是非叶子节点，假设主键id为bigint类型，长度为8个字节，页号在InnoDB中是4个字节。这样一共12个字节，则一页能能存储多少个这样的单元，就代表一页能存储多少指针，即大约16384/12=1280 个指针 如果这一页存储的是叶子节点，假设一行记录大小为1K(实际上很多互联网业务数据记录大小通常就是1K左右），则一页可以存储16条记录。 若一颗高度为2的B+树，则能存放大约1280 X 16 = ？条记录 ，为什么X16：1层的16k数据页可以放1280 个（索引+指针），分布到第二层是1280 个数据页，每个数据页不仅仅包含这一条1k的行记录，而是还有其他15k行记录。 同样，若一棵高度为3的B+树，能存放1280 X 1280 X 16 = 2.45k万数据。 所以InnoDB中B+树的高度一般为1~3层，就能满足千万级的数据存储。 在查询数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1~3次 I/O 操作即可查找到数据。  索引的失效  对一个索引字段模糊查询时%写在索引左边失效（特殊情况：表里 只有该字段+聚簇索引）优化器判定可以索引覆盖也就无需再全表扫描，除非有其它非聚簇索引字段，那么需要走两张表而且左模糊查询并不能体现b+树的有序性查找性能，还不如只走聚簇索引树全表扫描一张表。 使用or的时候可能失效，要求or两端的字段都有索引才会走索引，union不会让索引失效。 （最左原则）使用复合索引的时候没有使用索引左侧的列查找，索引失效。 where当中索引列参与了运算，索引失效。 在where中索引列使用了聚合函数。Explain select * from zs_case where lower(case_name)=’rxy’;   、\u0026lt;、!=、not in、in、IS NULL或者IS NOT NULL都会导致。\u0026gt;=、\u0026lt;= 不会。\n  对全表扫描速度比索引速度快的时候不会使用索引。 对索引隐式类型转换。  回表、索引覆盖 回表：以非聚簇索引查找包含非聚簇索引的内容。\n索引覆盖：以非聚簇索引查找聚簇索引。\n一张表四个字段 （id，sex，name，age，name）是索引列，主键是id，select * from table where name=‘rxy’ 该语句先会根据非聚簇索引 name 字段查询到 id，再根据聚簇索引 id 字段查询整行记录，走了两棵 b+树，此时这种现象叫做回表。\nb+树分为非聚簇索引树和聚簇索引树，聚簇索引树叶子节点存放行记录，非聚簇索引树叶子节点保存了2列（聚簇索引，该非聚簇索引）数据。\n就是根据普通索引查询到聚簇索引的 key 值后，再根据 key 值在聚簇索引中获取行记录。如果是 select id,name from table where name=‘rxy’； 该语句根据 name 可以直接查询到 id ，name 两个字段，直接返回即可，不需要从聚簇索引查询任何数据，此时就不需要回表，叫做索引覆盖，走一棵 B+ 树\n回表会增加IO量，会影响效率。 索引下推 索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。\neg：联合索引(A,B,C) 如果 where A=？ and C=？ 无索引下推会走索引 A 从引擎层返回数据到 server 层再在 server 层过滤 C。 而有索引下推直接在引擎层走了 A、C ，因此减少了回表数据。\n设计数据库时id要不要自增 尽量自增，自增不会影响前面的磁盘块，如果不自增，可能插入一个数据在一个容量不够的磁盘块中，则会磁盘块分裂（页分裂），类似的操作删除会导致页合并。\n分裂调整效率比较低，而自增直接append效率比较高。或者说，id由UUID随机生成，比较分裂，随机插入，会造成频繁页分裂，内存碎片化，大量随机IO。 最左匹配原则 联合查询下：\nMySQL内部有优化器： select * from table where 最左索引 = ‘ss’ and 其他索引 = ‘hh’；\n把两个索引位置对换也会走索引。因为优化器会重新把最左索引放在左边。但是如果where中没有用到最左索引，此时其他索引是无序的，就不会走索引。\n如果用范围查询，就会停止该索引字段之后的字段的匹配。\n比如 a = 1 and b = 2 and c \u0026gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，因为 c 字段是一个范围查询，从 c 开始都是无序的，它之后的字段会停止匹配。\n注：联合索引条件下，优化器调整的是写的sql的查询条件的顺序，调整成可以被走最多索引的顺序。\nMySQL常见的日志： redo log（重做日志）：用于掉电等故障恢复。\nundo log（回滚日志）\nbinlog（二进制日志）：全量日志，用于备份恢复、主从复制；\nredo logo redo log 是 InnoDB 引擎特有的，只记录该引擎中表的修改记录。\nbinlog 是 MySQL 的 Server 层实现的，会记录所有引擎对数据库的修改，所有引擎可见。\nredo log 是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。\nredo log 是基于两个文件环形文件组的循环写的，空间固定会用完，用完了就循环写；binlog 是可以追加写入的，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n而 redo log 实际本不需要那么多，因为 redo log只是保证 buffer pool 里的脏数据落盘，脏数据会依次落盘，并不会堆积着。如果满了，那么MySQL更新操作会被阻塞，\nredo log（重做日志）让 Innodb 有了崩溃恢复的能力，MySQL 实例挂了或宕机后重启时 Innodb 会使用 redo log 恢复数据，保证数据的完整和持久。\n后续的查询直接在查询缓存中查询，没命中再去硬盘加载，减少了 IO 开销。更新表时也是这样，发现缓存里存在要更新的数据，就直接在缓存里更新，然后会记录“哪个数据页做了什么修改”记录在 redo log 的缓存，接着刷盘到 redo log。\n理想状态是事务一提交就刷盘，实际上刷盘时机是根据策略来进行，有0，1，2三个策略。\n0：每次提交不刷。\n1（默认值）：每次提交都刷。\n2：每次事务提交都只把 redo log缓存写入 page cache（系统缓存）。\n另外Innodb存储引擎有一个后台线程，每隔一秒，就会把 redo log 缓存写到 page cache（系统缓存），然后刷盘。\n也就是说一个没提交的 redo log 记录可能也会被刷盘，因为在事务执行过程 redo log 记录是会写入 redo log 缓存，这些 redo log 会被后台线程刷盘，除了后台每秒一次刷盘还有一种情况会导致刷盘， 当redo log 缓存占用的空间即将达到 innodb_log_buffer_size 的一半时，后台线程会主动刷盘。 所以，为0时，MySQL 挂了或宕机了可能有一秒的数据丢失。\n为1时，redo log一定在硬盘里不会丢失，就算挂了，这部分日志也会丢失，但是事务并没提交，也不会损失。\n为2时，只要事务提交成功了，redo log缓存内容只写入page cache，如果是MySQL挂了不会丢失数据，宕机可能会有1秒数据丢失。\nbinlog用于复制，从库利用主库上的bin log进行传播，实现主从同步。\n事务提交的时候，一次性将事务中的 sql 语句（一个事物可能对应多个sql语句）按照一定的格式记录到 binlog 中。\nbinlog 与 redo log 很明显的差异就是 redo log 并不一定是在事务提交的时候刷新到磁盘，redo log 是在事务开始之后就开始逐步写入磁盘。\n事务提交后断电，redo log 恢复数据，提交前 redo log 恢复数据之后 undo log 回滚事务。\nbinlog\nMySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。\nbinlog 日志有三种格式，可以通过binlog_format参数指定。\n statement row mixed 指定 statement，记录的内容是SQL语句原文，比如执行一条 update T set update_time=now() where id=1\n同步数据时，会执行记录的 SQL 语句，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。  为了解决这种问题，我们需要指定为 row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据。\nrow格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。\nupdate_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（假设这张表只有 3 个字段）。\n这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。\n但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。\n所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。\nMySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。\nbinlog 写入机制：\nbinlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。\n因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。\n在写到内存是很快的，但再进一步刷盘持久化到磁盘也有对应的刷盘策略。\n0：表示每次提交事务都只write，由系统自行判断什么时候执行fsync。\n1：表示每次提交事务都会执行fsync，就如同 redo log 日志刷盘流程 一样。\nN：累积到了 N 个事务后才刷盘。\n两阶段提交\nredo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。保证主库数据。\nbinlog（归档日志）保证了MySQL集群架构的数据一致性。保证从库数据。\n二者都属于持久化的保证，但侧重点不同，只要有一个落盘不成功，就会导致主从数据不一致。\n在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n话说回来，假设执行过程中写完 redo log 日志后，binlog 日志写期间发生了异常，会出现什么情况呢？\n由于 binlog 没写完就异常，所以用 binlog 恢复数据时就会少了这次更新，而用 redo log恢复，则数据与用 binlog 恢复不一致。\n为了解决两份日志之间的逻辑一致问题，InnoDB 引擎使用两阶段提交方案。\n原理：将 redo log 的写入拆分为 prepare、commit 两个步骤。\n使用两阶段提交后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于prepare阶段，并且没有对应 binlog 日志，就会回滚该事务。\n但如果在 redo log “设置 commit 阶段”发生异常，是不会回滚事务的，因为虽然 redo log 是 prepare 阶段，但是能通过事务 id 找到对应的 binlog ，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n其它问题合集 数据库的读的延时问题 主库宕机后，数据可能丢失，从库只有一个 sql Thread，主库写压力大，复制很可能延时。\n如何解决？ 半同步复制解决数据丢失，并行复制解决从表复制延迟。\nExist和in的区别 exists是一个存在判断。\n如果后面的查询中有结果,则exists为真，否则为假，检测行的存在。\ndelete、drop、truncate 的区别 delete、truncate都只是删除表数据，而drop连表结构一块删除了，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。 delete是DML语句，可以回滚，但truncate、drop是DLL语句，不支持回滚。 执行速度：drop\u0026gt;truncate\u0026gt;delete\n视图 分为普通视图、物化视图。\n首先明白基本概念:\n 普通视图\n普通视图是不存储任何数据的，它只有定义，在查询中是转换为对应的定义SQL去查询。 物化视图\n物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，否则如果表很大的话，会在临时表空间内做大量的操作。\n物化视图也分为两种。  两种物化视图的区别 on demand 物化视图和 on commit 视图两者刷新方式不同，二者的区别在于刷新方法的不同。\nON DEMAND顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性；\n而 ON COMMIT 是说，一旦基表有了 COMMIT，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。\n为什么不推荐用外键？ 答：外键保障了数据质量，但是影响性能，每次 delete 或 update 都必须考虑外键约束，会导致开发痛苦，测试数据不方便。\n数据类型的优化？ 更小的通常更好：尽量使用不会超出范围的最小的占用空间的类型。\n简单就好：什么类型就用什么类型去存，如果是 ip 就调用方法转换成 int 类型去存。因为 int 比 字符串 节省很多空间。\n尽量避免使用 null：对于包含可为 null 列时很难优化。\n实际类型细则：\n整数类型：可以使用的几种整数类型：tiny int、small int、medium int、int、big int 分别是8、16、24、32、64 位存储位置。尽量使用满足需求的最小的数据类型。\n字符串类型：char、varchar、blob、text。（一个误区：文件大小和文件占用空间完全不同，因为 4kb 是一个读取数据的基本单元，那 4.01kb 的还是要占用两个 4kb 即两个基础单元（页）来存储，所以文件大小是 4.01kb， 占用空间是 8kb 。读一个数据会把该基础单元（页）里的数据都读进来这就是磁盘预读。）\nvarchar：使用最小符合需求的长度，varchar(n)，当 n\u0026lt;=255 时会用额外一个字节保存长度， n\u0026gt; 255 时会使用额外两个字节来保存长度， varchar(5) 和 varchar(255) 保存同样内容硬盘存储空间相同，但内存占用空间不同。varchar 在 MySQL 5.6 前变更长度从 255 变更到 255 以上会导致锁表。Char 最大长度 255 ，会删除末尾空格。\n时间戳类型：datetime 占 8 字节，与时区无关，数据库底层对时区对配置对其无效，不用要字符串类型来存，空间占用大。Timestamp 占 4 个字节，时间范围 1970-1-1 到 2038-1-19，精切到秒。Date类型占3个字节， 日期范围 1000-1-1 到 9999-12-31 。\n查询语句的执行顺序 from子句 \u0026ndash;\u0026gt; where子句 \u0026ndash;\u0026gt; group by子句 \u0026ndash;\u0026gt; 聚集函数\u0026ndash;\u0026gt; having子句 \u0026ndash;\u0026gt; select的字段 \u0026ndash;\u0026gt; Distinct（去重） \u0026ndash;\u0026gt; order by的字段 \u0026ndash;\u0026gt; limit\n表的关联项是从右到左解析，所以尽量把大的表项放在右边进行关联 group by（分组函数）不能直接在 where 子句中就是因为先执行 where 才执行分组 group by，where是无分组的过滤，having才是过滤分组。\nselect max (score) from zs_case\n该语句可以执行就是因为 select 在聚集函数后执行。\n查询如果分组 （group by） 了，那查询的字段只能和参与分组的字段相关，使用 having 可以对分完组后的数据继续过滤,但他必须和 group by 联合使用，而且 where 比 having 效率高。\n如果数据不分组，那整张表就默认为一组，分组函数自动忽略null，判断 null 用 isnull 而不是 = 。\n查询优化怎么做  减少请求的数据量：只返回有必要的列尽量避免 select * 、只返回有必要的行。 用 limit 限制、缓存重复查询的数据。 减少服务端扫描的行数：最有效就是避免回表（走两棵 b+ 树），而是尽量索引覆盖查询（走一棵 b+ 树）。 在表中建立索引，优先考虑 where、group by 使用到的字段。 where 子句模糊查询用在在字段后面，不要放在前面，否则会索引失效导致全表扫描。 尽量不要使用in 和 not in 和 or，会造成全表扫描。对于连续的数值，用 between 代替 in，对于子查询，用 exists 代替 in。union 代替 or，或者用 or 时两个字段都要是索引字段。 尽量不要在 where 子句中对字段进行表达式操作，会导致索引失效扫描整张表。 给字段添加默认值，不要对 null 进行判断，null 的判断会扫描整张表。  执行计划怎么看\n id：表项的查询顺序，注意是最大的先执行，也就是子查询先执行，查询的顺序如上。 table：查询涉及的表或衍生表。 select_type：  simple：不包含子查询或 union。 primary：包含子查询的 SQL 的最外层 select。 subquery：子查询中的第一个 select。 derived：派生/衍生表的 select, from 子句的子查询。 union：包含 union 的查询中的第二个或后面的 select 语句。 union result： union 的结果。   type：  ALL：全表扫描。 index：只扫描索引树，此时 select 的字段需要的字段不需要回表，则在 extra 会显示 using index。 range：索引范围扫描。 ref：非唯一性索引扫描，结果可能是多行，此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。 const、system：只有按照全部主键查询，执行计划type为const，也就是说此时查询出来的数据唯一，system就是其中特别的，表中只有一条数据，但在innodb中仍然显示为 const，而在 myisam 中显示 system。 eq_ref: 除了system和const类型之外,效率最高的连接类型；唯一索引扫描，对于每个索引键，表中只有一条记录与之对应；常用于主键或唯一索引扫描。   possible_keys：where子句包含的字段上若存在的索引，但该索引不一定被查询所使用。 key：MySQL查询实际使用到的索引。 key_len：表示索引占用的字节数。 ref：显示该表的索引字段关联了哪张表的哪个字段。 filtered：返回结果的行数占读取行数的百分比，值越大越好。 rows：根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。 extra：包含不适合在其他列中显示但十分重要的额外信息。常见的值如下  use filesort：MySQL会对数据使用非索引列进行排序，而不是按照索引顺序进行读取；若出现改值，应优化索引。 use temporary：使用临时表保存中间结果，比如，MySQL在对查询结果排序时使用临时表，常见于order by和group by；若出现改值，应优化索引。 use index：表示select操作使用了索引覆盖，避免回表访问数据行，效率不错。 use where：包含 where 子句。    排查MySQL问题的手段  show processlist命令查询当前所有连接信息。 Explain命令查询sql语句执行计划。 开启慢查询日志，查看慢查询的日志。  update语句执行流程  应用程序把 sql 发送到 server 端执行。 连接器：与客户端进行 TCP 三次握手建立连接；校验客户端的用户名和密码；读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限； 查询缓存：查询并清空查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 分析器 ：词法语法分析，提取表名查询条件。检查语法是否错误。 预处理器：检查表名字段名是否存在分析器 。 优化器 ：优化器根据自己的算法选择效率高的执行计划。 执行器 ：校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。 eg：更新会写日志文件。  ","permalink":"https://coderrenxy.github.io/posts/blog/%E6%88%91%E5%AF%B9mysql%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%E5%BF%B5%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...%E6%80%92%E8%82%9D16k%E5%AD%97-%E5%89%AF%E6%9C%AC/","summary":"​ 首先了解关于数据库一个误区，我们用的 MySQL、Oracle 都是 DBMS（数据库管理系统），用来操作数据的，而数据库是用来存数据的，而 sql 是","title":"我对MySQL的碎碎念念（持续更新...）怒肝12k字"},{"content":"首先二叉树的遍历分为，深度优先遍历（dfs）、广度优先遍历（bfs）。\n注意：但凡遍历都要注意根节点为 null；\n深度优先遍历又分为前中后序遍历，前面文章都讲过了，递归三个语句换个位置就解决了。\n注意：这里是深度优先遍历结果放在一个集合里 List 。广度优先遍历（层序遍历）才能分到不同的 List 中， {{1，3}，{4，1}}的形式。\n但凡是遍历，不论是深度（栈）、广度（队列），都是弹出一个再判断是否要塞（是否存在左右孩子）。\n深度优先的迭代做法后序遍历就是把前序的 left 、 right 压入顺序反转一下，再把得到的 List 反转一下，为什么？因为中前后（前序）、前后中（后序），后序逆转就是中后前，后前再逆转，就是中前后（前序）。关系明了吧！中序就不同，需要借助一个辅助的 cur 树节点，让其初始指向 root 根节点，利用 cur 和 stack 作为条件判空控制循环，然后 cur 不断变换位置。细节自己抠！前后序是 双if，中序 if\u0026hellip;else\u0026hellip;\n广度优先遍历（层序遍历）：\n递归（不推荐）方法利用 deep 控制深度。一个 if 判 root 空，一个 if（size \u0026lt; deep） 控制是否创建一个 List 存该深度的结点，resList.get(deep - 1).add(node.val); 最后两个递归完美收官。这里可以选择放入一个 List，也可以放入 List 中的 List，按需求来。\n迭代法（墙裂推荐！）：迭代法可以解决很多的遍历问题，而且很方便！主要就是利用队列，深度用循环来控制，条件为非空，那肯定是要不断有新的结点 offer 进来和 poll，这又要限制遍历一个深度再里面元素的次数了，这是又一个循环，这个循环不断进出，长度一直在变，所以要有个在内循环不变、外循环变化的 len 来控制内循环次数，每一次外循环都记录下该层深度的节点个数。\n根据遍历返回树后有感 到这里才发现。自己对遍历的认识是多么浅，别人写遍历的时候是根据遍历写代码，我是根据递归的代码来想遍历。这样也未尝是件坏事，至少把递归的前中后序遍历死死记住了.\n为什么前序求高度后序求深度?\n因为前序先走到叶子节点再 add，而后序是从头结点一路吃过去。add 我称为吃。\n其实理解递归/遍历 这样：\n前序：中左右：中是吃的操作，左右都是遍历，这样就能很好的理解遍历为何先进这个而不是那个。\nPS：堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树 。 持续更新中\u0026hellip;\u0026hellip; 如有错误，敬请斧正\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E7%BB%93/","summary":"首先二叉树的遍历分为，深度优先遍历（dfs）、广度优先遍历（bfs）。 注意：但凡遍历都要注意根节点为 null； 深度优先遍历又分为前中后序遍历","title":"二叉树遍历小结"},{"content":"正文\u0026hellip;. test\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/read/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E7%BB%93/","summary":"正文\u0026hellip;. test\u0026hellip;..","title":"以下暂为转载，作者《大白》"},{"content":" description：面试可能问到的异常相关八股文。\n （一）finally 块中的代码什么时候会执行？ 在 Java 语言的异常处理中，finally 块的作用就是为了保证无论出现什么情况，finally 块里的代码一定会被执行。\n由于程序执行 return 就意味着结束对当前函数的调用并跳出这个函数体，因此任何语句要执行都只能在 return 前执行（除非碰到 exit 函数），\t因此 finally 块里的代码也是在 return 之前执行的。\n此外，如果 try-finally 或者 catch-finally 中都有 return，那么 finally 块中\t的 return 将会覆盖别处的 return 语句，最终返回到调用者那里的是 finally 中 return 的值。\n（二）finally是不是一定会被执行到？ 不一定。\n下面列举两种执行不到的情况：\n 当程序进入 try 块之前就出现异常时，会直接结束，不会执行 finally 块中的代码； 当程序在 try 块中强制退出时也不会去执行 finally 块中的代码，比如在 try 块中执行 exit 方法。  （三）try-catch-finally中，如果catch中了return还会不会执行finally？ 会。\n程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally 块，最后再返回。\n因此，对基本数据类\t型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；而对引用类型是有影响的，返回的是在 finally 对 前面 return 语句返回对象的修改值。\n（四）try-catch-finally中哪个部分可以省略？ catch 和 finally可以省略其中一个，但必须保留其中一个。\ntry 只适合处理运行时异常，try+catch 适合处理运行时异常+普通异常。\n也就是说，如果你只用 try 去处理普通异常却不加以 catch 处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch 显示声明以便进一步处理。\n而运行时异常在编译时没有如此规定，所以 catch 可以省略，你加上 catch 编译器也觉得无可厚非。\n（五）Error和Exception的区别？ Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：\n Error 类： 一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防； Exception 类：分为运行时异常和受检查的异常。  （六）运行时异常与受检异常有何异同？  运行时异常：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。\n可以编译通过，但是一运行就停止了，程序不会自己处理； 受检查异常：要么用 try … catch… 捕获，要么用 throws 声明抛出，交给父类处理。  （七）throw和throws的区别?  throw：在方法体内部，表示抛出异常，由方法体内部的语句处理；throw 是具体向外抛出异常的动作，所以它抛出的是一\t个异常实例； throws：在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理；表示出现异常的可能性，并不一定\t会发生这种异常。  （八）常见的异常类有哪些  NullPointerException：当应用程序试图访问空对象时，则抛出该异常。 SQLException：提供关于数据库访问错误或其他错误信息的异常。 IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。 IOException：当发生某种 I/O 异常时，抛出此异常。此类是失败或中断的 I/O 操作生成的异常的通用类。 ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数  （九）主线程可以捕获到子线程的异常吗？ 线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部”。\n正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。\n如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 Thread 的静态方法\nThread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/%E5%BC%82%E5%B8%B8/","summary":"description：面试可能问到的异常相关八股文。 （一）finally 块中的代码什么时候会执行？ 在 Java 语言的异常处理中，finally 块的","title":"异常"},{"content":"JAVA补充面试题 五种IO模型与理解 IO最常接触的场景是读取文件和等待网络信息，一般而言，用户态是不能够直接操纵IO的，这就说明一定要向操作系统调用IO，主要分为两步：（1）操作系统的内核态会先等待数据准备好，（2）再从内核空间将数据拷贝到用户空间。\n同步阻塞IO \r\r以计算机网络编程为例，会调用read方法读取数据，而本质上是调用了内核的recvfrom方法。\n  此方法会被阻塞住，直到数据报准备好，也就是1阶段。\n  然后在数据报被从内核复制到用户空间这一过程中，该线程会再次阻塞，直到复制完成，这一过程对应上图的序号2的过程；\n  无论数据有没有被准备好，此IO过程都会被阻塞，数据准备好时只会阻塞2阶段，数据为准备好会阻塞1，2两个阶段。\n同步非阻塞IO \r\r这个过程分为了两种情况：\n  数据未准备好时，会一直调用recvfrom函数，如果数据没准备好会返回EWOULDBLOCK错误。即不会将用户进程（线程）至于阻塞状态。\n  数据准备好后，此时recvfrom系统调用，用户进程（线程）还是会阻塞，直到内核中的数据报已经拷贝到了用户空间，此时用户进程（线程）才会被唤醒来处理接收的数据报。\n  但是，进程（线程）不断轮训，因此这是非常耗费CPU的。\nIO多路复用模型 阻塞和非阻塞模型的缺点是一个线程只能监控一个IO(也可以称为文件描述符fd)。如果系统并发度很高，线程就会大量创建，并不断轮训。系统资源会被大量浪费。\n\r\rIO多路复用的思想是用一个线程监听多个文件描述符。当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。\n\r\rIO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。\n\r\r信号驱动IO IO多路复用解决了一个线程监控多个fd的问题。但是还有一个大问题，等待数据准备中一直要轮询，这不是很傻逼吗？于是就有了信号驱动IO，当数据准备好后通知线程，而不需要轮询。\n\r\r首先需要在线程和fd之间建立一个SIGIO信号联系，这是通过sigaction建立的，当内核数据准备好后通过SIGIO通知线程。线程再调用recvfrom从内核拷贝数据到用户空间。\n\r\r信号驱动IO模型在等待数据报期间是不会阻塞的，即用户进程（线程）发送一个sigaction系统调用后，此时立刻返回，并不会阻塞，然后用户进程（线程）继续执行；当数据报准备好时，此时内核就为该进程（线程）产生一个SIGIO信号，此时该进程（线程）就发生一次recvfrom系统调用将数据报从内核复制到用户空间，注意，这个阶段是阻塞的。\n异步IO模型 \r\r异步IO最大的优点是在准备数据和拷贝数据两个过程都不会被阻塞。\n 用户进程发生系统调用时，会立刻返回，不被阻塞。执行其他任务。 当内核把数据拷贝完毕后，通知线程数据已经准备好，这个过程也不会阻塞。  异步IO模型跟信号驱动IO模型的区别在于当内核准备好数据报后，对于信号驱动IO模型，此时内核会通知用户进程说数据报准备好啦，你需要发起系统调用来将数据报从内核拷贝到用户空间，此过程是同步阻塞的；而对于异步IO模型，当数据报准备好时，内核不会再通知用户进程，而是自己默默将数据报从内核拷贝到用户空间后然后再通知用户进程说，数据已经拷贝到用户空间啦，你直接进行业务逻辑处理就行。\nJava中的IO模型，BIO,NIO,AIO BIO(Blocking I/O)同步阻塞IO 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量.\nNIO(Non-blocking/New I/O)多路复用IO Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\nAIO(Asynchronous I/O)异步IO AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n","permalink":"https://coderrenxy.github.io/posts/blog/io/","summary":"JAVA补充面试题 五种IO模型与理解 IO最常接触的场景是读取文件和等待网络信息，一般而言，用户态是不能够直接操纵IO的，这就说明一定要向操作","title":""},{"content":"思特奇 一面 1.自我介绍 和 项目介绍 \u0026hellip;\n2.Java有多少种数据类型 各占多少个字节 6数字，1字符，1布尔 int4，short2，byte1，long8，float4，double8，char2，boolean未说明，但按理说应该是1\n3.list 容器 ArrayList和LinkedList的区别 底层实现 ArrayList：数组 LinkedList：链表 插入删除，随机查找的区别\n4.ArrayList和LinkedList的应用场景 详细说说 排序插入删除，查找\u0026hellip;\n补充：（ 1.集合有几种类型，都有什么特点？ 4种，list，set，queue，map\n2.int和Integer有什么区别？ 略\u0026hellip; ）\n5.JVM了解吗 说说JVM的结构 类加载器 运行时区域 GC 编译器 JIT\n6.运行时数据区详细说说\n公有\u0026hellip; 私有\u0026hellip;.\n7.堆和栈有什么区别 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存 栈：每次方法调用的数据都是通过栈传递的\n8.GC 一般发生在哪个地方 GC发生在堆(heap)中\n9.多线程有了解过吗 了解过\u0026hellip;巴拉巴拉\n10.平时有用到吗？ 无\n11.那你说说框架里面哪些用到了？ 不知道\n12.设计模式有了解过吗 有，不过不多，只有单例模式和工厂模式\n13.说说单例模式和工厂模式 单例模式：巴拉巴拉 工厂模式：巴拉巴拉\n14.说说你的项目，都用到了什么 框架、数据库、Redis\u0026hellip;.\n15.说说你用到的框架 我着重说了SpringBoot AOP、IOC、为什么比Spring好、生态丰富\u0026hellip;.（一时紧张吧MVC忘记了）\n16.还有什么想问的？ 我还要再学点（补充点）什么？\n二面  为什么做这个项目(校园门户网站) 我看你们学校已经有了类似的没为什么还做呢? 你是组长的话都干了些什么 你说主要的数据库表是你来设计的,你那说说怎么设计 说说项目的每个模块 你的数据库表设计原则是什么 有什么校园经历,说说? 职业规划? 长远打算? 你还有什么要问的  ","permalink":"https://coderrenxy.github.io/posts/read/01%E6%80%9D%E7%89%B9%E5%A5%87/","summary":"思特奇 一面 1.自我介绍 和 项目介绍 \u0026hellip; 2.Java有多少种数据类型 各占多少个字节 6数字，1字符，1布尔 int4，short2，byte1，lon","title":""},{"content":"哈罗 开始\n1.自我介绍\u0026amp;项目介绍\n我的是新闻门户网站,介绍了一下都用到了什么技术,几个人开发,怎么协作\n2.先聊聊java基础,说说java面向对象的三大特征\n(ps:如果碰到了这个问题,能说多少说多少,拖时间,面试官一般不会轻易打断的) 封装继承多态,在延伸一些C++中的一些对比什么的\n3.接口和抽象类的区别?\n4.接口和抽象类的java版本不同,有了哪些变化?\n5.说说集合的种类\n6.HashMap底层实现 (ps:这里能扯得也很多,多说说别的来做对比,比如HashTable怎么怎么,比如扩容机制怎么怎么,能延伸多少是多少)\n7.解决哈希冲突的几种办法是什么?\n8.ConcurrentHashMap 和 Hashtable 的区别\n9.多线程知道吗,大概说说\n10.多线程的线程池讲一下,好处是什么?\n11.多线程的实现方式\n12.多线程线程池的参数都有什么,有哪些作用?\n13.多线程的拒绝策略有哪些?详细说说\n14.多线程的应用场景,详细说说 (ps:这里一般我们的项目接触不到,一定要去看看相关的案例什么的)\n15.ThreadLocal 原理和内存泄漏问题说说\n16.行,那来聊聊框架,说说spring和springboot的特点\n17.Spring/Spring Boot 常用注解\n18.单例 bean 的线程安全问题了解吗？\n19.数据库的事务都有哪些,用什么来保证这些特征\n20.一条sql怎么优化的呢?\n21.知道什么是覆盖索引和回表吗？\n22.什么是MVCC？\n23.直到redis嘛,Redis Stream消费者崩溃带来的会不会消息丢失问题\n24.Redis Steam 坏消息问题，死信问题\n25.说说Redis哈希槽的概念？\n26.Redis文件事件的模型,详细说说\n27.算法题:类似leetcode269 火星词典 (因为见过,这个题的思路很清晰,很快就写完了,面试官觉得不过瘾又来了一道)\n28.算法题:一道动态规划,没找到合适的类似题目\n你还有什么想问的吗?\n评价一下我的表现\n面试官:很不错,等消息吧\n","permalink":"https://coderrenxy.github.io/posts/read/02%E5%93%88%E7%BD%97/","summary":"哈罗 开始 1.自我介绍\u0026amp;项目介绍 我的是新闻门户网站,介绍了一下都用到了什么技术,几个人开发,怎么协作 2.先聊聊java基础,说说jav","title":""},{"content":"金蝶 一面  自我介绍 项目的架构图画一下 项目是怎么部署到服务器的 为什么要用 Docker 做项目的过程中遇到了什么问题没有，如何解决的，学到了什么。 项目数据库表怎么设计的 项目的日志怎么做的 项目有没有做权限管理，怎么做的 说一下自己对 IoC、AOP 的理解 网络协议说一下 数据库优化 有没有用过针对多表查询如何优化  HR面  自我介绍 学校的成绩，有没有获得过什么奖项 介绍一下项目，业务情况，当时是怎么做这个项目的 项目中充当的角色，负责做什么 项目带给你最大的收获是什么 说一件你在校园中做过对自己来说最有价值的事情 你觉得一个好的开发工程师应该具备怎样的素质 平时有健身运动的习惯么，频率怎么样 讲讲你的个人优势 手里的 offer 情况 反问  二面  Spring,Spring MVC,Spring Boot 之间什么关系? @Autowired 和 @Resource 的区别是什么？ 静态代理和动态代理的区别 除了 JDK 提供的动态代理实现还有其他实现方式么(CGLIB ) 谈谈对 MySQL 索引的了解，哪些字段应该考虑创建索引，哪些字段尽量不要创建索引 为什么 InnoDB 引擎要选择 B+Tree 作为索引数据结构？ MySQL 中 一条 SQL 语句的执行流程 从执行流程的层面说说如何优化一条 SQL 语句的查询速度，发生在哪个部分 多表联合查询的时候，SQL语句的执行流程 目前正在学习什么知识 反问：新人培训体系是怎么样的  三面  自我介绍 简单介绍一下自己的项目 项目中用了哪些设计模式 单例模式有什么好处 项目中用了线程池干什么 为什么实际生产建议使用 ThreadPoolExecutor 构造函数来创建线程池 如何理解线程安全和不安全 平时怎么学习的 反问：公司目前的技术栈，是否有 CodeReview  三面这个面试官基本没怎么问题技术，后面找我唠嗑半天就闲聊一些大学生活啥的。\n","permalink":"https://coderrenxy.github.io/posts/read/03%E9%87%91%E8%9D%B6/","summary":"金蝶 一面 自我介绍 项目的架构图画一下 项目是怎么部署到服务器的 为什么要用 Docker 做项目的过程中遇到了什么问题没有，如何解决的，学到了什么。 项目数据库表","title":""},{"content":"步步高 一面（50分钟）  介绍一下项目 项目是视频还是通过什么途径学习的？ 你认为项目中复杂的点是什么？ Redis的使用场景？ Redis的高并发是依靠什么去保证的？ ThreadLocal 用在哪，为什么选择 ThreadLocal呢？ 项目上线了嘛？部署在哪里？怎么部署的？ 注解实现缓存和日志统一处理是怎么做的？ SpringBoot分哪些模块？ 项目中的分页是怎么实现的？ 项目中都有哪些sql表说一下吧？ 消息队列MQ用过吗？说一下？- 分布式锁这块有用到吗？- 说一下常用的一些集合？ 说一下 HashSet的原理？ 说一下 HashSet 与 HashMap的区别？ 线程安全的集合类有哪些？ 锁重入了解过嘛？那些锁支持锁重入？ 说一下锁升级的过程？ 数据库中的锁有哪些？ Java8 的新特性 Stream 流、Lambda 表达式说一下？ TCP和HTTP 协议之间的关系，有什么区别？ TCP/IP 参考模型，每层都是封装的什么？ TCP是可靠的嘛？那么UDP呢？ TCP如何保证我们的可靠传输的？ 说一下TCP中拥塞控制的一个过程？ Linux查看ip地址的命令？ 说一下聚簇索引和非聚簇的区别？ 事务的隔离级别和每个级别所产生的问题? 实际开发中最常使用的隔离界别 创建线程的方式?说一下？ 讲一下同步和异步的区别？ 说一下项目中Nginx的作用？ 说一下JMM吧 说一下常见的垃圾回收算法吧？ JMM的三个特性是哪三个？ 如何保证原子性，volatile的作用呢？ ThreadLocal和synchronized的区别 Redis的rdb和aof说一下吧，区别呢？ 为什么fork一个子进程呢？ Redis有持久化为什么还要用MySQL呢？ MySQL数据也会有丢失的情况呀？是如何保证的呢？ 单节点和集群的区别，集群解决了什么问题？ 主从复制解决了什么问题？ Redis集群的原理 MySQL为什么要采用读写分离呢？ 除了MySQL、Redis外还了解过其他数据库嘛？ 用过Docker嘛？ 使用Docker部署的好处是什么？相比原始部署？ 最近看了哪些书呢？ 反问  二面(25分钟)  Redis为什么快？ 线程的创建方式？ 怎么在Linux服务器上部署项目？ 使用过Docker嘛？ Docker与Linux相比为什么性能更好？ 如何进行sql优化？你自己实践哪些手段？ 我们MySQL读写压力很大，怎么解决？ 说一下TCP三次握手、四次挥手？ MQ是什么？ 项目是怎么做的？实习项目还是自己做的？ 如何设计秒杀系统 实际开发中如何解决高并发的问题？你知道哪些手段？实践过哪些手段？ 校园的实践经历 为什么来参加春招，是没offer吗？ 手里有几个offer ？ 以后的发展方向是走技术管理，还是架构方向？ 说一下在你眼里技术管理和技术架构的区别？ 如果领导让你3天完成一个任务，但是你4天才能完成 谈一下你对加班的看法？ 你将来计划打算学到什么，提升Java哪方面技能？ 反问  三面（HR面，20分钟）  为什么会有写博客的习惯呢，出发点是什么？ 这个博客是有粉丝的吗？你有多少粉丝呢? 大学校园经历中有意义的一些事情？ 大学当中跟室友的关系怎么样？ 为什么没有参加秋招呢？ 找工作跟考研之间是怎么权衡的呢？ 讲一下在自己的个人项目中学到了什么呢？ 大学期间有没有低谷期间 手里有其他的公司的offer吗？ offer是哪家公司的？ 期望薪资是多少，年薪呢？ 反问  四面（终面，7分钟） 一个非常让人讨厌的领导，说话阴阳怪气的，开头第一句话就是你的成绩不咋地啊（无挂科平均成绩在80+）。\n 有没有实习的经验 ？ 为什么秋招没有找到工作？ 你是怎么学习一个技术的？说一个擅长的  ","permalink":"https://coderrenxy.github.io/posts/read/04%E6%AD%A5%E6%AD%A5%E9%AB%98/","summary":"步步高 一面（50分钟） 介绍一下项目 项目是视频还是通过什么途径学习的？ 你认为项目中复杂的点是什么？ Redis的使用场景？ Redis的高并发是依","title":""},{"content":"行云集团 自我介绍\n实习用到的技术栈和编程语言是什么？\n(实习是学校很水的5G通信实习，压根不沾边，随便就过了)\nJava是什么时候开始接触和学习的？\n学习数据结构的时候，对于Map这种数据结构，它的底层是怎么实现的或者有什么特征？\n(因为扯了大学学过数据结构就问了这个，但是Map没怎么接触，就扯了HashMap用了链表+红黑树，冲突少用链表，冲突多用红黑树，又扯了红黑树的基本原则和为了解决二叉查找树的平衡问题和JavaGuide里的B树B+树介绍，属于是乱答)\n做这个Map的时候，你自己用过什么类型的Map？不管是C++还是Java\n（还没用到过，就扯了用的比较多的是小项目里的链表啥的，顺便讲了下自己使用链表和做项目的思路）\n算法这块的话，排序算法接触过哪些算法？\n（讲了冒泡和快速，但是表示自己对快速的原理记得不是很清楚，含糊地说也不知道说了什么\u0026hellip;.） 他们的时间复杂度分别是多少？（冒泡n²，快速nlogn，也说了Java的一些类提供的方法应该用的比较多是快速排序）\n快速排序它的消耗稳定吗？\n（脑抽答了稳定，把平均和最差时间复杂度nlogn和稳定性混为一谈了，估计要g了）\n有学习过网络通讯吗？\n（表示还没开始学，但是了解过一点，比较含糊地讲了TCP三次握手四次挥手的基本过程原理，也是JavaGuide里的）\n有接触过并发编程吗？\n（表示有学过多线程的一些基本运用）\n还记得吗，比如怎么创建，开始一个线程之类的？\n（讲了创建线程的4种方式）\n你能举例一下什么时候会出现并发的场景吗？\n（不是很理解问题，乱答了一些比如要共同操作共享数据啥的，举了很低级的例子比如多个人向同一账户存款啥的可能会出现线程安全问题，感觉有点跑题了）\n可能是跑题了，接着面试官问 能举一个Java编程上的例子吗？比如什么样的代码可能会出现并发的风险？\n（多线程没怎么深入学，也可能是对问题有点懵，就表示现在还没有很深入的去学，又扯回刚刚的例子和线程安全问题，还扯了多线程的好处，太菜了）\n数据库这块主要接触的是哪个数据库？\n（还没学到，但是有过一些入门了解，说了前面的B+树是MySQL的索引数据结构）\nSQL最近有写过吗？\n（还没写，但是有了解过事务，讲了要么都执行要么都不执行，举了转账的例子，属于是乱答了。表示后面会深入去学）\n","permalink":"https://coderrenxy.github.io/posts/read/05%E8%A1%8C%E4%BA%91%E9%9B%86%E5%9B%A2/","summary":"行云集团 自我介绍 实习用到的技术栈和编程语言是什么？ (实习是学校很水的5G通信实习，压根不沾边，随便就过了) Java是什么时候开始接触和学习的","title":""},{"content":"中税汇金 1.你的redis怎么和mysql同步数据的？（我已经忘了我当时做的那个收藏功能同步没有同步，问下xdm这样的收藏功能一般是怎么做的）\n2.你的项目中有MinIO，是什么？\n3.左关联右关联内关联有什么区别？\n4.讲讲springAOP\n5.设计模式你也会？我看你写的有策略模式，讲一讲（感觉被质疑了）\n6.那你对sql优化这块有了解吗，做过什么优化吗\n7.你对集合熟悉吗，说一下ArrayList和HashMap的区别\n8.ACID你是真的会用还是只是看了一些资料（感觉又被质疑了，我就解释了一下4个特性），面试官：就相当于你是了解过4个特性，没有配置过每个特性对应的实际参数。\n9.我看你会查sql执行流程，那你知道怎么给他优化吗？\n10.建索引的原则，哪些字段可以建索引？\n11分库分表你用过吗\n","permalink":"https://coderrenxy.github.io/posts/read/06%E4%B8%AD%E7%A8%8E%E6%B1%87%E9%87%91/","summary":"中税汇金 1.你的redis怎么和mysql同步数据的？（我已经忘了我当时做的那个收藏功能同步没有同步，问下xdm这样的收藏功能一般是怎么做的","title":""},{"content":"字节大数据基础架构部门 字节面经 一面 2.17\n 自我介绍 接口和抽象类的区别 了解过啥设计模式 单例模式是啥 工厂模式的作用，为什么要用工厂模式？ 解耦, 把对象的创建和使用的过程分开(就是Class A 想调用Class B,那么只是调用B的方法，而至于B的实例化，就交给工厂类) 建造者模式的实现方式 在设计模式中你使用抽象类还是接口比较多 了解哪些Java锁 死锁的必要条件 Mysql索引了解吗(那时候不会就直接说不会了) MySql事务隔离级别 说一下你用过的Java框架 (说了Spring 的 ioc/aop 还没说aop就下一问了) 项目中如何使用git和maven的 代码题:  写一个快排 1. 快排是否稳定 2. 什么情况下会退化 3. 如何优化 4. 时间复杂度 写一个二分查找 1. 复杂度 代码题写的太快了, 然后他说时间还没到在问几个问题   了解分布式吗(NO) 说一下Java基础类型 为什么int是2的31次方 了解Docker吗(NO) 什么是Java同步和异步  反问: 1. 部门的业务 2. 对我的评价\n字节跳动二面 2.18\n 进程之间的通信 管道通信 命名管道通信 消息队列 共享内存 信号量 套接字 信号 说一下你了解的锁 说一下synchronized 和 reentranlock 介绍一下Reentrantlock 单例模式中变量前加的关键字(volatile) 单例模式并发下实现方式 双重检查锁(DCL) 内部类 枚举类 volatile的作用是什么 防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性 会主动刷新存储 聚集索引和非聚集索引的区别 1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。** 2.非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引** mysql三大范式说一个你了解的 mysql的ACID是什么 Maven包冲突怎么解决 介绍一下HashMap HashMap扩容了解吗?说一下扩容因子(loadFactor) 红黑树的特点, 为啥红黑树比较二叉树快   每条路上黑节点的数量是固定的, 高度限制搜索快 红黑树特点 :   每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 Redis为什么快? 直接操作内存 单线程没有多线程创建销毁的开销 IO多路复用 Redis缓存机制(我觉得应该是处理流程) 算法题: LeetCode 25 困难 K个一组反转链表改版(最后n个不足也反转)  字节面经 三面Leader面 - 2.21(挂)\n Object类里有什么方法 有用过Object类中相关锁的方法吗 wait notify notifyAll Java垃圾回收的方法新生代和老年代的不同的算法 设计模式中有用到锁的模式 如果没有使用两个锁单例会有什么问题 MySQL使用还是对他的原理有什么了解 使用JavaEE开发过一些项目吗 在开发项目中有什么问题吗, 然后最后解决了的 算法题: LeetCode 101简单  对称二叉树 还是题刷的不够多,没写到这题也没多写二叉树,我居然用BFS写的    ","permalink":"https://coderrenxy.github.io/posts/read/07%E5%AD%97%E8%8A%82%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E9%97%A8/","summary":"字节大数据基础架构部门 字节面经 一面 2.17 自我介绍 接口和抽象类的区别 了解过啥设计模式 单例模式是啥 工厂模式的作用，为什么要用工厂模式？ 解耦, 把对象的","title":""},{"content":"美团 一面  挖项目，问的太多了，这里就不一一列举了，大部分是某个功能是怎么实现的或者如果要加某个功能应该怎么实现。 进程线程区别。 死锁，死锁条件。 知不知道中断和轮询的区别。 数据库索引，讨论了一下B+树能存多少数据。 数据库存储引擎知道哪些，有什么区别。 数据库锁。 算法题：起始点到终点最短路径。  二面  问项目。 什么是序列化反序列化。 负载均衡，知道哪些负载均衡 。 什么时候会OOM，服务OOM怎么办，如何排查。 Spring 启动流程。 Spring 设计模式。 对于模版模式的理解，应用场景，你在项目中是怎么使用的。 HTTP 请求过程 。 TCP 和 UDP 区别。 Linux知道哪些命令。 设置索引有什么注意的地方。 最近看了哪些书，有什么收获。 算法题：合并有序数组 O(N)时间 O(1)空间。 数据库设计：只能以半小时为单位订会议室。  华为 一面  项目、论文。 String 能否被继承。 Java 内存泄露和排查。 Hash 方式和 Hash 冲突解决。 静态代理和动态代理。 线程通信方式。 Volitate关键字。 Java 高效拷贝数组。 算法题 跳跃游戏 leetcode 55。  二面  简单说说项目、论文。 项目是自己学习的还是落地项目。 本科保研绩点高，为啥研究生期间没有刷绩点。 对华为的了解，这个聊了比较久 因为我本身就是华为用户，比较了解，主管也给我介绍和补充。 实习时间。 反问部门、技术栈，是否可以自己选项目。  字节 一面  问项目，聊怎么实现，从项目里学到什么。 手写单例模式，和 Spring 的单例有什么区别。 算法题：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 SQL 题：根据题目要求写出对应的 SQL，由于太久没写，不会做。 智力题 1-N批次其中有一批次重量不合格 用最少称重次数找到  1） 刚开始说二分 面试官说不是最优\n2） 提示可以从每批次拿不同数量：第N批拿N个 算重量差值就可以确定\n二面  问项目。 volitate 关键字。 JVM新生代怎么划分，大对象怎么分配。 新生代有哪些垃圾回收器。 ParNew 原理。 Innodb 默认隔离级别，RR能防止幻读吗，RR默认使用间隙锁吗。 怎么理解最终一致性，有哪些实现方案。 分布式事务。 算法题：数组里每个数右边第一个比他大的数。  三面  问项目。 RAFT 脑裂、一致性。 负载均衡。 各种排序算法，分析复杂度和稳定性。 其他想不起来了，八股很少，一直问项目。 算法题：旋转图像(90度旋转矩阵)。  ","permalink":"https://coderrenxy.github.io/posts/read/08%E7%BE%8E%E5%9B%A2%E5%8D%8E%E4%B8%BA%E5%AD%97%E8%8A%82/","summary":"美团 一面 挖项目，问的太多了，这里就不一一列举了，大部分是某个功能是怎么实现的或者如果要加某个功能应该怎么实现。 进程线程区别。 死锁，死锁条件。","title":""},{"content":"念神面经篇 Java基础篇  JDK \u0026amp; JVM \u0026amp; JRE的区别 包装类型的常量池技术 接口和抽象类的区别 String、StringBuffer、StringBuilder的区别 泛型擦除的原理 反射的应用场景 异常的类型，具体的例子有哪些 说说常用的容器和各自的特点 ArrayList的扩容机制 HashMap源码实现 ConcurrentHashMap的底层实现 Lambda表达式有什么好处，什么坏处，应用场景有哪些  Java并发篇  为什么要使用多线程，有什么好处，举例具体场景 线程的生命周期以及每个周期进入和结束的标志 避免死锁的三个必要条件 简述哲学家进餐问题和银行家算法 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ 场景题：如何实现一个实时排序的游戏战力榜单 场景题：如何实现一个竞技场挑战功能，考虑高并发 volatile的用法 synchronized和ReentrantLock的区别 乐观锁和悲观锁的底层实现 不加锁如何保证线程安全 synchronized是可重入锁么 使用了vector就一定能保证线程安全吗 多线程的实现方式 场景题：高并发的情况下保证数据的一致性怎么做到 场景题：有10个线程分别对 i = 0 做10次自增操作，最后 i 的值会是多少，为什么 ThreadLocal的原理 场景题：在生产者消费者问题中怎么保证当消费者用完产品后生产者会马上得知，不能使用while循环去解决 Java的线程池类型有哪些 Java线程池的参数以及其具体意义 线程池的拒绝策略  JVM篇  JVM的基本结构 双亲委派模型的好处 运行时数据区的基本结构，各种结构都有什么用途 垃圾回收策略 垃圾回收器都有哪些 如何判断一个类是无用的类 查看运行内存，JVM状态有什么方法 G1回收器与之前的回收器相比最大的不同是什么 类加载的过程是什么，每个过程具体做到了什么事 JVM的常用参数有哪些 JVM调优常用的手段是什么  Spring篇  Spring的特性和优势是什么 Spring有哪些组件 场景题：如果实现一个你自己的Spring框架需要考虑那些方面，简单聊聊 Spring MVC底层实现原理 IOC 和 AOP 具体介绍一下 Spring Bean是什么 IOC 和 DI 是什么关系 IOC 配置的三种方式 依赖注入的三种方式 为什么推荐构造器注入方式？ 场景题：在使用构造器注入方式时注入了太多的类导致Bad Smell怎么办 AspectJ注解方式接触过吗，具体说说有什么特点和不足 Spring为何不能解决非单例属性之外的循环依赖？ Spring中Bean的生命周期介绍一下 场景题：自定义一个你自己的starter怎么实现（开共享屏幕实现）  MyBatis篇  接口层和数据库交互的方式有哪些 简述MyBatis的层次结构 sqlSessionFactory 与 SqlSession介绍一下 Excutor的概念 动态SQL有哪些，都有什么用途 为什么要使用连接池 $ 和 # 的区别  计算机网络篇  OSI和TCP/IP介绍一下 HTTP和HTTPS的区别 HTTPS的加密手段是什么 三次握手的过程以及每一次起到了什么作用 四次挥手的过程以及每一次起到了什么作用 TCP协议中的流量控制起到什么作用 介绍一下ARQ协议 从输入URL到页面加载发生了什么 HTTP 如何保存用户状态 Cookie 的作用是什么 Cookie 和 Session 有什么区别 HTTP状态码有哪些  数据库篇  数据库设计通常分为哪几步 MySQL的分页怎么做的 MyISAM和InnoDB的区别 MySQL日志都有什么，分别有什么作用 读锁和写锁实现的底层原理 表级锁和行级锁的实现原理 事务的特性 并发事务带来的问题有哪些 事务隔离级别有哪些 场景题：MySQL对于千万级的数据库或者大表怎么处理 MVCC解决什么问题 索引有什么作用 索引的底层数据结构 为什么InnoDB使用B+树作为索引的数据结构 索引有哪些种类 为什么会出现回表查询，怎么避免 解释一下最左前缀法则 覆盖索引是什么意思 MySQL读写分离方案 MySQL主从复制是什么意思 MySQL主从的延迟怎么解决  Redis篇  为什么Redis 是单线程的 Redis 一般有哪些使用场景 Redis 有哪些数据类型，每一种都有什么实际应用 sds存在的意义 为什么会设计Redis Stream Redis Stream消费者崩溃带来的会不会消息丢失问题 Redis Steam 坏消息问题，死信问题 Redis 的持久化机制是什么 AOF是写前日志还是写后日志 Redis 过期键的删除策略有哪些 Redis 内存淘汰算法有哪些 Redis如何做内存优化 Redis事务相关命令 Redis事务中出现错误的处理 为什么 Redis 不支持回滚 Redis缓存有哪些问题，如何解决 Redis6.0之前为什么一致不用多线程  ","permalink":"https://coderrenxy.github.io/posts/read/09%E5%BF%B5%E7%A5%9E%E9%9D%A2%E7%BB%8F/","summary":"念神面经篇 Java基础篇 JDK \u0026amp; JVM \u0026amp; JRE的区别 包装类型的常量池技术 接口和抽象类的区别 String、StringBuffer、StringBui","title":""},{"content":"百度Java中级面试 Spring BeanFactory 和 ApplicationContext 有什么区别 1、BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义， 以便在接收到客户端请求时将对应的 bean 实例化。\n2、BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始 化方法（initialization methods）和销毁方法（destruction methods）。\n3、从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。\n 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件  Spring Bean 的生命周期 1、Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。\n2、Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n 初始化之后调用的回调方法。 销毁之前调用的回调方法。  Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：\n  InitializingBean 和 DisposableBean 回调接口\n  针对特殊行为的其他 Aware 接口\n  Bean 配置文件中的 Custom init()方法和 destroy()方法\n  @PostConstruct 和@PreDestroy 注解方式\n  Spring IOC 如何实现 1、Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IoC 容器的基础。\n2、BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。\nApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的 WebApplicationContext。\n3、org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。\n说说 Spring AOP 1、面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有 update 方法的执行时间时间，操作人等等信息，记录到日志， 通过 spring 的 AOP 技术，就可以在不修改 update的代码的情况下完成该需求。\nSpring AOP 实现原理 1、Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类。\n2、如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB （Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final， 那么它是无法使用 CGLIB 做动态代理的。\n动态代理（cglib 与 JDK） 1、JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用 Java 动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而 CGLIB 则可以实现对类的动态代理。\nSpring 事务实现方式 1、编码方式\n 所谓编程式事务指的是通过编码方式实现事务，即类似于 JDBC 编程实现事务管理。  2、声明式事务管理方式\n 声明式事务管理又有两种实现方式：基于 xml 配置文件的方式；另一个实在业务方法上进行@Transaction 注解，将事务规则应用到业务逻辑中  Spring 事务底层原理 a、划分处理单元——IOC\n由于 spring 解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用 spring中的 IOC 划分了事务处理单元。并且将对事务的各种配置放到了 ioc 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。\nb、AOP 拦截需要进行事务处理的类\nSpring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用 TransactionProxyFactoryBean 接口来使用 AOP功能，生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取 ioc 容器事务配置属性，转化为 spring 事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为 TransactionAttribute 表示的数据对象。\nc、对事物处理实现（事务的生成、提交、回滚、挂起）\nspring 委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource 数据源支持、hibernate 数据源事务处理支持、JDO 数据源事务处理支持，JPA、JTA 数据源事务处理支持。这些支持都是通过设计PlatformTransactionManager、AbstractPlatforTransaction 一系列事务处理的支持。 为常用数据源支持提供了一系列的 TransactionManager。\nd、结合\nPlatformTransactionManager 实现了 TransactionInterception 接口，让其与TransactionProxyFactoryBean 结合起来，形成一个 Spring 声明式事务处理的设计体系。\n如何自定义注解实现功能 1、创建自定义注解和创建一个接口相似，但是注解的 interface 关键字需要以@符号开头。\n2、注解方法不能带有参数；\n3、注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的\n数组；\n1、注解方法可以有默认值；\n2、注解本身能够包含元注解，元注解被用来注解其它注解。\nSpring MVC 运行流程 1.spring mvc 将所有的请求都提交给 DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。\n2.DispatcherServlet 查询一个或多个 HandlerMapping,找到处理请求的 Controller.\n3.DispatcherServlet 请请求提交到目标 Controller\n4.Controller 进行业务逻辑处理后，会返回一个 ModelAndView\n5.Dispathcher 查询一个或多个 ViewResolver 视图解析器,找到 ModelAndView 对象指定的视图对象\n6.视图对象负责渲染返回给客户端。\nSpring MVC 启动流程 在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext, DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化了\nSpring MVC 总的组件。\nSpring 的单例实现原理 Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是\nConcurrentHashMap 对象。\nSpring 框架中用到了哪些设计模式 代理模式—在 AOP 和 remoting 中被用的比较多。\n单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。\n模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。\n前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。\n视图帮助(View Helper )—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。\n依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。\n工厂模式—BeanFactory 用来创建对象的实例。\nNetty 为什么选择 Netty   API 使用简单，开发门槛低；\n  功能强大，预置了多种编解码功能，支持多种主流协议；\n  定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；\n  性能高，通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优；\n  成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为NIO 的 BUG 而烦恼；\n  社区活跃，版本迭代周期短，发现的 BUG 可以被及时修复，同时，更多的新功能会被加入；\n  经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。\n  正是因为这些优点，Netty 逐渐成为 Java NIO 编程的首选框架。\n说说业务中，Netty 的使用场景 1、构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等， Netty 主要作为基础通信框架提供高性能、低时延的通信服务；\n2、公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的WebSocket 协议栈；\n3、各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。\n4、原生的 NIO 在 JDK 1.7 版本存在 epoll bug ，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些 而已，它并没有得到根本性解决。\n什么是 TCP 粘包/拆包 1、要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。\n2、待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。\n3、要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。\n\u0026gt; 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\nTCP 粘包/拆包的解决办法 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。\n2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将 不同的数据包拆分开。\nNetty 线程模型 首先，Netty 使用 EventLoop 来处理连接上的读写事件，而一个连接上的所有请求都保证在一个 EventLoop 中被处理，一个 EventLoop 中只有一个 Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个 EventLoopGroup 包含多个 EventLoop，可以把一个 EventLoop 当做是 Reactor 线程模型中的一个线程，而一个 EventLoopGroup 类似于一个 ExecutorService\n说说 Netty 的零拷贝 “零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。\nNetty 内部执行流程 1、Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2、Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一 个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer\n","permalink":"https://coderrenxy.github.io/posts/read/10%E7%99%BE%E5%BA%A6/","summary":"百度Java中级面试 Spring BeanFactory 和 ApplicationContext 有什么区别 1、BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义， 以便在","title":""},{"content":"京东Java中级面试 1、哪些情况下的对象会被垃圾回收机制处理掉？ 利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用链\n向下寻找，如果某个对象不能通过 GC Roots 寻找到，虚拟机就认为该对象可以被回收掉。\n1.1 哪些对象可以被看做是 GC Roots 呢？ 1）虚拟机栈（栈帧中的本地变量表）中引用的对象；\n2）方法区中的类静态属性引用的对象，常量引用的对象；\n3）本地方法栈中 JNI(Native 方法）引用的对象；\n1.2 对象不可达，一定会被垃圾收集器回收么？ 即使不可达，对象也不一定会被垃圾收集器回收，\n1）先判断对象是否有必要执行 finalize()方法，对象必须重写 finalize()方法且没有被运行过。\n2）若有必要执行，会把对象放到一个队列中，JVM 会开一个线程去回收它们，这是对象最后一次可以逃逸清理的机会。\n2、讲一下常见编码方式？ 编码的意义：计算机中存储的最小单元是一个字节即 8bit，所能表示的字符范围是 255 个， 而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻 译成计算机能懂的语言。\n1）\nASCII 码：总共 128 个，用一个字节的低 7 位表示，\n0〜31 控制字符如换回车删除等；\n32~126 是打印字符，可通过键盘输入并显示出来；\n2）ISO-8859-1,用来扩展 ASCII 编码，256 个字符，涵盖了大多数西欧语言字符。\n3）GB2312:双字节编码，总编码范围是 A1-A7,A1-A9 是符号区，包含 682 个字符，B0-B7 是\n汉字区，包含 6763 个汉字；\n4）GBK 为了扩展 GB2312,加入了更多的汉字，编码范围是 8140~FEFE，有 23940 个码位，能\n表示 21003 个汉字。\n5）UTF-16: ISO 试图想创建一个全新的超语言字典，世界上所有语言都可通过这本字典\nUnicode 来相互翻译，而 UTF-16 定义了 Unicode 字符在计算机中存取方法，用两个字节来表\n示 Unicode 转化格式。不论什么字符都可用两字节表示，即 16bit，固叫 UTF-16。\n6）UTF-8：UTF-16 统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪\n费存储空间，而 UTF-8 采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成。\n3、utf-8 编码中的中文占几个字节 int 型几个字节？\nutf-8 是一种变长编码技术，utf-8 编码中的中文占用的字节不确定，可能 2 个、3 个、4 个，\nint 型占 4 个字节。\n4、静态代理和动态代理的区别，什么场景使用？ 代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问， 将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。\n区别：\n1）静态代理：由程序员创建或是由特定工具生成，在代码编译时就确定了被代理的类是哪一个是静态代理。静态代理通常只代理一个类；\n2）动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类；\n实现步骤：a.实现 InvocationHandler 接口创建自己的调用处理器；b.给 Proxy 类提供ClassLoader 和代理接口类型数组创建动态代理类；c.利用反射机制得到动态代理类的构造函数；d.利用动态代理类的构造函数创建动态代理类对象；\n使用场景：Retrofit 中直接调用接口的方法；Spring 的 AOP 机制；\n5、Java 的异常体系 Java 中 Throwable 是所有异常和错误的超类，两个直接子类是 Error（错误）和 Exception（异常）：\n1）Error 是程序无法处理的错误，由 JVM 产生和抛出，如 OOM、ThreadDeath 等。这些异常发生时，JVM 一般会选择终止程序。\n2）Exception 是程序本身可以处理的异常，又分为运行时异常(RuntimeException)(也叫 Checked Eception) 和 非 运 行 时 异 常 ( 不 检 查 异 常 Unchecked Exception) 。 运 行 时 异 常 有 NullPointerException\\IndexOutOfBoundsException 等，这些异常一般是由程序逻辑错误引起的，应尽可能避免。非运行时异常有 IOException\\SQLException\\FileNotFoundException 以及 由用户自定义的 Exception 异常等。\n6、谈谈你对解析与分派的认识。 解析指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。\n分派可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。动态分派则需要根据实际类型来调用相应的方法。\n7、修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？ 会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和==都是比较栈内局部变量表中指向堆内存地址值是否相等。\n8、Java 中实现多态的机制是什么？ 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。这样就可以不用修改源程序，就可以让引用变量绑定到各种不同的类实现上。\nJava 实现多态有三个必要条件：\n继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。\n9、如何将一个 Java 对象序列化到文件里？ ObjectOutputStream.writeObject()负责将指定的流写入，ObjectInputStream.readObject()从指定流读取序列化数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //写入  try { ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\u0026#34;D:/student.txt\u0026#34;)); os.writeObject(studentList); os.close(); } catch(FileNotFoundException e) { e.printStackTrace(); } catch(IOException e) { e.printStackTrace(); }   10、说说你对 Java 反射的理解 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性。这种能动态获取信息及动态调用对象方法的功能称为 java语言的反射机制。\n反射的作用：开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用 java 的反射机制通过反射来获取所需的私有成员或是方法。\n  获取类的 Class 对象实例 Class clz = Class.forName(\u0026ldquo;com.zhenai.api.Apple\u0026rdquo;);\n  根 据 Class 对 象 实 例 获 取 Constructor 对 象\n  Constructor appConstructor = clz.getConstructor();\n 使 用 Constructor 对 象 的 newInstance 方 法 获 取 反 射 类 对 象 Object appleObj = appConstructor.newInstance();\n  获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\u0026ldquo;setPrice\u0026rdquo;, int.class);5) 利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14);\n  通过 getFields()可以获取 Class 类的属性，但无法获取私有属性，而 getDeclaredFields()可以获取到包括私有属性在内的所有属性。带有 Declared 修饰的方法可以反射到私有的方法，没有 Declared 修饰的只能用来反射公有的方法，其他如 Annotation\\Field\\Constructor 也是如此。\n  11、说说你对 Java 注解的理解 注解是通过@interface 关键字来进行定义的，形式和接口差不多，只是前面多了一个@\n1 2 3  public @interface TestAnnotation { }   使用时@TestAnnotation 来引用，要使注解能正常工作，还需要使用元注解，它是可以注解 到注解上的注解。元标签有@Retention @Documented @Target @Inherited @Repeatable 五种\n@Retention 说明注解的存活时间，取值有 RetentionPolicy.SOURCE 注解只在源码阶段保留， 在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到 JVM 中。\nRetentionPolicy.RUNTIME 可以留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。\n@Documented 注解中的元素包含到 javadoc 中去\n@Target\n限 定 注 解 的 应 用 场 景 ， ElementType.FIELD 给 属 性 进 行 注 解 ；\nElementType.LOCAL_VARIABLE 可以给局部变量进行注解；ElementType.METHOD 可以给方法进行注解；ElementType.PACKAGE 可以给一个包进行注解 ElementType.TYPE 可以给一个类型进行注解，如类、接口、枚举\n@Inherited 若一个超类被@Inherited 注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解；\n注解的作用：\n1）提供信息给编译器：编译器可利用注解来探测错误和警告信息\n2）编译阶段：软件工具可以利用注解信息来生成代码、html 文档或做其它相应处理；\n3）运行阶段：程序运行时可利用注解提取代码\n注解是通过反射获取的，可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了某个注解，再通过 getAnnotation()方法获取 Annotation 对象\n12、说一下泛型原理，并举例说明 泛型就是将类型变成参数传入，使得可以使用的类型多样化，从而实现解耦。Java 泛型是在Java1.5 以后出现的，为保持对以前版本的兼容，使用了擦除的方法实现泛型。擦除是指在一定程度无视类型参数 T，直接从 T 所在的类开始向上 T 的父类去擦除，如调用泛型方法，传入类型参数 T 进入方法内部，若没在声明时做类似 public T methodName(T extends Fathert){}，Java 就进行了向上类型的擦除，直接把参数 t 当做 Object 类来处理，而不是传进去的 T。\n即在有泛型的任何类和方法内部，它都无法知道自己的泛型参数，擦除和转型都是在边界上发生，即传进去的参在进入类或方法时被擦除掉，但传出来的时候又被转成了我们设置的 T。\n在泛型类或方法内，任何涉及到具体类型（即擦除后的类型的子类）操作都不能进行，如new T()，或者 T.play()（play 为某子类的方法而不是擦除后的类的方法）\n13、Java 中 String 的了解 1）String 类是 final 型，固 String 类不能被继承，它的成员方法也都默认为 final 方法。String对象一旦创建就固定不变了，对 String 对象的任何改变都不影响到原对象，相关的任何改变操作都会生成新的 String 对象。\n2）String 类是通过 char 数组来保存字符串的，String 对 equals 方法进行了重定，比较的是值相等。\n1 2 3  String a = \u0026#34;test\u0026#34;; String b = \u0026#34;test\u0026#34;; String c = new String(\u0026#34;test\u0026#34;);   a、b 和字面上的 test 都是指向 JVM 字符串常量池中的\u0026quot;test\u0026quot;对象，他们指向同一个对象。而new 关键字一定会产生一个对象 test，该对象存储在堆中。所以 new String(\u0026ldquo;test\u0026rdquo;)产生了两个对象，保存在栈中的 c 和保存在堆中的 test。而在 java 中根本就不存在两个完全一模一样的字符串对象，故在堆中的 test 应该是引用字符串常量池中的 test。\n例：\nString str1 = \u0026ldquo;abc\u0026rdquo;; //栈中开辟一块空间存放引用 str1，str1 指向池中 String 常量\u0026quot;abc\u0026quot;\nString str2 = \u0026ldquo;def\u0026rdquo;; //栈中开辟一块空间存放引用 str2，str2指向池中 String 常量\u0026quot;def\u0026quot;\nString str3 = str1 + str2;//栈中开辟一块空间存放引用 str3\n//str1+str2 通过 StringBuilder 的最后一步 toString()方法返回一个新的 String 对象\u0026quot;abcdef\u0026quot;\n//会在堆中开辟一块空间存放此对象，引用str3指向堆中的(str1+str2)所返回的新String对象。\nSystem.out.println(str3 == \u0026ldquo;abcdef\u0026rdquo;);//返回 false\n因为 str3 指向堆中的\u0026quot;abcdef\u0026quot;对象，而\u0026quot;abcdef\u0026quot;是字符池中的对象，所以结果为 false。JVM对 String str=\u0026ldquo;abc\u0026quot;对象放在常量池是在编译时做的，而 String str3=str1+str2 是在运行时才知道的，new 对象也是在运行时才做的。\n14、String 为什么要设计成不可变的？ 1）字符串常量池需要 String 不可变。因为 String 设计成不可变，当创建一个 String 对象时，若此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。\n如果字符串变量允许必变，会导致各种逻辑错误，如改变一个对象会影响到另一个独立对象。\n2）String 对象可以缓存 hashCode。字符串的不可变性保证了 hash 码的唯一性，因此可以缓存 String 的 hashCode，这样不用每次去重新计算哈希码。在进行字符串比较时，可以直接比较 hashCode，提高了比较性能；\n3）安全性。String 被许多 java 类用来当作参数，如 url 地址，文件 path 路径，反射机制所需的 Strign 参数等，若 String 可变，将会引起各种安全隐患。\n","permalink":"https://coderrenxy.github.io/posts/read/11%E4%BA%AC%E4%B8%9C/","summary":"京东Java中级面试 1、哪些情况下的对象会被垃圾回收机制处理掉？ 利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用","title":""},{"content":"蚂蚁面试题总结 1. jdk1.7到jdk1.8 Map发生了什么变化(底层)?\n1.8之后hashMap的数据结构发生了变化，从之前的单纯的数组+链表结构变成数组+链表+红黑树。也就是说在JVM存储hashMap的K-V时仅仅通过key来决定每一个entry的存储槽位（Node[]中的index）。并且Value以链表的形式挂在到对应槽位上（1.8以后如果value长度大于8则转为红黑树）。\n但是hashmap1.7跟1.8 中都没有任何同步操作，容易出现并发问题，甚至出现死循环导致系统不可用。解决方案是jdk的ConcurrentHashMap，位于java.util.concurrent下，专门解决并发问题。\n2. ConcurrentHashMap\n思路与hashMap差不多，但是支持并发操作，要复杂很多\n3. 并行跟并发有什么区别？\n并发：指应用交替执行不同的任务，多线程原理\n并行：指应用同时执行不用的任务\n区别：一个是交替执行，一个是同时执行。\n4. jdk1.7到jdk1.8 java虚拟机发生了什么变化?\nJVM中内存份为堆、栈内存，及方法区。\n**栈内存主要用途：**执行线程方法，存放本地临时变量与线程方法执行是需要的引用对象的地址。\n**堆内存主要用途：**JVM中所有对象信息都存放在堆内存中，相比栈内存，堆内存大很多所以JVM一直通过对堆内存划分不同功能区块实现对堆内存中对象管理。\n堆内存不够常见错误：OutOfMemoryError\n栈内存溢出常见错误：StackOverFlowError\n在JDK7以及其前期的JDK版本中，堆内存通常被分为三块区域Nursery内存(young generation)、长时内存(old generation)、永久内存(Permanent Generation for VM Matedata)，显示如下图：\n在最上面一层是Nursery内存，一个对象被创建以后首先被房到Nuersery中的Eden内存中，如果存活周期超过两个Survivor（生存周期）之后会被转移到Old Generation中。\n永久内存中存放对象的方法、变量等元数据信息。永久内存不够就会出现 以下错误：java.lang.OutOfMemoryError:PermGen\n但是在JDK1.8中一般都不会得到这个错误，原因在于：1.8中把存放元数据的永久内存从堆内存中已到了本地内存（native Memory）中，1.8中JVM内存结构变成了如下图：这样永久内存就不占用堆内存，可以通过自增长来避免永久内存错误。\n-XX:MaxMetaspaceSize=128m 这只最大的远内存空间128兆\nJDK1.8移除PermGen，取而代之的是MetaSpace源空间\nMetaSpace 垃圾回收：对僵死的类及类加载器的垃圾回收机制昂在元数据使用达到“MaxMetaSpaceSize”参数的设定值时运行。\n**MetaSpace 监控：**元空间的使用情况可以在HotSpot1.8的详细GC日志输出中得到。\n更新JDK1.8的原因：\n1.字符串存在永久代当中，容易出现性能问题和内存溢出\n2.类及方法的信息比较难确定其大小，因此对永久代的大小制定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n3.永久代会为GC带来不必要的复杂度，并且回收效率偏低\n4.Oracle可能会想HotSpot 与 JRockit 合并。\n5. 如果叫你自己设计一个中间件,你会如何设计?\n我会从以下几点方面考虑开发：\n1) 远程过程调用\n2) **面向消息：**利用搞笑的消息传递机制进行平台无关的数据交流，并给予数据通信来进行分布式系统的集成，有一下三个特点：\ni) 通讯程序可以在不同的时间运行\nii) 通讯晨旭之家可以一对一、一对多、多对一甚至是上述多种方式的混合\niii) 程序将消息放入消息队列会从小吸毒列中取出消息来进行通讯\n3) 对象请求代理：提供不同形式的通讯服务包括同步、排队、订阅发布、广播等。可构筑各种框架如：事物处理监控器、分布数据访问、对象事务管理器OTM等。\n4) 事物处理监控有一下功能：\na) 进程管理，包括启动server进程、分配任务、监控其执行并对负载进行平衡\nb) 事务管理，保证在其监控下的事务处理的原子性、一致性、独立性和持久性\nc) 通讯管理，为client和server之间提供多种通讯机制，包括请求响应、会话、排队、订阅发布和广播等\n6. 什么是中间件？\n中间件是处于操作系统和应用程序之间软件，使用时旺旺是一组中间件集成在一起，构成一个平台（开发平台+运行平台），在这组中间件中必须要有一个通信中间件，即中间件=平台+通信。该定义也限定了只有勇于分布式系统中才能称为中间件\n主要分类：远程过程调用、面向消息的中间件、对象请求代理、事物处理监控。\n7. ThreadLock用过没有,说说它的作用?\nThreadLock为本地线程，为每一个线程提供一个局部变量，也就是说只有当前线层可以访问，是线程安全的。原理：为每一个线程分配一个对象来工作，并不是由ThreadLock来完成的，而是需要在应用层面保证的，ThreadLock只是起到了一个容器的作用。原理为ThreadLock的set()跟get()方法。\n实现原理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; } return setInitialValue(); }    dubbox和spring cloud区别?\n  dubbox的源码看过没,dubbox有哪些组件,介绍下?\n  10. Hashcode（）和equals（）和==区别?\n(1) hashcode()方法跟equals()在java中都是判断两个对象是否相等\n(2) 两个对象相同，则hashcode至一定要相同，即对象相同 \u0026mdash;-\u0026gt;成员变量相同 \u0026mdash;-\u0026gt;hashcode值一定相同\n(3) 两个对象的hashcode值相同，对象不一定相等。总结：equals相等则hashcode一定相等，hashcode相等，equals不一定相等。\n(4) ==比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间）\n11. mysql数据库中,什么情况下设置了索引但无法使用?\n(1) 索引的作用：在数据库表中对字段建立索引可以大大提高查询速度。\n(2) Mysql索引类型：\na) 普通索引\nb) 唯一索引：唯一索引列的值必须唯一允许有空值，如果是组合索引，则列值的组合必须唯一：\nCREATE UNIQUE INDEX indexName ON mytable(username(length)) \u0026ndash; 修改表结构 ALTER mytable ADD UNIQUE [indexName] ON (username(length)) \u0026ndash; 创建表的时候直接指定 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );\nc) 主键索引：一种特殊的唯一索引，不允许有空值，一般在创建表的时候创建主键索引：\nCREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );\nd) 组合索引：CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );\n为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是\t将 name, city, age建到一个索引里：代码如下:\nALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);\n(3) 什么情况下有索引，但用不上？\na) 如果条件中有OR，即使其中有部分条件带索引也不会使用。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。\nb) 对于多了索引，不是使用的第一部分，则不会使用索引。\nc) Like查询以%开头，不使用索引\nd) 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引\ne) Where 子句里对索引列上有数学运算，用不上索引\nf) Where 子句中对索引列使用函数，用不上索引\ng) Mysql估计使用全表扫描要比用索引快，不使用索引\n(4) 什么情况下不推荐使用索引？\na) 数据唯一性差的字段不要使用索引\nb) 频繁更新的字段不要使用索引\nc) 字段不在where语句中出现时不要添加索引，如果where后含IS NULL/IS NOT NULL/LIKE ‘%输入符%’等条件，不要使用索引\nd) Where子句里对索引使用不等于（\u0026lt;\u0026gt;），不建议使用索引，效果一般\n12. mysql优化会不会,mycat分库,垂直分库,水平分库?\n(1) 为查询缓存优化你的查询\n(2) EXPLAIN select查询：explain 的查询结果会告诉你索引主键是如何被利用的\n(3) 只需要一行数据时使用limit1\n(4) 为搜索字段添加索引\n(5) 在关联表的时候使用相当类型的例，并将其索引\n(6) 千万不要ORDER BY RAND()\n(7) 避免select*\n(8) 永远为每张表设置一个ID\n(9) 使用ENUM而不是VARCHAR\n(10) 从PROCEDURE ANALYS()提取建议\n(11) 尽可能的使用NOT NULL\n(12) Java中使用Prepared Statements\n(13) 无缓冲的查询\n(14) 把IP地址存成UNSIGNED INT\n(15) 固定表的长度\n(16) 垂直分库：“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。\n(17) 水平分库：“水平分割”是一种把数据库中的表按行变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。\n(18) 越小的列会越快\n(19) 选择正确的存储引擎\n(20) 使用一个对象关系映射器\n(21) 小心永久链接\n(22) 拆分大的DELETE活INSERT语句\n13. 分布式事务解决方案?\n(1) 什么是分布式事务？\na. 什么情况下需要用到分布式事务？\na) 当本地数据库断电、机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠TCP、存储数据丢失、其他异常等需要用到分布式事务。\nb) 例如：当本地事务数据库断电的这种秦光，如何保证数据一致性？数据库由连个文件组成的，一个数据库文件和一个**日志文件，**数据库任何写入操作都要先写日志，在操作前会吧日志文件写入磁盘，那么断电的时候及时才做没有完成，在重启数据库的时候，数据库会根据当前数据情况进行undo回滚活redo前滚，保证了数据的强一致性。\nc) 分布式理论：当单个数据库性能产生瓶颈的时候，可能会对数据库进行分区（物理分区），分区之后不同的数据库不同的服务器上\t，此时单个数据库的ACID不适应这种清苦啊，在此集群环境下很难达到集群的ACID，甚至效率性能大幅度下降，重要的是**再很难扩展新的分区了。**此时就需要引用一个新的理论来使用这种集群情况：CAP定理\nd) CAP定理:由加州肚饿伯克利分销Eric Brewer教授提出，指出WEB服务无法同时满足3个属性：\na. 一致性：客户端知道一系列的操作都会同时发生（生效）\nb. 可用性：每个操作都必须以可预期的响应结束\nc. 分区容错性：及时出现单组件无法可用，操作依然可以完成。\n具体的将在分布式系统中，在任何数据库设计中，一个WEB应\n至多只能同时支持上面两个属性。设计人员必须在一致性和可用\n性之间做出选择。\ne) BASE理论：分布式系统中追求的是可用性，比一致性更加重要，BASE理论来实现高可用性。核心思想是：我们无法做到羟乙酯，单每个应用都可以根据自身的业务特点，采用适当的方式使系统达到最终一致性。\nf) 数据库事务特性：ACID\ni. 原子性\nii. 一致性\niii. 独立性或隔离性\niv. 持久性\n(2) 分布式系统中，实现分布式事务的解决方案：\na. 两阶段提交2PC\nb. 补偿事务TCC\nc. 本地消息表（异步确保）\nd. MQ事务消息\ne. Sagas事务模型\n(3)\n14. sql语句优化会不会,说出你知道的?\n(1) 避免在列上做运算，可能会导致索引失败\n(2) 使用join时应该小结果集驱动大结果集，同时把复杂的join查询拆分成多个query，不然join越多表，会导致越多的锁定和堵塞。\n(3) 注意like模糊查询的使用，避免使用%%\n(4) 不要使用select * 节省内存\n(5) 使用批量插入语句，节省交互\n(6) Limit基数比较大时，使用between and\n(7) 不要使用rand函数随机获取记录\n(8) 避免使用null，建表时，尽量设置not nul，提高查询性能\n(9) 不要使用count（id），应该使用count（*）\n(10) 不要做无谓的排序，尽可能在索引中完成排序\n(11) From语句中一定不要使用子查询\n(12) 使用更多的where加以限制，缩小查找范围\n(13) 合理运用索引\n(14) 使用explain查看sql性能\n15. mysql的存储引擎了解过没有?\n(1) MySQL存储引擎种类：\n(2) https://blog.csdn.net/m0_37888031/article/details/80704344\n(3) https://blog.csdn.net/m0_37888031/article/details/80664138\n(4) 事务处理：在整个流程中出现任何问题，都能让数据回滚到最开始的状态，这种处理方式称之为事务处理。也就是说事务处理要么都成功，要么的失败。\n16. 红黑树原理？\n(1) 红黑树的性质：红黑树是一个二叉搜索树。在每个节点增加了一个存储位记录节点的颜色，可以是RED，也可以是BLACK，通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的两倍，加以平衡。性质如下：\ni. 每个节点颜色不是黑色就是红色\nii. 根节点的颜色是黑色的\niii. 如果一个节点是红色，那么他的两个子节点就是黑色的，没有持续的红节点\niv. 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点。\n","permalink":"https://coderrenxy.github.io/posts/read/12%E8%9A%82%E8%9A%81/","summary":"蚂蚁面试题总结 1. jdk1.7到jdk1.8 Map发生了什么变化(底层)? 1.8之后hashMap的数据结构发生了变化，从之前的单纯的数组+链","title":""},{"content":"软通动力Java中级 1、锁可以锁在哪里？ Java 为程序加锁的方式主要有两种：synchronized 与 Lock。\n1、synchronized 可以修饰的作用域如下：\n 非静态方法（加的锁为对象锁）； 静态方法（加的锁为类锁）； 代码块（对象锁与类锁均可）；  2、Lock 采用 lock()对代码加锁，unlock()进行解锁\n参考文章：https://blog.csdn.net/yx0628/article/details/79086511\n2、怎么利用反射获取类中的对象？\n 获取 Class 对象 通过 Class 对象获取构造方法 通过构造方法调用 newInstance()方法创建对象实例  参考文章 ：https://baijiahao.baidu.com/s?id=1619748187138646880\u0026amp;wfr=spider\u0026amp;for=pc\n3、HTTP 和 https 区别？ 1、 HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。\n2、使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。\n3、HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\n4、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80， 后者是 443。\n5、HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS比 HTTP 要更耗费服务器资源。\n参考文章：https://www.runoob.com/w3cnote/http-vs-https.html\n4、谈谈你对 TCP / IP 协议的了解 \\1. TCP/IP 是一个协议簇，是一个开放的协议标准，所有人都可以免费使用，并且是独立于硬件和操作系统的。\n2、TCP/IP 协议是不区分网络硬件的，它在局域网，广域网和互联网中都被广泛使用。\n3、TCP/IP 协议使用统一的网络地址分配的方案，网络中的每台电脑都具有唯一的 IP地址。\n\\4. TCP/IP 协议是一个标准的高层协议，拥有极高的可靠性，可以为用户提供可靠的服务。\n参考文章： https://blog.csdn.net/my_learning_road/article/details/79941273\n5、说说 Aop 和 IOC 的应用 IOC 的主要应用场景体现在 BeanFactory 接口，BeanFactory 下面有具体的实现类来实现 IOC 的功能。\nAOP 的主要应用场景：日志、权限、事物等。\n6、Spring 中 bean 是线程安全的吗？ Spring 容器中的 Bean 本身不具备线程安全的特性，但是具体还是要结合具体scope 的 Bean 去研究。\n1、Spring 容器中的 Bean 默认是单例的，所有线程都共享一个单实例的 Bean，因此是存在资源的竞争。\n如果单例 Bean,是一个无状态 Bean，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的。\n比如Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。对于有状态的 bean，是线程不安全的，但是我们可以通过ThreadLocal 去解决线程安全的方法。\n2、对于原型 Bean（即 scope=\u0026ldquo;prototype\u0026rdquo;）,每次创建一个新对象，也就是线程之间并不存在 Bean 共享，自然是不会有线程安全的问题。\n参考文章：https://blog.csdn.net/qq_29645505/article/details/88432001\n7、Maven 中 package 和 install 区别 package 是把 jar 打到本项目的 target 下，而 install 时把 target 下的 jar 安装到本地仓库，供其他项目使用。\n8、遇到过哪些设计模式？ 参考文章：https://www.cnblogs.com/Leo_wl/p/6067267.html\n9、谈谈简单工厂和抽象工厂的区别 简单工厂模式：是由一个工厂对象创建产品实例，简单工厂模式的工厂类一般是使用静态方法，通过不同的参数的创建不同的对象实例 可以生产结构中的任意产品，不能增加新的产品\n抽象工厂模式： 提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类，生产多个系列产品 生产不同产品族的全部产品，不能新增产品，可以新增产品族\n参考文章：https://www.cnblogs.com/gclokok/p/10029088.html\n10、说说你常用的 Linux 基本操作命令\nls - 用来显示目标列表\ncd - 用来切换工作目录\npwd - 以绝对路径的方式显示用户当前工作目录\ncat - 文件内容查看\ngrep - 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行\n打印出来tail - 输出文件中的尾部内容\nps - 用于报告当前系统的进程状态\nkill - 命令用来删除执行中的程序或工作\ntop - 可以实时动态地查看系统的整体运行情况\n11、谈谈 Currenthashmap 的扩容机制 JDK1.7**：**\n先对数组的长度增加一倍，然后遍历原来的旧的 table 数组，把每一个数组元素也就是 Node 链表迁移到新的数组里面，最后迁移完毕之后，把新数组的引用直接替换旧的。\nJDK1.8**：**\n扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用 tabAt 方法获得 i 位置的元素 f，初始化一个 forwardNode 实例 fwd，如果 f == null，则在 table 中的 i 位置放入 fwd，否则采用头插法的方式把当前旧table 数组的指定任务范围的数据给迁移到新的数组中，然后 给旧 table 原位置赋值fwd。\n直到遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新 sizeCtl 为新数组大小的 0.75 倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断 head 节点是否为 forwardNode 节点，如果是就帮助扩容。\n参考文章：https://blog.csdn.net/axibaaa/article/details/97109455\n","permalink":"https://coderrenxy.github.io/posts/read/13%E8%BD%AF%E9%80%9A%E5%8A%A8%E5%8A%9B/","summary":"软通动力Java中级 1、锁可以锁在哪里？ Java 为程序加锁的方式主要有两种：synchronized 与 Lock。 1、synchronized 可以修","title":""},{"content":"银盛支付Java中级 1. 说说springcloud的⼯作原理 springcloud由以下⼏个核⼼组件构成：\nEureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉\n取注册表，从⽽知道其他服务在哪⾥\nRibbon：服务间发起请求的时候，基于Ribbon做负载均衡，从⼀个服务的多台机器中选择⼀台\nFeign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求\nHystrix：发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，避免了服务雪崩\n的问题\nZuul：如果前端、移动端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务\n2. ⽤什么组件发请求 在Spring Cloud中使⽤Feign, 我们可以做到使⽤HTTP请求远程服务时能与调⽤本地⽅法⼀样的编码体验，开发者完全感知不到\n这是远程⽅法，更感知不到这是个HTTP请求。\n3. 注册中心心跳是几秒 1、Eureka的客户端默认每隔30s会向eureka服务端更新实例，注册中⼼也会定时进⾏检查，发现某个实例默认90s内没有再收到\n⼼跳，会注销此实例，这些时间间隔是可配置的。\n2、不过注册中⼼还有⼀个保护模式（服务端在短时间内丢失过多客户端的时候，就会进⼊保护模式），在这个保护模式下，他\n会认为是⽹络问题，不会注销任何过期的实例。\n4. 消费者是如何发现服务提供者的 a. 当⼀个服务实例启动，会将它的ip地址等信息注册到eureka；\nb. 当a服务调⽤b服务，a服务会通过Ribbon检查本地是否有b服务实例信息的缓存；\nc. Ribbon会定期从eureka刷新本地缓存。\n5. 多个消费者调用同⼀接⼝，eruka默认的分配方式是什么 a. RoundRobinRule:轮询策略，Ribbon以轮询的⽅式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问;\nb. RandomRule:随机选择，也就是说Ribbon会随机从服务器列表中选择⼀个进⾏访问;\nc. BestAvailableRule:最⼤可⽤策略，即先过滤出故障服务器后，选择⼀个当前并发请求数最⼩的;\nd. WeightedResponseTimeRule:带有加权的轮询策略，对各个服务器响应时间进⾏加权处理，然后在采⽤轮询的⽅式来获取相\n应的服务器;\ne. AvailabilityFilteringRule:可⽤过滤策略，先过滤出故障的或并发请求⼤于阈值⼀部分服务实例，然后再以线性轮询的⽅式从\n过滤后的实例清单中选出⼀个;\nf. ZoneAvoidanceRule:区域感知策略，先使⽤主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例\n清单，依次使⽤次过滤条件列表中的过滤条件对主过滤条件的结果进⾏过滤，判断最⼩过滤数（默认1）和最⼩过滤百分⽐（默\n认0），最后对满⾜条件的服务器则使⽤RoundRobinRule(轮询⽅式)选择⼀个服务器实例。\n6. 说说常⽤的springboot注解，及其实现？\na. @Bean：注册Bean\ni. 默认使⽤⽅法名作为id，可以在后⾯定义id如@Bean(\u0026ldquo;xx\u0026rdquo;)；\nii. 默认为单例。\niii. 可以指定init⽅法和destroy⽅法：\n  对象创建和赋值完成，调⽤初始化⽅法；\n  单实例bean在容器销毁的时候执⾏destroy⽅法；\n  多实例bean，容器关闭是不会调⽤destroy⽅法。\n  b. @Scope：Bean作⽤域\ni. 默认为singleton；\nii. 类型：\n singleton单实例（默认值）：ioc容器启动时会调⽤⽅法创建对象放到ioc容器中，以后每次获取就是直接从容器中拿  实例；\n prototype多实例：ioc容器启动不会创建对象，每次获取时才会调⽤⽅法创建实例；\n  request同⼀次请求创建⼀个实例；\n  session同⼀个session创建⼀个实例。\n  c. @Value：给变量赋值\ni. 代码：\n1 2 3 4 5 6 7 8 9 10 11  import org.springframework.beans.factory.annotation.Value; public class Person extends BaseEntity{ @Value(\u0026#34;xuan\u0026#34;) private String name; @Value(\u0026#34;27\u0026#34;) private int age; @Value(\u0026#34;#{20-7}\u0026#34;) private int count; @Value(\u0026#34;$person.nickName}\u0026#34;) private String nickName; }   i. ⽅式：\n  基本数字\n  可以写SpEL（Spring EL表达式）：#{}\n  可以写${}，取出配置⽂件中的值（在运⾏环境变量⾥⾯的值）\n  d. @Autowired：⾃动装配\ni. 默认优先按照类型去容器中找对应的组件：BookService bookService = applicationContext.getBean(BookService.class);\nii. 默认⼀定要找到，如果没有找到则报错。可以使⽤@Autowired(required = false)标记bean为⾮必须的。\niii. 如果找到多个相同类型的组件，再根据属性名称去容器中查找。\niv. @Qualifier(\u0026ldquo;bookDao2\u0026rdquo;)明确的指定要装配的bean。\nv. @Primary：让spring默认装配⾸选的bean，也可以使⽤@Qualifier()指定要装配的bean。\ne. @Profile：环境标识\ni. Spring为我们提供的可以根据当前环境，动态的激活和切换⼀系列组件的功能；\nii. @Profile指定组件在哪个环境才能被注册到容器中，默认为\u0026quot;default\u0026quot;@Profile(\u0026ldquo;default\u0026rdquo;)。\niii. 激活⽅式：\n  运⾏时添加虚拟机参数：-Dspring.profiles.active=test\n  代码⽅式：\n  7. spring的事务注解是什么？什么情况下事物才会回滚 a. spring事务实现机制：\nb. 事务注解@transactional；\nc. 默认情况下，如果在事务中抛出了未检查异常（继承⾃ RuntimeException 的异常）或者 Error，则 Spring 将回滚事务。\nd. @Transactional 只能应⽤到 public ⽅法才有效：只有@Transactional 注解应⽤到 public ⽅法，才能进⾏事务管理。这是因为\n在使⽤ Spring AOP 代理时，Spring 在调⽤在图 1 中的 TransactionInterceptor 在⽬标⽅法执⾏前后进⾏拦截之前，\nDynamicAdvisedInterceptor（CglibAopProxy 的内部类）的的 intercept ⽅法或 JdkDynamicAopProxy 的 invoke ⽅法会间接调\n⽤ AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）\n的 computeTransactionAttribute ⽅法。\n8. 说说spring事物的传播性和隔离级别 a. 七个事传播属性：\n  PROPAGATION_REQUIRED \u0026ndash; ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。\n  PROPAGATION_SUPPORTS \u0026ndash; ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。\n  PROPAGATION_MANDATORY \u0026ndash; ⽀持当前事务，如果当前没有事务，就抛出异常。\n  PROPAGATIONREQUIRESNEW \u0026ndash; 新建事务，如果当前存在事务，把当前事务挂起\n  PROPAGATIONNOTSUPPORTED \u0026ndash; 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。\n  PROPAGATION_NEVER \u0026ndash; 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。\n  PROPAGATIONNESTED \u0026ndash; 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与 PROPAGATIONREQUIRED类似的操作。\n  b. 五个隔离级别：\n  ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.\n  另外四个与JDBC的隔离级别相对应：\n  ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种\n  隔离级别会产⽣脏读，不可重复读和幻读。\n ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。\n  ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。\n  ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。\n  c. 关键词：\n1、脏读（新增或删除）：脏读就是指当⼀个事务正在访问数据，并且对数据进⾏了修改，⽽这种修改还没有提交到数据库 中，这时，另外⼀个事务也访问这个数据，然后使⽤了这个数据；\n Mary的原工资为1000，财务人员将Mary的工资改为了8000（但未提交事务） Mary读取自己的工资，发现自己的工资变为了8000，欢天喜地！ 而财务发现操作有误，回滚了事务，May的工资又变为了1000像这样，Mary记取的工资数8000是一个脏数据。  2、不可重复读（修改）：是指在⼀个事务内，多次读同⼀数据。在这个事务还没有结束时，另外⼀个事务也访问该同⼀数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改，那么第⼀个事务两次读到的的数据可能是不⼀样的。这样在⼀个事务内两次读到的数据是不⼀样的，因此称为是不可重复读。（解决：只有在修改事务完全提交之后才可以读取数据，则可以避免该问题）；\n 在事务1中，May读取了自己的工资为1000，操作并没有完成 在事务2中，这时财务人员修改了Mary的工资为2000，并提交了事务. 在事务1中，Mary再次读取自己的工资时，工资变为了2000  3、幻读（新增或删除）：是指当事务不是独⽴执⾏时发⽣的⼀种现象，例如第⼀个事务对⼀个表中的数据进⾏了修改，这种修改涉及到表中的全部数据⾏。同时，第⼆个事务也修改这个表中的数据，这种修改是向表中插⼊⼀⾏新数据。那么，以后就会发⽣操作第⼀个事务的⽤户发现表中还有没有修改的数据⾏，就好象发⽣了幻觉⼀样（解决：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题）。\n目前工资为1000的员工有10人。\n 事务1，读取所有工资为1000的员工。 这时事务2向employee表插入了一条员工记录，工资也为1000 事务1再次读取所有工资为1000的员工共读取到了11条记录。  9. mysql的引擎有什么？他们的区别 a. InnoDB：\n  ⽀持事务处理\n  ⽀持外键\n  ⽀持⾏锁\n  不⽀持FULLTEXT类型的索引（在Mysql5.6已引⼊）\n  不保存表的具体⾏数，扫描表来计算有多少行\n  对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引\n  DELETE 表时，是一行一行的删除\n  InnoDB 把数据和索引存放在表空间⾥⾯\n  跨平台可直接拷⻉使⽤\n  表格很难被压缩\n  b. MyISAM：\n  不⽀持事务，回滚将造成不完全回滚，不具有原⼦性\n  不⽀持外键\n  ⽀持全⽂搜索\n  保存表的具体⾏数,不带where时，直接返回保存的⾏数\n  DELETE 表时，先drop表，然后重建表\n  MyISAM 表被存放在三个⽂件 。frm ⽂件存放表格定义。 数据⽂件是MYD (MYData) 。 索引⽂件是MYI (MYIndex)引伸\n  跨平台很难直接拷⻉\n  AUTO_INCREMENT类型字段可以和其他字段⼀起建⽴联合索引\n  表格可以被压缩\n  c. 选择：因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原⼦性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接⽤备份覆盖恢复。如果系统读少，写多的时候，尤其是并发写⼊⾼的时候。InnoDB就是⾸选了。两种类型都有⾃⼰优缺点，选择那个完全要看⾃⼰的实际类弄。\n10. innodb如何实现mysql的事务 事务进行过程中，每次sql语句执⾏，都会记录undo log和redo log，然后更新数据形成脏⻚，然后redo log按照时间或者空间等条件进⾏落盘，undo log和脏⻚按照checkpoint进⾏落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发⽣崩溃，则⾸先检查checkpoint记录，使⽤相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤undo log进⾏事务回滚。事务执⾏COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚继续按照checkpoint进⾏落盘。如果此时发生了崩溃，则只使⽤redo log恢复数据。\n11.mysql索引谈⼀谈 12.说说b+树的原理 a. B-tree：\nB-tree 利⽤了磁盘块的特性进⾏构建的树。每个磁盘块⼀个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级⽐原来的⼆叉树少了，减少数据查找的次数和复杂度。\nB-tree巧妙利⽤了磁盘预读原理，将⼀个节点的⼤⼩设为等于⼀个⻚（每⻚为4K），这样每个节点只需要⼀次I/O就可以完全载入。\nB-tree 的数据可以存在任何节点中。\n B+tree：  B+tree 是 B-tree 的变种，B+tree 数据只存储在叶⼦节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少\n所以查询数据更快，所有指关键字指针都存在叶⼦节点，所以每次查找的次数都相同所以查询速度更稳定;\n13. 让你设计⼀个索引，你会怎么设计 a. mysql默认存储引擎innodb只显式⽀持B树索引，对于频繁访问的表，innodb会透明建⽴⾃适应hash索引，即在B树索引基础上建⽴hash索引，可以显著提⾼查找效率，对于客户端是透明的，不可控制的，隐式的。\n14. 还问了git和svn的区别 1、Git是分布式的，⽽Svn不是；\n2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件\n3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；\n4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。\n5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹络问题\n时降低对版本库的破坏。)\n15. git命令的⼀些底层原理以及流程 https://www.jianshu.com/p/2b47a3078a46\na. git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库是这样的：\n1 2 3 4 5 6 7 8 9 10 11  - HEAD - branches - config - description - hook - objects - - info - - pack - refs - - heads - - tags    description⽤于GitWeb程序 config配置特定于该仓库的设置（还记得git config的三个配置级别么） hooks放置客户端或服务端的hook脚本 HEAD传说中的HEAD指针，指明当前处于哪个分⽀ objectsGit对象存储⽬录 refsGit引⽤存储⽬录 branches放置分⽀引⽤的⽬录 其中description、config和hooks这些不在讨论中，后⽂会直接忽略。  b. git add：Git commit之前先要通过git add添加⽂件：\n可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个\n4d96d5b00d98959ea9960f069585ce42b1349a⽂件。\n其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。\nc. git commit：\n","permalink":"https://coderrenxy.github.io/posts/read/14%E9%93%B6%E7%9B%9B%E6%94%AF%E4%BB%98/","summary":"银盛支付Java中级 1. 说说springcloud的⼯作原理 springcloud由以下⼏个核⼼组件构成： Eureka：各个服务启动时，Eur","title":""},{"content":"中软国际Java中级 1、java 中==和 equals 和 hashCode 的区别 1）==若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。对象是存放在堆中，栈中存放的对象的引用，所以==是对栈中的值进行比较，若返回 true 代表变量的内存地址相等；\n2）equals 是 Object 类中的方法，Object 类的 equals 方法用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。若是类中覆盖了 equals 方法，就要根据具体代码来确定，一般覆盖后都是通过对象的内容是否相等来判断对象是否相等。\n3）hashCode()计算出对象实例的哈希码，在对象进行散列时作为 key 存入。之所以有hashCode 方法，因为在批量的对象比较中，hashCode 比较要比 equals 快。在添加新元素时，先调用这个元素的 hashCode 方法，一下子能定位到它应该旋转的物理位置，若该位置没有元素，可直接存储；若该位置有元素，就调用它的 equals 方法与新元素进行比较，若相同则不存，不相同，就放到该位置的链表末端。\n4）equals 与 hashCode 方法关系：\nhashCode()是一个本地方法，实现是根据本地机器上关的。equals()相等的对象， hashCode()也一定相等；\nhashCode()不等，equals()一定也不等；\nhashCode()相等，equals() 可能相等，也可能不等。\n所 以 在 重 写 equals(Object obj) 方 法 ， 有 必 要 重 写 hashCode() 方 法 ， 确 保 通 过equals(Object obj)方法判断结果为 true 的两个对象具备相等的 hashCode()返回值。\n5）equals 与==的关系：\nInteger b1 = 127;在 java 编译时被编译成 Integer b1 = Integer.valueOf(127);对于-128到 127 之间的 Integer 值，用的是原生数据类型 int，会在内存里供重用，也就是这之间的Integer 值进行==比较时，只是进行 int 原生数据类型的数值进行比较。而超出-128〜127的范围，进行==比较时是进行地址及数值比较。\n2、int、char、long 各占多少字节数 int\\float 占用 4 个字节，short\\char 占用 2 个字节，\nlong 占用 8 个字节，byte/boolean 占用 1 个字节\n基本数据类型存放在栈里，包装类栈里存放的是对象的引用，即值的地址，而值存放在堆里。\n3、int 与 integer 的区别 Integer 是 int 的包装类，int 则是 java 的一种基本数据类型，Integer 变量必须实例化才能 使用，当 new 一个 Integer 时，实际是生成一个指向此对象的引用，而 int 是直接存储数据的值，\nInteger 默认值是 null，而 int 默认值是 0\n4、谈谈对 java 多态的理解 同一个消息可以根据发送对象的不同而采用多种不同的行为方式，在执行期间判断所引用的对象的实际类型，根据其实际的类型调用其相应的方法。\n作用：消除类型之间的耦合关系。实现多态的必要条件：继承、重写（因为必须调用父类中存在的方法）、父类引用指向子类对象\n5、String、StringBuffer、StringBuilder 区别 都是字符串类，String 类中使用字符数组保存字符串，因有 final 修饰符，String 对象是不可变的，每次对 String 操作都会生成新的 String 对象，这样效率低，且浪费内存空间。但线程安全。\nStringBuilder 和 StringBuffer 也是使用字符数组保存字符，但这两种对象都是可变的，即对字符串进行 append 操作，不会产生新的对象。它们的区别是：StringBuffer 对方法加了同步锁，是线程安全的，StringBuilder 非线程安全。\n6、什么是内部类？内部类的作用 内部类指在类的内部再定义另一个类。\n内部类的作用：\n1）实现多重继承，因为 java 中类的继承只能单继承，使用内部类可达到多重继承；\n2）内部类可以很好的实现隐藏，一般非内部类，不允许有 private 或 protected权限的，但内部类可以；\n3）减少了类文件编译后产生的字节码文件大小；内部类在编译完后也会产生.class 文件，但文件名称是：外部名称$内部类名称.class。\n分为以下几种：\n1）成员内部类，作为外部类的一个成员存在，与外部类的属性、方法并列，成员内部类持有外部类的引用，成员内部类不能定义 static 变量和方法。应用场合：每一个外部类都需要一个内部类实例，内部类离不开外部类存在。\n2）静态内部类，内部类以 static 声明，其他类可通过外部类.内部类来访问。特点：不会持有外部类的引用，可以访问外部类的静态变量，若要访问成员变量须通过外部类的实例访问。\n应用场合：内部类不需要外部类的实例，仅为外部类提供或逻辑上属于外部类，逻辑上可单独存在。设计的意义：加强了类的封装性（静态内部类是外部类的子行为或子属性，两者保持着一定关系），提高了代码的可读性（相关联的代码放在一起）。\n3）匿名内部类，在整个操作中只使用一次，没有名字，使用 new 创建，没有具体位置。\n4）局部内部类，在方法内或是代码块中定义类，\n7、抽象类和接口区别 抽象类在类前面须用 abstract 关键字修饰，一般至少包含一个抽象方法，抽象方法指只有声明，用关键字 abstract 修饰，没有具体的实现的方法。因抽象类中含有无具体实现的方法，固不能用抽象类创建对象。\n当然如果只是用 abstract 修饰类而无具体实现，也是抽象类。抽象类也可以有成员变量和普通的成员方法。抽象方法必须为 public 或 protected（若为 private，不能被子类继承，子类无法实现该方法）。\n若一个类继承一个抽象类，则必须实现父类中所有的抽象方法，若子类没有实现父类的抽象方法，则也应该定义为抽象类。\n接口用关键字 interface 修饰，接口也可以含有变量和方法，接口中的变量会被隐式指定为public static final 变量。方法会被隐式的指定为 public abstract，接口中的所有方法均不能有具体的实现，即接口中的方法都必须为抽象方法。若一个非抽象类实现某个接口，必须实现该接口中所有的方法。\n区别：\n1）抽象类可以提供成员方法实现的细节，而接口只能存在抽象方法；\n2）抽象类的成员变量可以是各种类型，而接口中成员变量只能是 public static final 类型；\n3）接口中不能含有静态方法及静态代码块，而抽象类可以有静态方法和静态代码块；\n4）一个类只能继承一个抽象类，用 extends 来继承，却可以实现多个接口，用 implements\n来实现接口。\n7.1、抽象类的意义 抽象类是用来提供子类的通用性，用来创建继承层级里子类的模板，减少代码编写，有利于\n代码规范化。\n7.2、抽象类与接口的应用场景 抽象类的应用场景：1）规范了一组公共的方法，与状态无关，可以共享的，无需子类分别\n实现；而另一些方法却需要各个子类根据自己特定状态来实现特定功能；\n2）定义一组接口，但不强迫每个实现类都必须实现所有的方法，可用抽象类定义一组方法\n体可以是空方法体，由子类选择自己感兴趣的方法来覆盖；\n7.3、抽象类是否可以没有方法和属性？ 可以\n7.4、接口的意义 1）有利于代码的规范，对于大型项目，对一些接口进行定义，可以给开发人员一个清晰的\n指示，防止开发人员随意命名和代码混乱，影响开发效率。\n2）有利于代码维护和扩展，当前类不能满足要求时，不需要重新设计类，只需要重新写了\n个类实现对应的方法。\n3）解耦作用，全局变量的定义，当发生需求变化时，只需改变接口中的值即可。\n4）直接看接口，就可以清楚知道具体实现类间的关系，代码交给别人看，别人也能立马明\n白。\n8、泛型中 extends 和 super 的区别 限定参数类型的上界，参数类型必须是 T 或 T 的子类型，但对于 List，不能通过 add()来加入元素，因为不知道是 T 的哪一种子类； 限定参数类型的下界，参数类型必须是 T 或 T 的父类型，不能能过 get()获取元素，因为不知道哪个超类； ## 9、父类的静态方法能否被子类重写？静态属性和静态方法是否可以被继承？ 父类的静态方法和属性不能被子类重写，但子类可以继承父类静态方法和属性，如父类和子类都有同名同参同返回值的静态方法 show()，声明的实例 Father father = new Son(); (Son extends Father)，会调用 father 对象的静态方法。静态是指在编译时就会分配内存且一直存在，跟对象实例无关。 ## 10、进程和线程的区别 进程：具有一定独立功能的程序，是系统进行资源分配和调度运行的基本单位。 线程：进程的一个实体，是 CPU 调度的苯单位，也是进程中执行运算的最小单位，即执行处理机调度的基本单位，如果把进程理解为逻辑上操作系统所完成的任务，线程则表示完成该任务的许多可能的子任务之一。 关系：一个进程可有多个线程，至少一个；一个线程只能属于一个进程。同一进程的所有线程共享该进程的所有资源。不同进程的线程间要利用消息通信方式实现同步。 区别：进程有独立的地址空间，而多个线程共享内存；进程具有一个独立功能的程序，线程不能独立运行，必须依存于应用程序中； ## 11、final，finally，finalize 的区别 final：变量、类、方法的修饰符，被 final 修饰的类不能被继承，变量或方法被 final 修饰则不能被修改和重写。 finally：异常处理时提供 finally 块来执行清除操作，不管有没有异常抛出，此处代码都会被执行。如果 try 语句块中包含 return 语句，finally 语句块是在 return 之后运行； finalize：Object 类中定义的方法，若子类覆盖了 finalize()方法，在在垃圾收集器将对象从内存中清除前，会执行该方法，确定对象是否会被回收。 ## 12、序列化 Serializable 和 Parcelable 的区别 **序列化**：将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输； **为什么要进行序列化**：开发过程中，我们需要将对象的引用传给其他 activity 或 fragment使用时，需要将这些对象放到一个 Intent 或 Bundle 中，再进行传递，而 Intent 或 Bundle只能识别基本数据类型和被序列化的类型。**Serializable**：表示将一个对象转换成可存储或可传输的状态。 **Parcelable**：与 Serializable 实现的效果相同，也是将一个对象转换成可传输的状态，但它的实现原理是将一个完整的对象进行分解，分解后的每一部分都是 Intent 所支持的数据类型，这样实现传递对象的功能。 **Parcelable 实现序列化的重要方法**：序列化功能是由 writeToParcel 完成，通过 Parcel 中的 write 方法来完成；反序列化由 CREATOR 完成，内部标明了如何创建序列化对象及数级， 通过 Parcel 的 read 方法完成；内容描述功能由 describeContents 方法完成，一般直接返回 0。 **区别**：Serializable 在序列化时会产生大量临时变量，引起频繁 GC。Serializable 本质上使用了反射，序列化过程慢。Parcelable 不能将数据存储在磁盘上，在外界变化时，它不能很好的保证数据的持续性。 **选择原则**：若仅在内存中使用，如 activity\\service 间传递对象，优先使用 Parcelable，它性能高。若是持久化操作，优先使用 Serializable **注意**：静态成员变量属于类，不属于对象，固不会参与序列化的过程；用 transient 关键字编辑的成员变量不会参与序列化过程；可以通过重写 writeObject()和 readObject()方法来重写系统默认的序列化和反序列化。\r## 13、谈谈对 kotlin 的理解 特点：\r1）代码量少且代码末尾没有分号；\r2）空类型安全（编译期处理了各种 null 情况，避免执行时异常）；\r3）函数式的，可使用 lambda 表达式；\r4）可扩展方法（可扩展任意类的的属性）；\r5）互操作性强，可以在一个项目中使用 kotlin 和 java 两种语言混合开发； ## 14、string 转换成 integer 的方式及原理 1）parseInt(String s)内部调用 parseInt(s, 10)默认为 10 进制 。 2）正常判断 null\\进制范围，length 等。 3）判断第一个字符是否是符号位。 4）循环遍历确定每个字符的十进制值。 5）通过*=和-=进行计算拼接。 6）判断是否为负值返回结果。","permalink":"https://coderrenxy.github.io/posts/read/15%E4%B8%AD%E8%BD%AF%E5%9B%BD%E9%99%85/","summary":"中软国际Java中级 1、java 中==和 equals 和 hashCode 的区别 1）==若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。","title":""},{"content":"北京(上) 大家好，我是大白，以程序员的视角看北京系列终于和大家见面了。因为北京适合程序员工作的企业实在太多了，所以怎样给大家介绍北京适合程序员的工作机会一直让我十分头疼。如果写的太简单，我跟大家说北京有百度、腾讯、阿里、美团等等，大家一定觉得我是在废话，但把所有企业一次性全介绍了工作量太大，并且文章也看不出重点了。所以我最终决定，北京拆成三篇来讲，一篇介绍北京的国企央企研究所、一篇介绍北京的大型互联网公司和大型外企、一篇介绍北京的中小型互联网公司。\n我发现在互联网公司工作的程序员都对国企央企以及研究所十分好奇，但是因为这些单位的信息比较封闭，所以大家对于这些企业的工作方式以及薪酬情况都都不清楚。为了能给北京系列开个好头，第一篇文章我就以我熟悉的北京的国企央企研究所来给大家介绍了。想提前声明一点，虽然我有很多同学和朋友在北京国企央企以及研究所，但是同一个公司，不同的部门或者不同的组差别都太大了。尤其是研究所，每个系列都有数量庞大的下属研究所，并且下属的研究所独立性都特别高，所以风格差别很大。我只能把我见到的情况给大家做一个介绍，具体去到哪个研究所哪个团队还得你们自己去详细打听。只能说我的介绍相对于更接近一些真实。如果大家发现哪里有误，欢迎大家指出。\n下面还是分开来介绍：\n国企\u0026amp;央企 在这篇文章中说的都是国企和央企的直属软件开发中心，子公司是不包含在里面的。子公司的工作风格差别很大。总体来说，国企和央企在软件技术上都是差互联网公司一大截的，待遇好不好真的看具体公司。是有些好的国企，我一个朋友在某国企虽然工资不太高，但是上了两年没加过班。也有一些国企，加班比拼多多都重，但是工资低且福利差。\n银行软件开发中心 最近几年计算机相关专业应届毕业生对于银行的软件开发中心热情越来越高，主要是由于银行的软件开发中心比较稳定，薪酬也还可以。目前应届生选择比较多的是工行、农行、中国银行、邮储银行的软件开发中心。大家比较感兴趣就分开详细介绍下吧。银行软件开发中心在校招时和互联网公司不太一样，hr 只会和你说一个大概的工资，hr 说的工资只能参考，工资还是以实际发放为准。如果想知道具体工资你得私下去问和你关系好的学长学姐，或者只能等工资发下来了才能知道。另外银行软件开发中心的稳定也只是说轻易不会开除你，但是忙不忙就要看你运气了。银行软件开发中心有的组忙起来完全不虚 PDD。\n工商银行软件开发中心 和同行相比，工商银行的软件开发中心算技术最好的了。工行喜欢招应届生，社招进来的比较少。刚进来的应届生职级是助理经理，税前年薪差不多是20万左右（到手15-16万吧，加上年终奖和节假日补贴）。工资发放方式稍微有点奇怪，就是每月发八九千，然后留一部分年底一并发放。每月会有饭补，过节也会有节假日补贴（放三天的节日假期给 1000，国庆给 2000，过年 4000）。这个职级的工资对于在北京工作来说还是有点难顶的，毕竟光跟人合租每月就要画掉两千多了。如果你是本科毕业进入工行，从助理经理升到经理一需要两年时间，硕士只需要一年，这个职级基本上全都能按时达到，不过工资变化不太大。从经理一升到经理二大约要一到两年的时间，这就看你能力了，经理二以后工资就相对多一些了，经理二绩效不太好的话每年到手能拿 22 万左右，如果绩效好，可能能拿到 29 万左右。经理二升经理三就完全看你自己能力了，到经理三以后每年到手都能 35 万左右，收入就很可观了。另外在工行发专利什么的也有些奖金，一个专利貌似是奖励 5000.\n工行的总行是在珠海。工行在西安、杭州等地也设立了研发中心，都是属于总行。目前北京这边也一直在动员员工去西安，薪资和北京差不太多。听说西安那边的工行加班比较严重。北京这边总体还好，卷不卷看你组长了，不过你也可以不甩你领导，他们是很难开掉你的，他们能的只是绩效给你打低点，你工资少点。\n农业银行软件开发中心 感觉农业银行的软件开发中心技术比工行差一点，不过工资比工行多一些，刚毕业的应届生税前能到税前25万-32万（这是hr说的啊，我了解到的西安每月税后到手是 1万2，加上年终奖税前能算 20 万的年包，北京比西安稍微多一点点，但是多不了太多）。农行软件开发中心有个大问题就是工资分配很平均，但是工作量分布不均，有的组十分养生，有的组忙的受不了（越接近客户用的产品线越累）。我的一个学长天天早早就下班了，另外一个同学周末跟我吃个饭都急匆匆的，为了投产要加班到凌晨。目前农行内部的怨气比较大，这点大家在脉脉上也能看出来。农行想要升职还要去考软考。\n中国银行软件开发中心 中国银行软件开发中心算是给钱最少的了，年包15万左右。这钱在北京确实太少了。不过工作是目前几个银行软开里最轻松的，家里不怎么缺钱，只想找个轻松稳定的可以选。\n邮政储蓄银行软件研发中心 第一年包含试用期，年薪税前总包 26w, 第二年年薪税前总包 31w。加不加班看你运气了，运气好被分到好的组不怎么加班，运气不好就很惨了。在北京工作的话不会被外调，但是在西安等地工作的许多人会被外调。\n券商 曾经农行软开的一位领导来我们学校校招宣讲时就说因为银行的工资有限制，涨薪比较慢。所以很多银行软开的职工干几年后就会跑到券商去挣钱。那时我才知道券商居然还招不少程序员。后来我发现中信建投证券是真不错，北京这边校招生进来月薪 18k ，年终奖 6 个月，虽然薪资还是不及互联网公司，但是涨薪速度相比于其它国企央企还是快很多的。另外只有股票开市的日子用上班，加班很少。不过对于学历的要求比较高，必须是985硕士，并且还卡本科。\n对于其它券商的情况我知道的就不多了，这里给大家提供一个找工作的思路，大家可以多去了解下。\n运营商 这里说的运营商说的是移动联通还有电信的研究院。移动的工资发放风格和工行有异曲同工之妙，每个月发的工资很少，到年终会一起再发一些。应届生年薪大概 20w 左右，平时工资发一半，年终把剩下的一半发给你。联通在北京的研究院有两个，一个叫联通研究院，一个叫联通软件研究院。我听说的是联通研究院比较好，联通软件研究院比较坑。 电信研究院的据说很轻松，但是工资低，没朋友在这里，我不太确定，只是听说。\n研究所 北京有着数量庞大的研究所，比如航天科技系列、航空工业系列、中船舶系列、中科院系列、中电科系列、军事科学院下属系列、工信部下属研究院、中国兵器等等。不得不说计算机相关专业真的是万金油，因为上述研究所，不管他们主营业务是啥，他们全都招计算机相关专业的毕业生，并且招的还不少。\n近几年想成为这些研究所的正式职工都需要是硕士以上了，签的本科生基本都是劳务派遣。户口的事放在生活里统一说。\n可能家里的长辈听到你去了研究所会觉得很有面子。但是单论软件技术来说，目前研究所是落后于互联网公司的，并且差距还不算小。研究所和互联网公司的办事风格不太一样，互联网公司会把岗位划分的很细致甚至有的互联网公司会无限的细分一个岗位（这点是我觉得不太好的地方，因为划分的太细了，以后跳槽会存在问题），但是研究所的岗位又划分的太粗糙了（从订需求、写开发文档、代码开发、测试、到和客户扯皮这些流程全的你来搞）。另外因为研究所的大部分领导软件方面技术没有互联网那么专，所以对工作量的评估不是太准，有时候安排起活来就比较离谱。是否来研究所要想想明白以下几个问题：（1）你家庭的经济情况，至少北京买房首付家里能掏出来。（2）你的兴趣（如果只想安安静静的写代码，研究所不太合适）。（3）面试通过后你要充分的了解你所在的团队情况，同一个研究所，不同的团队的差别那可大了去了。\n总体来说，个人感觉如果你在一个二线城市的研究所工作会比在一线城市研究所工作舒服。在一线城市去互联网公司干几年攒点钱撤一个二线城市压力没那么大。在北京的研究所工作北京户口是拿了，但是干几年根本攒不下多少钱，一线城市研究所分房这事就不用做梦了，充其量会给你提供一个宿舍，这种宿舍也就是毕业三到五年内可以住，以后就不能住了。相比于二线城市的研究所，一线城市研究所的工资每月多个两三千，但是房价是二线城市的三到五倍，生活幸福感会大打折扣。\n航天科技\u0026amp;航空工业 我有很多的校友都在航空航天系列的研究所。研究所的具体薪资都比较保密，大部分研究所在给你 offer 的时候不会像互联网公司那样把薪资给你说的清清楚楚并且写在合同上，而是大概和你说个数。而且你入职后两到三个月的薪资往往都很少，等三四个月以后薪资稳定了你才能确定你开多少钱。\n航空航天目前效益比较好，算是研究所中薪资比较高的。另外食堂和宿舍都有，如果没宿舍还会有租房补贴。但是挣钱和互联网公司肯定没法比。薪资的话刚毕业的学生每月到手大概是一万出头，工资加上各种补贴年薪差不多税前能到20多万。加班没有加班费，出差会有出差补贴，有的团队出差一天补300，有的团队出差一天补400。所以如果你一个月都驻在外面的话，一个月工资到手也两万多呢。但是一年有个一两月出差还行，有的项目组一年有三分之二时间在外面出差，你会怀疑人生的。其实刚毕业头两年航空航天的薪资和互联网公司差距不大，不过在两三年后薪资水平就会逐渐拉开，研究所薪资涨的都慢。\n另外航空航天的研究所是很忙的，所以别想着进来轻松。研究所的忙法和互联网公司不是一种忙法，有的人在工作强度大的互联网公司待过的可能觉得自己 996 和 007 都能抗，来个研究所还怕啥？我是想说你可能想的有点简单了，在研究所写代码只是工作的一小部分，让你烦心的事多着呢。只是说你如果不把领导打了的话，他不太容易把你开掉。另外研究所有个好处是比较支持在职读博，如果你的组不是太忙，提升下学历是个不错的选择。\n工信部下属研究院 工信部下属的研究院整体上都不错，就比如信通院（中国信息通信研究院），如果你对这个单位陌生的话你可以看看你的行程码下面服务提供商排在第一个的是谁。信通院是制定标准的单位，也是监理单位。在信通院的话代码就很少写了，更多就是写文档了，不过信通院这种地方的视野肯定高一些。薪资的话信通院每个职工薪资差别很大，刚进去工资很低，可能就四五千块钱，但是薪资每个月都会变化，然后稳定在一个数。薪资低的每月到手有一万出头，但我知道每月到手两三万甚至更多的也是有的（不是领导啊，只是职工）。\n中科院系列 中科院系列下计算机相关最强的三个所就是自动化所（搞 nlp 的应该都听过宗成庆老师）、软件所、计算所。另外还有信工所、电子所也还凑合。整体待遇上，中科院系列的待遇不如航空航天系列的。你可以把中科院系列的研究所完全的想象成一个大学（嗯，不用想象，确实是个大学，中国科学院大学嘛）。每个团队就是你们研究生的实验室。基本上就是一个大老板，带几个小老板，再带几个职工，另外再配几个中科院的学生。课题组想要挣钱也是需要大老板出去拉活，然后小老板带着学生去干活。工作方式和技术水平和你们研究生的实验室一模一样的，就是多了一些硕士博士职工罢了。\n中科院系列各个所和各个课题组的待遇以及工作方式差距特别大，工资有少量的比较高的（我说的比较高是能和互联网公司持平），大部分刚进来的硕士应届生工资差不多就是八九千，博士一万多点。有的所提供宿舍，有的所连宿舍都没。总体上来说想在中科院有好的发展，需要你是博士，然后多发论文。等你成为小老板后，且团队可以项目成果转化，或者孵化企业后你的待遇会有比较大的变化。\n中电科系列 中电科系列的待遇比航空航天系列稍差，比中科院系列稍强一些。我感觉中电科系列的加班强度比较高，认识的几个在中电科系列的经常 996 甚至 007，还经常出差。待遇的话基本工资也是每月1万出头，然后出差也是有出差补贴，每天300 或者400，具体要看团队。感觉工资主要是靠出差补贴堆起来的。大部分下属院所会提供职工宿舍，中电科系列下属研究所风格差别很大，好起来是真好，坑起来是真坑啊。\n中国兵器系列 中国兵器系列计算机相关专业招的不是太多，其实每年一共招的人也不多。我最初对中国兵器系列的研究所有了解是一个所来我们学校宣讲。感觉中国兵器在西安的几个所能算的上是西安研究所的天花板了吧，待遇还不错（和航天504所比我有点不太确定）但是在北京我就不太清楚了。\n军事科学院系列 军事科学院系列的研究所招的职位都是军队文职，也就是说都需要考试的。我上时，听过几家军事科学院下属单位来宣讲，只是有个粗略的了解。军队文职也是上班制的，上班时也是需要穿军装的，下班后的生活不干预。工资有个很详细的职称对应表，硕士进去我记得是一万出头。想有好的发展最好去抓总单位，因为上面提的很多研究所想要项目都得抓总单位批。不过抓总单位的科研岗都要博士了，硕士进去只能是支撑岗位。\n北京来我们学校宣讲的几家军科院下属研究所都是承诺户口以及包解决子女上学问题的。当时说的是博士进去副营级，会提供一个四十平左右的房子住。硕士就是普通两人一间的宿舍。\n生活方面 北京具体的房价、美食教育等情况我放到下一篇讲北京互联网公司的文章中好好去讲下。这篇文章只讲一个事，那就是北京户口。北京户口的主要用处就是子女教育问题，其它的一些好处就是有北京户口可以申请共有产权房还有摇车牌等。应届毕业生是最好搞定户口的时候了，如果你能进这篇文章中讲的这些单位，大概率你是有户口的。不过拿户口的同时都要签一个五年的服务期合同，违约金每个单位不一样， 20万-50万不等，逐年递减。对于应届生来说户口貌似吸引力没有特别的大，毕竟现在自己还顾不过来，也不知道自己子女在哪呢。但是对于已经有子女的人来说，我一提给北京户口的事他们眼睛就亮了。\n北京这些年对于户口有也逐渐放宽，一些互联网公司的特殊应届招聘计划也会给户口，另外今年双一流学科的硕士以上应届毕业生都给户口了。\n另外想要户口还可以走积分落户，不过想要靠积分落户解决北京户口，就需要你头上有犄角，身后有尾巴了。\n好啦，这篇文章就介绍这么多，期待下一篇北京有哪些大型互联网公司和外企吧！\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n ","permalink":"https://coderrenxy.github.io/posts/read/beijing-01/","summary":"北京(上) 大家好，我是大白，以程序员的视角看北京系列终于和大家见面了。因为北京适合程序员工作的企业实在太多了，所以怎样给大家介绍北京适合程序","title":""},{"content":"北京(下) 大家好呀，我是大白。第一篇“程序员在北京可以选择哪些国企、央企以及研究所”发出后被一些读者和号主夸奖了，十分开心。没看过的朋友也可以通过链接进去看看呀。今天我们就继续来看看北京有哪些大型的互联网公司。写完这篇再写下北京比较不错的中小型互联网公司，就可以收官了。\n北京的繁华程度自然不用我多说。特别是对于程序员来说，北京有数量庞大的互联网公司。所以许多计算机相关专业的学生刚毕业时都会想着来北京闯一闯，一方面多学点东西，另一方面多挣点钱。今天这篇文章我们会介绍一下互联网大厂和大型外企在北京这边的部门以及特点。再讲下大厂程序员在北京的生活。\n这里再说一句，虽然北京依然在资源和机会上是领先其它准一线和二线城市一大截的。但是由于现在杭州、苏州、成都、西安等等城市发展的都不错，像长沙、大连、天津、青岛等地也比较安逸。再加上由于现在网络越来越发达，不像前些年一样许多事情只能在北京、上海、广州这些地方才能体验到。所以大家根据自身情况选择合适自己的城市就好了，硬往北京卷也没必要。\n工作机会 互联网大厂 谈到互联网公司，免不了说薪资。很多应届生校招时由于没有工作经验，容易被哄。首先要知道，校招给你开出的薪资是可以 argue 的，也就是说可以和 hr 商量。然后我主要想说的是，要谈你去和 HR 谈 base（每月基础工资）, 可不敢去和 hr argue 每年多少薪哈。一个哥们给我讲了个真事，他们公司一个应届生嫌 25k x 15 少，HR 跟他说那给你 25k X 16 吧，然后那个应届生就开心的答应了。HR 给你承诺的每月 base 是没问题的，但是说每年发多少个月的月薪只是一个期望，最终给你发几个月的年终奖要根据你到年底的评分以及你所在团队年底的评分共同决定。\n下面我说的各个公司薪资时说的每年多少薪也是 HR 说的一个期望薪资呀！许多说发 4 个月年终奖的，实际上一半人拿不到。\n百度 坐标：西北旺\n2022校招薪资：开发岗白菜价 22k，sp 24k，ssp 26k 。算法岗白菜价 26k，sp 29k，ssp 32k。每年 16 薪。\n个人评价：曾经十分强大的百度这几年逐渐和腾讯阿里拉开了差距。不过就我个人而言还是比较喜欢百度的。首先百度是以技术为导向的，这一点作为程序员应该会有比较好的体验，另外百度总体来说加班不是特别严重。工作制差不多 975 或者是 985, 前两周我趁着去找在百度的同学玩的机会，周六下午三点左右在百度大楼里转了一圈，最起码周末是没几个工位上有人的。工位上有人的看样子也是趁周末想自己单独学习会。另外百度的办公环境还不错，食堂也很好。百度在北京的部门以及岗位都特别齐全，只是大量的开发岗位用 php 有点难顶。\n百度这两年集中发展人工智能，这一点在给校招开出的薪资上也能看得出来。不得不说这两年校招的薪资是真高呀，就不用说算法岗校招的薪资，开发岗校招的薪资都倒挂了不少老员工。百度在算法上投入的决心是挺大的，自己能搞出深度学习框架 PaddlePaddle 十分让我敬佩。读研时实验室显卡不够我还经常上百度的 AI Studio 平台上薅羊毛，有次顺手打了个比赛得了个名次，排名不高，但百度还真给我寄来几百块钱的购物券。只是最近百度无人车进展的不太顺利，感觉是百度人工只能发展的一大挫折了。\n腾讯 坐标：西北旺\n2022校招薪资：19-25k，每年 16 薪；每月 4k 租房补贴；6-10 w的签字费分两年发放。\n个人评价：北京这边腾讯和百度的办公楼离得很近，腾讯在北京这边的部门主要是 PCG 事业群（PCG 中都是腾讯和媒体宣传相关的部门，包含腾讯视频、腾讯新闻、腾讯QQ等，另外央视频也是包给北京这边的腾讯做的。话说PCG 在脉脉上被喷的很惨）。腾讯主要用的语言是 C++ 和 Go，我见过一个部门招 Java 的，不过一方面是招的人数太少，一方面在腾讯做 Java 总觉得有点怪怪的。介绍百度时说的百度是以技术为导向的是说给腾讯听的，因为腾讯是以产品为导向的。产品的话语权比程序员大。\n腾讯的福利是特别香的，食堂也很好。特别今年把租房补贴涨到了4k。那肯定有鹅选鹅呀。\n近期搜狗也并入腾讯了，并到了腾讯的 Pcg 事业群下，目前各方面已经和腾讯对齐了。我有个同学先在腾讯的 PCG 实习，然后校招最终选择了去搜狗，结果又被并回 PCG 了，也是特别的缘分。上面的图就是我在搜狗茶水间拍到的照片~可以看到已经都换成腾讯 logo 了。搜狗不在西北旺，搜狗在五道口附近呀。\n阿里巴巴 坐标：望京\n2022校招薪资：开发岗白菜价 21-24k，sp 25-28k，ssp 29-30k。算法岗白菜价 25k，sp 29-31k，ssp 33-36k。每年 16 薪，签字费 1-10w，还会额外发 6k 的搬家费。\n个人评价：北京的阿里巴巴大楼在望京。另外目前阿里巴巴的北京总部也在建设中，预计2023年投入使用。阿里巴巴近两年一直有负面消息，我个人而言也不太喜欢阿里的狼性文化。但是有一说一，阿里的技术在国内的互联网是数一数二的。从阿里出来的职工跳槽的认可度绝对是很高的。不过还是求求你们别卷啦！\n字节跳动 坐标：中航广场\n2022校招薪资：开发岗白菜价22-24k，sp 26-28k，ssp 30-33k。算法岗白菜价26-29k，sp 30-32k，ssp 35k。每年15薪，还有1w-12w的签字费，我看大部分是 1w！住在 30分钟内可以到达公司的地方额外会有 1500 的租房补贴。\n个人评价：目前字节慢慢的把 BAT 中的 B 换成了 ByteDance 的 B，字节目前技术的认可度是很高的。我的一位学长 18 年时纠结去京东还是去字节（18年时我听字节跳动这个名字还有些许陌生），最终去了字节。然后他现在的薪资已经让我十分惊叹了。字节跳动的福利待遇也特别好，最近因为业务影响裁应届生虽然是无奈之举，不过或多或少对公司有点影响。字节最近在西安设立了研发中心，另外听说在青岛开了一个元宇宙研发中心，工作地点在市北，校招招人，感兴趣的可以去看看。\n美团 坐标：望京\n2022校招薪资：开发岗白菜价21k，sp 24k，ssp 27-29k。算法岗白菜价 24k，sp 27k，ssp30-32k。每年15.5薪。其余的福利也就是每天 30 饭补和 9 点以后打车了。\n个人评价：美团的技术绝对没得说，特别是对于应届生有不错的培养，美团的学城上有很多质量很高的技术资料，许多从美团离职的员工都想念美团的学城。另外给的薪资从去年薪资大涨后也算不错了。虽然今年校招比去年没怎么涨，只是在 ssp 的薪资上做了一些调整，但是凭良心讲，一个应届生这个价确实不低了。不过美团的办公环境和福利就太差劲了，首先美团的办公大楼都是租的，工位也都很简陋，也没食堂。别的公司过节发礼品，好家伙，你团发个贺卡，要么发个微信的红包专属封皮\u0026hellip;\n京东 坐标：亦庄\n2022校招薪资: 开发岗白菜价 19.5-23k，sp 25-26.5k，ssp 29k。算法岗白菜价 27.5k，sp 31-33.5k，ssp 36.5k。每年 15 薪。\n个人评价：首先说坐标哦，京东在亦庄，租房会相对便宜一些，省到就是赚到。然后说薪资，京东有个不太好的地方就是薪资的 20% 是绩效，虽然绩效一般都能拿满，但是这部分绩效就不用交住房公积金了呀。京东周末很少加班，周内大部分 8 点左右下班的样子。\n网易 坐标:西北旺\n2022校招薪资:北京这边网易的薪资划分的不太明确，我看开发爆料出的月薪从 18.4k、22k、24k、25.5k的都有。算法爆出的月薪 25.5k，27.5k, 30k的都有。每年 15 薪。\n个人评价:北京这边基本上都是网易有道团队的，今年薪资给的不太行呀，不过我百度的朋友和我说他每次晚上看网易大楼的灯总是关的最早的（西北旺聚集的几家公司在楼上可以互相看到对方）\n大型外企 外企的 wlb（工作生活平衡）一直是大家十分喜欢的，不过近几年由于国内互联网大厂给的实在太多了。同样的水平国内互联网给的薪资大概会比外企多50%左右。另外一些同学也会担心在外企待几年后工作和技术适应不了国内的强度。所以许多 offer 收割机拿到许多大厂 offer 和大型外企 offer 后也会犹豫该去哪。\n许多人会问面外企是否需要用英文面试？我问了几位在外企的老哥，共同的说法是要看你面的组和职级。有的组是频繁和国外开会交流的，这自然需要你英语好，但是如果你面的组和国外开会少，那么就不需要你英语好。另外看你面的职级是否比较高，如果职级高，和国外交流的事自然少不了。但是如果你只是组长给你布置活你干的话，也不需要你英语好。\nHulu 坐标：望京\n2022校招薪资：Hulu 招人的量不大，所以爆料薪资的人不多。有限的几个爆料的年包都在 50w 以上。\n个人评价：可能做开发的同学没听说过这个公司，不过做算法的同学应该知道这家公司的很多，这家公司出了一本挺不错的书籍叫《百面机器学习》。有许多同学应该在准备算法面试时看过这本书。Hulu 是美国的一个比较热的视频网站。严格的来说 Hulu 应该算是一家小而美的公司，不能算大型企业。但是因为 Hulu 工资不错，技术很好，另外也不加班。所以 Hulu 的 offer 比许多大型企业的 offer 还有诱惑力。\n微软 坐标：离五道口也不远。\n个人评价：微软的薪资情况和面试考察重点等在介绍苏州时已经详细介绍过了，就不在重复介绍了，大家感兴趣的可以看这里。不过相比在微软苏州工作而言，在北京的房价和消费情况水平下，微软北京的薪资就不算太香了。什么？给我 offer 我去不去? 马上去！ 微软北京前些年的落户指标比较多，不过近几年微软的落户指标相对少一些了。\nShoppe（虾皮） 坐标：五道口附近，和搜狗挨着。那片有好多互联网公司。\n2022校招薪资：白菜价 22k，sp 25k，ssp 27k。有3万签字费，以及12万股票分三年发放。\n个人评价：你可以把虾皮想象成东南亚的淘宝。我还是比较喜欢虾皮的，薪资很高，技术也不错。但是网传的 965 是没几个组能达到的，虾皮说是外企其实和国内互联网公司风格差不太多。近几年虾皮也越来越卷了。虾皮周六应该是不用加班，前两周周六我和我同学去转了一圈，大门是锁着的。听说周内 7 点到 10 点下班的组都有。\nAmazon 坐标：朝阳区远洋国际中心\n2022校招薪资：亚马逊的基础年薪我看到有30w和34.9w 两个档，配给员工的股票也有 23w 和 27w 两个档（第一年发5%，第二年发15%，第三年和第四年都是发40%），签字费第一年会给9.5w的签字费，第二年还会给6.9w的签字费。\n个人评价：最近几年外企不如国内互联网大厂开出的薪资高，但是外企的养生一直是大家十分喜欢的。亚马逊在外企中算是比较抠的，不过因为近几年亚马逊股票涨的多，所以给了员工股票后员工还是大赚。另外有个缺点就是亚马逊在国内的业务相对比较边缘，但是亚马逊的光环很耀眼，员工出来还是很受欢迎的。\nApple 坐标：朝阳区建国门外大街国贸大厦\n个人评价：苹果的保密相当的严格，我也没有关系好的在苹果上班的朋友，所以我也没找到苹果今年校招的薪资是多少。苹果北京的业务比较边缘，岗位基本都是做功能本土化的工作。工作时间是去掉午休后满 8 小时就可以。\nAirbnb 坐标:朝阳区环球金融中心\n2022校招薪资：基础年薪35w，额外基础薪资 15% 的奖金，8w 美元股票分 4 年发放。\n个人评价：爱彼迎优势是 wlb（工作生活平衡），且薪资也很不错，这个股票太有诱惑力了。 当然缺点也是有的，这里引用脉脉上一个 Airbnb 职工的匿名评论“Airbnb单纯做项目基本学不到啥技术 、框架封装的太完善且都是业务。自学能力强的话可以来，如果想单纯靠做项目提升能力就需要慎重了”。我感觉这个挺适合我的哦~ 上班干活，六点下班再写写文章，完美。\n好了，详细介绍的就这么多了。另外谷歌由于在国内招的人十分的少，我也没有在谷歌上班的大神朋友，所以谷歌的信息我就不知道了。Paypal 我找到的信息也有点少，也不展开介绍了，貌似 PayPal 在上海部门比较齐全，北京这边工作地点我最初都没搜到，还是根据朋友圈一个朋友提醒在 boss 上找到的，在朝阳区金地中心。\n生活成本 在北京的生活就仁者见仁智者见智了，有的人喜欢他的繁华与机遇，有的人讨厌他的拥挤与压力。\n房价 买房的事往后稍稍，咱们先说租房的事。注意啊，我下面说的上班方便基本上就是出门后一个小时内到公司呀！来了北京后大概率事要和人合租了，像上面说的在腾讯百度等西二旗这片区域上班的，大多数选择在回龙观这块和人合租，相对便宜且有地铁站上班比较方便。在回龙观这块租一个 10 来平的卧室大约 2500 左右吧。 在五道口那片上班和望京那片上班的在附近租房要更贵点，租一个 10 来平的卧室大概每月要花 3000+。当然在望京上班可以沿着14号线租的远点，租金会便宜点，上班直接坐着地铁过来也还挺方便。在亦庄那边上班的租房会相对便宜点，2000多点基本可以。想要一个住且在上述公司上班方便，租一个30平左右的一居室基本最低每月都要 5000 以上了。\n另外大家还可以瞅着点公租房，租金会比较便宜，单租一间 40 平的房子也就不到 3000，只是限制会比较多。部分公司会有公租房名额，我记得度小满就能协助职工申请公租房。申请一居室的会容易点，两居室的难申请。\n下面就说买房的事了，算了，我对北京买房的事也没什么见解。贴个图你们自己看吧，数据不一定准，就感受下房价有多高吧\u0026hellip;.密云延庆什么的就太远了，当然有很多人在北京上班在天津买房或者廊坊买房的。\n美食 有一句话叫“京城无美食”。虽然这句话有点极端但是也有点道理的。美食的聚集地大部分是沿山沿海沿河沿江的地方，北京一直不是一个美食原料富足的地方。北京常说的北京名菜特点不像鲁菜川菜江苏菜那样特点鲜明。我能想到的北京特色的饭也就是烤鸭、涮羊肉、爆肚、炒肝、京酱肉丝、炸酱面，除了这些还真不太好想了。在北京有个好处是你能在这里吃到全国各地的美食，因为北京全国各地甚至世界各地的人都有，所以各省各国风味的餐厅都会有，但是感觉风味上还是根据北京这边的口味做了一些改变。\n抛开美食说一个现实的问题，就是吃饭的花销。你在学校时一顿饭也就是十块左右。来到北京后吃饭的花销基本上要比你学校的花销贵一倍左右（因为老板的房租也会摊到饭的价格中）。如果你公司有食堂还好，要是公司没食堂只能吃外卖的话，自己的腰包和胃都受不了。说到这我觉得我以后晚饭还是自己做吧。\n教育\u0026amp;医疗 北京的教育和医疗肯定全国顶级了。再往详细的介绍我觉得我写不出什么有深度的东西了，对于教育和医疗来说，我觉得我这个刚毕业不到一年的人肯定不如在北京待了多年的并且有孩子的了解的多。我只是知道虽然北京的高考会比其它省份容易很多，但北京一贯实行的素质教育对于孩子家长来说会很累，今天陪孩子学个交谊舞，明天学个马术，后天学校开个家长联谊会。对于 996 或者 995 的程序员家长来说真的有点难顶，不像我们上学时很少叫家长了。\n娱乐 北京值得去的玩的地方很多的，圆明园、颐和园、故宫、香山、各种胡同、各种博物馆、各种茶馆。听个相声、听个演唱会，看个体育比赛都是不错的休闲方式。去各种商场转一转买点东西也是休闲。当然因为北京这么大所以周末出来玩一趟会特别花时间。北京的国家级景区票价是比较便宜的，我记得颐和园门票也就四五十，不像其它地区的景区动辄好几百的门票。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/beijing-02/","summary":"北京(下) 大家好呀，我是大白。第一篇“程序员在北京可以选择哪些国企、央企以及研究所”发出后被一些读者和号主夸奖了，十分开心。没看过的朋友也可","title":""},{"content":"长沙 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越来越全面了，但相同公司不同部门不同组的情况也差别很大，这里只能介绍一个总体情况，如果大家有更多的信息，欢迎联系我补充呀。\n这篇文章我们来以程序员的视角带你看长沙，长沙的房价真的是太香了。如果工资还可以的话，以长沙这个房价在长沙生活，是真的幸福。下面我们还是分工作机会，生活环境两个角度进行介绍。\n首先我们来看工作机会！\n工作机会 总体来说，长沙的互联网环境还是太差了！不过，相比于几年前也是在慢慢改进中！近几年许多知名互联网企业纷纷落户长沙，比如深信服、华为。不过，这些公司在长沙的研发岗位一般都很少，相当于一个办事处的感觉。\n长沙本土互联网公司的话，首推芒果 TV 和兴盛优选。另外，长沙这边的互联网公司集中于岳麓区，在这里会有更多选择。\n腾讯云 腾讯云和腾讯的关系一直是很多人好奇的，许多人把腾讯云称作腾讯的内包。腾讯云目前在西安、重庆、长沙三个城市设点。应届生水平根据薪资爆料差不多是 14k * 16，据说今年4月底时腾讯云的公积金已经调至 12% 了，也还不错。腾讯云的职级和腾讯不是完全对齐的，这点要注意。社招的话可以看下在 boss 的薪资水平。\n中兴 中兴校招给的薪资全国基本都一样，除蓝剑计划给的很高外，大部分人月薪给的集中在 13k 和 15k，少部分有 17k。社招的话大家看下boss上的薪资水平。\n芒果 TV 芒果 TV 是国内 A 股首家国有控股的视频平台，成立于 2006 年，公司总部位于湖南省长沙市金鹰影视文化城湖南国际会展中心西附楼。\n芒果 TV 可以说是长沙最能打的几家互联网公司之一了（虽然也有一些不好的地方）。\n根据其官网招聘来看，前端开发、产品经理、架构师等岗位都在招人。\n关于薪资的话，看准网上的参考薪资还是挺高的！像 Java 达到了 20k+ ，Go 达到了 16k+。不过，我觉得实际情况应该要稍微低一些。\n据说芒果 TV 平时加班很少，各种福利待遇都还不错！\n芒果 TV 内部大部分人养老，比较轻松，少部分人比较累。\n浩鲸科技 浩鲸科技前身是中兴软创（中兴的子公司），后来被阿里收购，加入了阿里云的生态圈（浩鲸科技非外包，浩鲸智能是外包！）。\n公司的技术一般，和大厂还是有一些差距。不过，被阿里收购以后，引入了不少阿里的技术体系。所以，应该也还是能够学到一些东西（很有限，和项目也有很大关系）。\n薪资水平在行业内算中等水平吧，现在研发岗，本科应届生也能给到 9-12k 的样子。不过内部加薪比较慢，待个几年后就会感觉比外面低了。这也算是行业通病了，加薪靠跳槽。\n公司福利的话只能说一般，班车补贴、餐补、出差补贴、端午、中秋、生日礼物也都有。\n另外，近几年加班强度明显一年比一年强，不过属于那种一阵忙一阵闲的，加班强度最大的应该是交付岗。有的岗位出差比较多，像国际中心，调研和交付岗，每年最少有半年在出差。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 13k +）、Web 前端开发工程师（薪资大概在 12k +）。\n总的来说，在长沙工作的话，浩鲸科技还是值得推荐的（虽然也有一些不好的地方）。\n兴盛优选 社区电商独角兽，湖南省第一家估值超过 10 亿美金的“独角兽”企业。兴盛优选发展还可以，获得了腾讯、京东、红杉资本等十余家投资机构的投资。\n在兴盛优选官网可以找到技术岗位的招聘信息。从招聘信息可以看出，薪资相对来说还是很高的!\n天鹅到家 天鹅到家（原 58 到家）成立于 2014 年，是国内 Top 级别的家庭服务平台。\n相对来说，天鹅到家还是值得推荐的，不过，长沙这边招聘的技术岗位不多。\n校招的话，先去公司参加笔试，面试体验还可以，问的问题都是基础的问题，都是在学校里学的知识比如数据结构，数据库，算法、网络。社招的话，面试一般难很多，会问很多多线程、分布式、数据库方面的问题。\n关于薪资的话，智联招聘上的高级 Java 后端开发参考薪资在 15k 左右。\n拓维云创 拓维云创是一家主要做外包的公司，2008 年登陆深圳证券交易所成功上市。公司总部位于岳麓区桐梓坡西路 298 号拓维软件园，在北京、上海、深圳等地有子公司。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 10k +）、.Net 开发工程师（薪资大概在 10k +）、C++开发工程师（薪资大概在 15k +）。\n这家公司技术面试的一般没有笔试，难度也一般。\n华为 长沙这边有一个华为长沙研究所，地址也在长沙市岳麓区。\n如果想在长沙追求高薪的话，华为是很好的选择，按照华为的工资水平在长沙买房简直是轻轻松松！\n不过，据我了解，华为在长沙仅仅是一个办事处而已，研发岗位很少很少，毕竟已经有武汉研究所了。\n武汉离长沙也比较近，如果想去华为的话，还是建议选择武汉的华为研究所。\n华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。\n华为在长沙的社招我不是特别清楚，只是知道华为社招大部分给的是 OD ，社招想拿正式 offer 基本都需要 16 级以上的评级。\n在华为上班是压力比较大，也比较累的，这个就不多说了，大家应该都清楚。\n深信服 深信服在长沙也有分部，不过，研发岗位比较少。\n京北方 一家大型外包公司，总部位于北京，在广东、山东、江苏、长沙、程度等地有子公司。\n不过，据说北方有点坑，实际情况和招聘的时候说的那一套严重不符，工资也非常低。另外，还有网友爆料这家公司有随便开人的嫌疑，\n我一个哥们当时也去了这里面试，不过，据他所说：“体验极差，面试官看着非常油腻，格局不大！”（作为参考，不同的面试官带来的面试体验差别很大）。\n一般是先电话面试，然后现场面试，会问一些项目上的技术问题，不过，都比较简单。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 9k +）和软件测试工程师（薪资大概在 5k +）。\n另外，大型外包公司中软国际在长沙也有分公司。\n科大讯飞 科大讯飞在长沙岳麓区有一个小分部，不过，招聘的很多都不是技术岗位。\n中国长城科技 大型国企，相对来说还行。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 10k +）、后端架构师（薪资大概在 12k +）、全栈工程师（薪资大概在 12k +）。\n福利这块的话，公积金还是可以的。\n湖南竞网智赢 湖南竞网智赢网络技术有限公司主要提供的是互联网营销综合服务。公司总部设在长沙高新区麓谷企业广场，全省服务团队规模过 1000 人，服务企业 20000 家。\n面试体验的话还行，整体面试过程流畅，两轮的面试官整体素质都很高，HR 问得有点细，工作环境感觉还是不错的，就是大小周有点可惜。\n关于薪资的话，看准网上的后端开发参考薪资在 10k 左右。\n超维创想信息技术有限公司 这家公司的总部位于北京，网上的信息少之又少！\n根据智联招聘上的最新数据，目前，长沙的招聘岗位只有 Java 开发工程师，薪资大概在 7k+。\n东华软件 东华软件 2001 年 1 月成立，总部位于北京中关村，在长沙、武汉、上海等地有子公司，2006 年 8 月在深圳主板上市。\n这个公司规模还挺大的，不过，据说待遇很一般，工资比较低，平时也没什么福利。并且， 领导爱画饼，也学不到什么技术。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师、项目经理。\n关于薪资的话，看准网上的 Java 开发参考薪资是 12k 左右，不过，我觉得实际情况应该要稍微低一些。\n梦网云创科技有限公司 梦网云创科技有限公司是国内最大规模之一的企业云通信平台，总部位于深圳，在长沙、重庆等地有子公司。\n不过，研发岗位主要集中在深圳和长沙。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 13k +）和软件测试工程师（薪资大概在 7k +）。\n薪资待遇相对来说，还是挺不错的！\n梦网云这家公司在网络上几乎没找到任何评价，所以，我这里也不多做评价。感兴趣的小伙伴，可以自己了解一下！\n其他 其他还有像 福米信息、万兴科技 、亚信 等公司，这里就不多介绍了。\n其实程序员在长沙，目光不要只着眼于互联网软件公司，长沙有许多军工芯片类型的公司待遇也很好。另外许多大型制造业公司，比如三一重工、中联重科、山河智能等公司也在招程序员，待遇也很好。\n生活环境\u0026amp;生活成本 房价 长沙的房价真的就太香太香太香了！！！作为一个省会城市，房价竟然还要比很多普通的地级市都要低。\n以下房价数据来源于安居客，可以作为参考。\n可以看到长沙新房的均价在 9500 附近。\n即使是互联网公司比较多的岳麓区，新房均在也才在 12000 附近。\n教育 先来看高中！\n长沙有四大，长郡/雅礼/师大附中/一中，每一个都是全国有名的重点高中。有多厉害？长沙市雅礼中学“一本录取率”：92.6%，长沙市长郡中学“一本录取率”：93.4% \u0026hellip;\u0026hellip;\n长沙人虽然也重视教育，但是学区房之类的价格还是比较友好的。\n再来看大学!\n长沙有 3 所 985 高校，分别是国防科大、中南大学、湖南大学。放眼全国，一所城市能够 3 所 985 的少之又少！\n其他的比较好的学校还有 湖南师范大学（211）、湖南农业大学（一本）、长沙理工大学（一本）、湖南科技大学（一本）\u0026hellip;\u0026hellip;。\n医疗 医疗资源在二线城市中算不错的。湘雅三个医院，省人民医院，省妇幼，都是还不错的医院。\n交通\u0026amp;气候\u0026amp;娱乐\u0026amp;美食 交通一般，这几年一直在修地铁（12 条线路），道路复杂。并且，长沙的司机素质普遍比较差，感觉每个人都很急，很赶时间。\n气候讲真不太友好，多雨，炎热，夏天的时候没有空调真活不下去。\n基本没有说错，这是个基本只有夏季和冬季，但是夏季冬季随机播放，没有空调基本没法生活的城市。\n娱乐和美食这个就不用多说了，毕竟长沙的娱乐业还是比较发达的，美食也有很多（很多外地人专门跑到长沙吃美食）。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/changsha/","summary":"长沙 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越","title":""},{"content":"成都 在一些读者的强烈要求后，我终于开始对成都下手了。成都近些年发展的速度极其的快，感觉西部地区的互联网环境能发展成这样实属不易。今天我们就以程序员的视角带你看成都。\n其实我读大学时没怎么接触过四川人，直到读研来了西安，感觉西安的四川人好多啊（西安到成都最快的一趟车3个小时17分钟）。身边接触的四川人逐渐多了起来，加上我的四川舍友（读研来报道时我的四川舍友看着暖气研究了很久），让我逐渐对四川有了一些了解。感觉四川人普遍是真爱吃火锅，真爱吃辣呀，另外我发现四川人普遍懂得享受生活~ 在开始介绍城市前先为成都定一个基调吧，那就是 享受生活。\n本篇文章还是从成都的工作机会、生活成本两个角度来介绍成都。\n工作机会 互联网公司 嗯\u0026hellip;刚把主题定成享受生活，不过调查了下发现，在成都的这几个互联网大厂还都挺卷的。不过成都这个消费水平，加上这几个大厂这么高的工资，扶我起来，我还能加班。为了描述方便，我把一些严格意义上不算互联网的也一起介绍了。\n腾讯 基本情况：腾讯在成都的部门算是挺多的了。天美（王者荣耀）、WXG（在成都主要是做企业微信的那部分）、PCG 。\n薪酬福利情况：腾讯在成都的薪资体系是和总部对齐的（参考去年校招，给的工资是17k，18.5k，20k，21.5k，23k五档)。不过给你工资的定档会稍微低一些。比如你的能力面腾讯总部是大Sp，去成都的腾讯可能给你定档就只能是小Sp了。另外有租房补贴有食堂，全额住房公积金。\n面试特点：校招笔试不是必须做。面试八股文+手撕代码。2-3轮技术面，1轮hr面。\n工作强度：听说成都这边的腾讯加班挺严重的。不过成都这样的房价，在腾讯这么好的部门、开这么多工资，还要啥自行车？\n阿里巴巴 基本情况：我去阿里巴巴招聘官网查了一下，阿里在成都的需求量很大。根据贴出的招聘信息感觉在成都需求最多的就是蚂蚁，其次本地生活和菜鸟的需求也不少。平头哥和阿里云也有招聘需求，但感觉不是很多。\n薪酬福利情况：阿里成都的薪资也是和总部对齐的，住房公积金全额12%。成都的阿里巴巴目前在蚂蚁C空间办公，没有食堂！不过楼下是银泰城商业街，吃的选择还比较丰富。中午和晚上吃饭各补贴 20 块钱，中午直接给现金，晚上是餐券。\n面试特点：笔试必须做，笔试题难度挺大。一道 Leetcode 中等难度和一道困难难度的题在一个小时内做完，基本上测试用例过30%能进面试。面试后手撕代码不多，不过对于原理性知识问的比较深入。\n**工作强度：**成都阿里工作强度大部分部门是 995。\n字节跳动 基本情况：看了下字节跳动在成都的岗位很多，前段、后端、客户端、SRE、算法都有。\n薪酬福利情况：成都的字节会在北京字节薪资的基础上打个九折，所以在校招薪水上看薪资爆料会看到很多带小数点的薪资报价，住房公积金全额12%。。比如 23.4k * 15，这个薪资相当于北京的 26k * 15。字节的食堂一直是让人很羡慕的，成都字节也直接包了三餐。省到就是赚到呀。\n面试特点：有的部门通过内推可以免笔试，有的部门笔试必须做。3轮技术面+一轮hr。面试比较注重手撕代码。\n工作强度：成都字节加班也不轻，基本上是早上十点上班，晚上十点下班。\n美团 基本情况：美团在成都主要是闪购、企业平台、餐饮生态、外卖。在成都这边的美团部门都比较边缘。\n薪酬福利情况：薪酬福利部门我开水团就和上面几家有差距了。成都的美团的薪资会在美团北京薪资的基础上打个八五折，住房公积金8%。。就比如去年北京美团 sp 是 24k，在成都就是 20.4k。公积金食堂不是自己的，是外包食堂。美团的办公环境也不太好。\n面试特点：笔试必须做。2-3轮技术面+一轮hr。面试比较注重手撕代码。\n**工作强度：**美团成都的工作强度相对来说没那么大，技术方面还是可以的。\n京东 基本情况：成都京东的业务布局还是很全面的，商城技术线、技术中台、商城客服线、数科客服线、物流都有。听说京东健康也打算过去。\n薪酬福利情况：京东的福利待遇一般，之前的一年14薪一直被诟病，不过今年成了16薪了。京东成都薪资基本上是在北京薪资的基础上打8.5折。另外京东的薪资构成里面会加绩效。住房公积金是交6%，这有点过分呀。京东在北京的食堂感觉不错，但是在成都的京东食堂我没找到相关信息，有了解的老哥跟我说下。\n面试特点：可以通过部门直推免笔试。2-3轮技术面+一轮hr。面试八股文问的多，手撕代码较少。面试难度总体上较为友好。\n工作强度：京东周末一般是不加班的，周内早上9点上班，晚上下班时间看部门，7点到10点下班的都有。\n华为 基本情况：华为在成都的部门挺齐全的。基本上每个产品线都有。\n薪酬福利情况：成都华为和西安华为的薪酬基本一致。校招生的话根据评级月薪 13k-19k 都有，如果干的好工资涨的还挺快。12%住房公积金。食堂也不错。\n面试特点：笔试必须做，三轮技术面。第一轮主要是笔试代码的复盘，第二轮面试八股文+写代码，第三轮总监面半问技术半聊理想。\n工作强度：华为的产品线都是很累的，不过加班费挺到位的。做技术预研的相对好点。\nOPPO 基本情况：成都 OPPO 的岗位挺全的，项目主要是平台技术中心、浏览器、手机软件、中间件等。\n薪酬福利情况：一个 OPPO，一个 VIVO，给钱贼大方。我 看OPPO 成都去年给应届生开的价总包基本都在30w以上了。也太有钱了。\n面试特点：感觉面试总体难度适中。2轮技术面+1轮hr面。技术面基本就是八股文面试+手撕代码。\n工作强度：OPPO 在成都各个部门的加班情况不太一样，大部分部门能双休，但也大部分部门晚上9点以前走不了。\n龙湖数科 基本情况：你们是不是觉得混入了一个奇怪的公司~ 我看到成都有，就给大家介绍下龙湖的数字科技部吧。龙湖数科成立时间不久，现在也在砸钱组建团队。我参加过龙湖仕官生的招聘（这个计划会把你当成核心来培养，龙湖有个好处是可以自己选择是否技术轮岗）。\n薪酬福利情况：龙湖为了组建团队现在也是下了血本，应届硕士校招都能开到四五十万的年包了，不过工资构成主要是通过年终奖把总包提起来的。相关福利也都不错，听入职的同学说好像他们上班有个什么积分（好像是叫龙积分），这个积分还能用来买东西。工作一定年限后买龙湖房子也能打折。\n面试特点：我感觉面试难度不大，校招时一面就简单问了问项目，然后提了两个比较基础的问题。二面稍微上了一些强度，就面完了。让我提问，我问了问他们在做什么，通过他们的讲述我感觉他们的技术和目前的互联网公司还是存在一定差距的。\n工作强度：因为组建不久，所以工作强度还没上来。\n建制齐全业务全面的大型互联网公司主要是上面这些了。还有一些互联网公司在成都也设立研发岗位，我快速给大家过一遍。\n滴滴：滴滴因为之前的事现在日子不太好过，在成都主要是橙心优选业务。\n爱奇艺：手游岗位和算法岗位在成都。\n**新浪：**主要事绿洲业务，岗位不多。\n**携程：**我去扒了下招聘网站，没看到现在招人。好像会不定期招人。\n**科大讯飞：**科大讯飞主要事围绕语音在做的，成都主要是智慧城市业务。\n中兴：在成都规模不大，中兴的薪资不算高，给应届毕业硕士月薪差不多是15 k。\n联想：在成都的岗位挺多的，Java、物联网、边缘计算等都有招人。\n国企研究所 中电29所、中电10所、中电30所 基本情况：成都的几个中电系列的研究所效益还算不错。其实在效益比较好的中电系列的研究所收入还可以，但是这伴随着你要经常的出差和加班。中电系列的研究所出差一天貌似是要给 280 左右的补助。很多中电系列研究所的职工一年有三分之一的时间在外面出差。工资加上出差补助每年挣得其实也不少了。但是天天在外面飘着得感觉可不好受。效益比较好的中电系列得研究所大部分是 996 起步。\n中航工业611所 基本情况：611所基本上是在成都的研究所的最好的选择了。我说明一下，航天工业是负责出地球的，也就是造火箭相关的。航空工业是造飞机相关的。航天工业和航空工业的效益普遍好一些，福利待遇也比较完善，但是这几年工作也挺累的。工资涨幅比较慢。\n核动力研究院 基本情况：工资不是很高，年薪大概15万左右（税前），工作比较稳定。\n总体上这几个研究所的性价比是 中航工业611所 \u0026gt;核动力研究院 = 中电系列研究所。研究所工作比较稳定，但工资涨的很慢，工作中扯皮的现象会比较多。喜欢哪种生活看个人了。\n农行软开 基本情况：我对农行软件开发中心的印象挺不错的。部分部门会加班比较严重（有个哥们在农行挺苦逼的），不过大部分部门还是比较轻松的。技术和互联网公司有一定差距，不过工作稳定。转正后每月月薪到手是一万二。在成都节奏慢点享受下生活不香吗？\n招银网络 基本情况：招银网络算是招银的子公司，为了归类较为统一我就把他放在这里了，但是招银网络不是国企啊。和招行信用卡中心不一样，招行信用卡中心是属于招行总行的。招银网络算是银行软件开发里最像互联网公司的，给的工资水平基本能和互联网公司持平。\n工行软开 基本情况：工行软开的技术在银行软开中还是不错的。不过工资给的不如农行多。西安和成都工行给的工资相对于北上广珠要少一点。成都的工行软开属于总行序列。本科生和硕士生进入工行后职级都是助理经理，年薪总包 20 万左右，本科生每月工资就比硕士生少几百块钱。工行软开每月发的工资会少一些，然后年终会一下发好几万的年终奖。本科生需要两年才能升经理一，硕士需要一年就可以升 经理一。升到 经理一 后表现好一年就可以升 经理二，不过从助理经理到经理二的薪资涨幅不大。从毕业到升职成为经理三（相当于组长）最快需要五年，经理三的年薪还是很可观的。\n除此之外邮储银行的软开、中信银行的软开以及浦发银行的软开也不错，注意，浦发银行的软件开发中心被子公司化了。另外成都各银行的省分行的科技岗位待遇也不错。\n生活成本 房价 让很多在一线工作多年的程序员把成都当作第一撤退选择的就是成都的房价。在有上述这么多互联网公司的城市里，成都的房价几乎是最低的了。在青羊、武侯、高新、锦江、天府新区等几个区买房会贵一点，均价都在两万以上了，其它几个区的房价都在每平一万多的水平。8月份成都二手房均价是一万四每平。下图来自安居客，大家可以参考下。如果在上面列出的公司工作的话，买房压力不会特别大，另外相对于去北上广深，刚毕业在成都租房会便宜很多，这样也能更多的把工资省下来。\n教育 感觉四川的高等教育方面不错，但小学、初中、高中教育资源并不是很好，高考难度不小。不过四川的优质教育资源基本都在成都了。大学方面，985有两所，四川大学和电子科技大学。211有3所，四川农业大学、西南交通大学和西南交通大学。另外成都理工大学、成都大学、成都信息工程大学等也不错。\n高中方面成都的七中林荫校区、树德宁夏校区、石室文庙校区、七中高新等等都很不错。成都有30所左右的高中，高考的一本率都能超过50%。\n美食\u0026amp;娱乐 成都的美食就很多了，美食之都不是白叫的。成都也是川菜的发源地。大家都知道四川人喜欢吃辣，不过四川的辣是香辣，还是很不错的。美食我就不一个个数了，数也数不过来呀。\n娱乐方面我是发现四川人是真的爱玩。成都的小酒馆和麻将馆都是四川人十分喜爱的。好多人中午吃完饭就急匆匆的往麻将馆跑，去迟了就打不上了。另外想去景区玩一玩的话成都的旅游景点也非常的多。\n交通 成都的交通方面也很棒，近年来大力发展轨道交通，截止今年6月，已经开通12条线路了，地铁运营里程排行全国第四。开车的话堵车是肯定会堵的，现在还没见过哪个二线以上城市不堵的，但是成都相对其它同级别城市会好不少。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/chengdu/","summary":"成都 在一些读者的强烈要求后，我终于开始对成都下手了。成都近些年发展的速度极其的快，感觉西部地区的互联网环境能发展成这样实属不易。今天我们就以","title":""},{"content":"大连 大家好呀，我是大白。今天我们来以程序员的视角看一下美丽的大连。话说我印象中大连是没有什么程序员的就业机会的。但是一直有读者想让我写，那我就安排一下。不过在调研大连的互联网环境时，还是发现几个让我惊喜的公司，还有号称山海关以北最强的开发团队。一起来看吧！\n由于大连这边互联网的关注度较低，所以我废了九牛二虎之力也就搜寻到有限的信息。不能像其它的城市那样薪资福利列的明明白白了，只能我搜集到啥就说啥了！\n工作机会 大连的互联网公司特别少，主要是外包公司，还有挺多做软件的外企，话说我在调查大连的互联网环境时看到大连有这么多外企还挺吃惊的。这是我第一次介绍程序员的就业机会先介绍外企，在大连的软件行业来说，这些外企确实比其它类型的公司值得加入。\n外企 LINE LINE 基本上是程序员回大连的第一选择了，可能很多人没听说过。LINE是做社交聊天工具的，在日本和韩国特别火，你可以把它想象成日本和韩国的微信。LINE的技术是很强的，号称山海关以北最强开发团队，面试的技术要求挺高，社招比较喜欢从 BAT 回大连的程序员。工作时间是 965，有的部门会加班。\n给的薪资福利在大连是数一数二的，网上没找到 LINE 的具体薪资爆料。问了一下了解的人，薪资大概和北京三线互联网公司开的薪资持平（在大连住开这个工资很带劲呀），加班有加班费。招聘的岗位比较少，就招 JAVA 和安卓。\nSAP 程序员在大连工作的话 SAP 也是一个好去处。SAP是一家德企，是全球最大的企业管理和协同化商务解决方案供应商。SAP 的技术挺不错的。待遇方面是基本工资＋10%左右的年终奖金。主要节日奖金888，有加班的话，双倍三倍全额付。t3以上买车有补贴。买公司股票有优惠。每年base也有稳定增长。\n思科 曾经的思科十分强大，但是近些年慢慢的不太行了。大连的思科主要是劳务派遣，跟大连软件园签合同。有机会转成正式职工，要看业绩。如果在思科做正式职工还是挺爽的，不加班，工资水平在大连也排在前列了。\nIBM IBM 大连还不错，但也没想象的那么好。IBM的办公楼在黄泥川，比较偏远。大连的IBM主要是对日本的业务。薪资方面前些年IBM还是很有优势的，不过近些年也只能算中等了。\nIBM的优势在于学习资源比较多，工作轻松且稳定，有着很不错的企业文化。\n花旗金融 花旗银行的岗位主要在上海，大连比较少。大连的工资基本上是上海的八五折，有个应届硕士校招薪资爆料是 15.8k * 12。这薪资在大连还是不错的。工作比较轻松，一般下午 6:30 都能下班。花旗的技术还是不错的。\n埃森哲 埃森哲虽然是外企不过也是外包。在网上说埃森哲好的和不好的都有。我调查了一下发现，进入埃森哲后，进入不同项目组后的工作体验差距十分的大。有的项目很好，也不忙，但是有的项目组进去以后加班十分严重。然后就是埃森哲工资水平比较低。校招薪水上有爆料，2021 年毕业的 211 硕士，月薪 7.4k * 13，这也太少了吧。\n大连的外企是真不少，我就不一一详细介绍了，我把他们列在下面，大家感兴趣的话去了解下。\nAVAYA、infosys、思佰益、富达、简伯特、甲骨文（逐渐放弃中国市场了）、HP、纬创、罗克韦尔\n互联网 腾讯大连无线研发中心 腾讯大连无线研发中心实际上是由两个大连公司合并而成，一个叫世纪鲲鹏，一个叫世纪成讯，腾讯100%控股。注意，腾讯大连无线研发中心算是腾讯的一个全资子公司，和腾讯的北京和深圳这些研发中心的性质不一样，所以薪资和福利不是对齐的。大连这边是属于腾讯 MIG 事业群的，工作地点在大连甘井子区，招聘岗位基本都是后端和游戏岗位。校招薪资多多少少有点辛酸，看一个硕士的校招薪资爆料，一个月税前一万，每年 1-2 月的年终奖。看 boss 上的社招薪资资还凑合，看下图。\n西山居 西山居是我比较喜欢的一个团队。大家可能对于这个名字有点陌生，西山居其实是金山的游戏团队，技术还挺强的，剑网 3 就是西山居的产品。西山居的部门主要是在北京和珠海，大连招聘的量比较少，在大连能去西山居工作的话还挺舒服的。薪资我没打听到准确的，有三年左右经验的月薪也就是税前13-15k左右吧。\n话说大连的互联网公司是真的约等于没有。能拿的出手的也就上面两个了，另外还行的就是大商天狗和长城汽车了，大商天狗是做电商的，不过产品使用人群仅局限于大连，流量很小。大商天狗招的岗位很多，看boss上放出的职位目标薪资在大连也还算过的去吧，岗位也比较丰富。长城汽车成立了一个数字化中心在大连也设有岗位，但是招的人也很少。\n外包 接下来就是大连的主要 IT 力量了，那就是外包！大连的外包公司是真多。最近我的一个朋友去了外包，也让我对外包有了更多的了解，话说我才发现外包公司给的工资比一些中小型的互联网公司还高。我朋友之前没有编程经验，经过培训去了西安的一家外包公司给华为做外包，和华为的上下班时间是一致的，周一周二周四加班到晚上 9 点，周三周五 6 点下班，周末加班的话三倍工资。福利基本就是逢年过节发点月饼和油之类的，年终奖几乎没有。每个月的工资和加班费加起来每月到手将近 1 万（他是跨行过来的，西安能给这么多我还是比较吃惊）。\n我个人认为去外包的发展是不如去有自己产品的公司的，不过对于一些计算机编程基础较差暂时进不到好的公司的同学来说，也是一个锻炼自己的地方。下面我就详细介绍一下东软吧，其它的大家感兴趣自己去了解。\n东软 东软在国内的外包里算是不错的。虽然是外包，不过接的项目还不错，都是比较大型的项目，主要接政府的外包。也做医疗方面的产品卖给医院。入职后也是和大的互联网公司一样有导师制的，东软一些员工的实力还不错，新人进去后对于个人能力的提升挺有帮助的。作息就看部门了，有的部门比较清闲，但是有的部门忙起来也是挺可怕的。东软的工作环境还是不错的，园区修的很漂亮。东软的工资和福利待遇方面就不太行了。\n大连这边的东软招聘的岗位很多，招聘数量也挺大的，放一张 boss 上招聘的截图，大家可以参考下呀。\n外包我也就不一一介绍了，我把有的外包列在下面，大家感兴趣的话自行去了解呀。\n中科创达、中软、华信、亿达信息、文思海辉、软通动力、华宇、心医国际\n生活成本 房价 大连的房价其实挺高的，在上述这种工资水平下，二手房挂牌价还将近每平1万6呢。不过有个好消息是最近大连的房价一直在跌，许多炒房的被套了，哈哈哈。要是再降一降，去个 Line 或者 SAP 以及腾讯大连的子公司工作，那美滋滋呀。\n教育 教育方面大连还是不错的。高校方面有一所 985（大连理工大学），一所 211（大连海事大学）。其它的大连交通大学，东北财经大学，大连大学，大连海洋大学等等也都不错。\n大连市共有75所高中，其中省级示范高中25所。大连24中，大连育明高中，大连八中，大连一中，大连二中，大连八中，大连十一中都非常的不错\n美食\u0026amp;交通\u0026amp;风景 首先因为大连是滨海城市，所以在大连的美食是海鲜为主的。话说在滨海城市吃海鲜，口感会比内陆好很多，内陆的海鲜大部分经过长时间的冷冻，吃起来口感会差很多。\n交通方面大连还是挺堵的，记得大连经常被百度地图列在十大堵城里。而且大连的地铁线路就三条就太少了。\n大连的美景绝对是让人留恋的，看看海还真的是让人心情舒畅啊。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/dalian/","summary":"大连 大家好呀，我是大白。今天我们来以程序员的视角看一下美丽的大连。话说我印象中大连是没有什么程序员的就业机会的。但是一直有读者想让我写，那我","title":""},{"content":"广州 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我把我最近收集到的信息以及读者的补充添加到了文章中。\n广州的互联网环境相对来说还不错。\n广州的繁华以及它的魅力不用我多说，无论从人文还是从经济来说都是不虚其它城市的。不过我在面试时发现，广州除了几个头部大厂是统一薪资标准外，相较于其它一线城市，广州的互联网行业给我的感觉是整体薪资水平偏低。\n大家注意呀，其实学计算机相关专业的想在广州挣钱，不止可以通过互联网公司，也可以通过当公务员，教师等方式去挣钱呀。应届生考进体制内当公务员，年薪也20多万呢，并且各方面福利待遇绝对到位，相当不错了。下面我们还是分互联网公司以及国企央企研究所介绍吧。\n声明一下，下面的内容仅代表我个人的调查结果，如果大家知道更多的信息，欢迎补充呀。\n工作机会 互联网公司 网易\n网易在广州主要是游戏部门。算是网易的核心业务了。注意，网易面试时候是散装的，网易互娱、网易雷火和网易互联网是分开招聘的，我当时投简历都是分开给他们投的，同样的简历我在网站上填了三次，累死。不过好处就是你有三次机会能进网易 ~ 注意，互娱、雷火、互联网的薪资方案也是不一样的。网易的薪资方案很复杂，这里面水太深，我感觉我有点把握不住~ 我知道有人拿到sp大概就是 25k * 16吧，还会有股票。网易食堂的伙食是真的好，大部分人去了工作一段时间都胖了。\n微信\n广州主要是腾讯的 wxg 事业群，也就是微信。wxg 事业群的效益非常好，能进 wxg 还是很棒的，不过面试难度也挺大的。腾讯去年校招的薪资分 17k，18.5k，20k，21.5k，23k 几个档次，hr说是应届生第一年保证18薪，不过第二年就不保证了哈。注意，腾讯开出的薪资是可以argue的，如果他给你的薪资不满意，你可以用其它offer跟腾讯的 hr argue 更高档次的薪资，有成功的。另外校招生还有签字费以及股票以及租房补贴。腾讯时不时送点小礼物，工作的舒适度还是不错的。\n字节跳动\n广州的字节整体上不如其它地方的字节加班严重，不过也要看部门，有的部门听说挺累的。字节之前一直是大小周，前不久刚刚宣布要取消大小周，有双休还是挺幸福的，就是要少挣不少钱了，看你是不是奋斗逼了。我看到21届字节校招的薪资主要是每月20k，22k，24k，26k，28k，30k不等。不过我看校招拿到广州这边offer的大部分是22k和24k的月薪，\n欢聚时代\n大家看到欢聚时代这个名称可能有点陌生，其实 YY 和 虎牙 都是欢聚时代的。欢聚时代的薪资水平我不清楚，我问了朋友也不清楚，我就去查校招薪水上的薪资爆料。有点迷呀，去年校招，开发方向的月薪14k、16k、18k 的都有，但是这算法薪资的爆料咋还直接就 27k 呢？这也差的太多了吧。有靠谱消息的老铁欢迎来补充。\n唯品会\n唯品会算是广州本地的一霸了吧，唯品会的福利挺给力的，包三餐，双休，租房补贴。本科生开发的月薪主要集中在14k-16k。\nSHEIN\n这家公司我熟，我就给你们展开讲讲。这家公司最近势头很猛，做跨境电商的，主要卖女装。我在去年秋招初期还面试过这家公司，面试难度比较友好。首先是 hr 给我发了个笔试链接，让我几天内找个时间做了。通过笔试后，第一轮面试，面试了大概有 30 多分钟，主要问了项目以及面试八股文，没有让写代码，然后面试就通过了。第二轮面试，面试官随便问了两个八股文问题就开始聊理想了。第三轮面试好像是他们的 cto，问我高考数学考多少分 ~ 问我上学期间大概写了多少行代码~ 然后又聊了几句就跟我结束面试了。就给我 offer了。后续hr跟我谈薪的时候说他们加班少，工资是 16k * 14，我觉得工资有点少，就没接offer。\n三七互娱\n我了解到三七互娱后端岗位大部分是 PHP，本科生校招进来薪资大概是12k 左右吧，每年发 15个月的工资。在知乎上对三七互娱的讨论比较多，有黑点，每个部门的情况也不太一样，大家可以再去了解下呀。\n小鹏汽车\n小鹏汽车最近风头正盛，应届生校招进来的工资基本在 16k 左右，每年15薪。小鹏汽车目前是大小周呀，工作强度还是比较大的。\n酷狗音乐\n酷狗音乐是腾讯的这应该大家都知道，不过内部的薪资职级不是完全对齐的哈。酷狗的不同部门工作强度差别很大，有的闲的要死，有的忙的要死。选择部门时要注意。\n4399\n4399大家应该都不陌生，好多小游戏都是从小开始玩的，工资也在16k左右。\n好了，我算看明白了。广州互联网这边除了几个头部大厂，做开发的应届生薪资差不多就是16k呀，感觉有点低。其它的在广州设点的互联网公司我直接列到下面啦，实在写不过来了，大家有兴趣的详细了解呀。\n分别有：科大讯飞、TCL、小鹏汽车、荔枝FM、多益游戏、太平洋、UC、CVTE、小米（目前正在建设中）、华为（正在建设中）\n运营商 感觉待遇一般，就是比较轻松，追求轻松和稳定的可以看下。\n移动\n移动每月的工资很低，可能到手就五六千块钱，然后年底会一下再发五六万的年终奖，有时候会更多一些。据说 18 年效益好年底一下发了 8 万，19 年就拉跨了。\n联通\n转正后每月到手八九千，绩效好能到手一万左右。\n电信\n我看到 offershow 上有做网络运维的爆料，入职第一年每月到手8.5k，年终发了3.5万。\n研究所 工信部第五研究所（赛宝实验室）\n据我所知，工信部下属的研究所福利待遇各方面都是不错的、平台也很大。但是每个部门的情况也差距很大呀，去研究所一定要找到那种效益好的部门，选对了起飞，选不对就坑了。\n中电7所（广州通信研究所）\n我打听了一下，这个研究所工资待遇不高，也就是图个轻松了。\n我找了下没找到航空航天类在广州的研究所。其它类型的研究所也会招计算机相关专业的，目前计算机专业是万金油，哪里也招，不过你进了重点不是放在计算机行业的研究所，技术上的发展肯定不太好。如果有比较好的研究所也欢迎补充呀。\n生活成本 房价 大家直接看图，相比于其它一线城市房价算是便宜了。但是按照广州互联网的工资水平想在广州差不多的区域和地段买房，压力是很大的。\n教育 广州的985大学有两所，分别是中山大学和华南理工，211也有两所是暨南大学以及华南师范大学，另外广州大学、广东工业大学等等也都不错。广州的高中也很给力，华南师范大学附属中学、广东实验中学、广东广雅中学、广州市执信中学、广州二中、六中等等学校都很不错。\n医疗 一线城市的医疗资源肯定是没问题的，我粗略数了一下，广州有不下40所三甲医院。我了解到顶级医疗资源主要有中山系、南方系、广中医系等等。\n风景\u0026amp;美食 广州的美景自然不用多说，另外空气质量也很好，说起空气质量，我这个北方人已经习惯冬天经常见不到太阳了。广州的美食也很多，白切鸡、煲仔饭和肠粉等等，还有很多我就不报菜名了，我在西安上学时食堂有个卖肠粉的窗口，我很爱吃，不过这个肠粉明显是本地化了。话说南北差异还是挺大的，我一个同学去广州上学，去洗澡带着搓澡巾，他的广州舍友都十分的好奇~ 当然广州的同学看我拍雪景也很好奇 ~ 还有一次实验室和厦门大学一起合作做项目，我和一个厦门大学的博士都要了一份豆腐脑，我加韭菜花，他加糖，我两面对面坐着都觉得对方的不能吃。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/guangzhou/","summary":"广州 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我","title":""},{"content":"杭州 一二线大厂 字节跳动  基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。今年 6 月，抖音电商落户杭州。 业务方向 ：抖音电商、抖音餐饮、字节跳动广告业务、字节跳动本地生活 工作地点 ：余杭区中国杭州 5G 创新园 5 层、余杭区杭州巨量引擎网络技术有限公司 1401 福利情况：六险一金(12%)、包三餐、免费下午茶+零食、免费健身房、Top 薪酬、住房补贴 招聘情况：主要招聘后端（Java、Go）、前端、测试等岗位。 面试 ： 面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。  阿里系  基本情况 ：阿里系占据了杭州互联网的一片天，相关联的企业是在是太多了。 业务方向 ：达摩院、淘宝、菜鸟、钉钉、飞猪、盒马、支付宝、夸克、UC、书旗小说\u0026hellip;\u0026hellip; 工作地点 ：西湖区、滨江区、余杭区\u0026hellip;\u0026hellip; 福利情况：7 险一金（全额住房公积金）、节日礼物、带薪假期、集体婚礼。 招聘情况：主要招聘 Java 后端开发、数据研发、数据分析、算法工程师等岗位。 面试 ： 不论是校招还是社招，技术面试问的都比较深入，通常会针对一个技术问题深入挖下去。 补充 ：加班的问题比较严重，受不了 996 的小伙伴慎重考虑。  京东  基本情况 ： 京东在杭州也有招聘，不过，招聘的岗位比较少。 业务方向 ：京东金融、京东云 工作地点 ：杭州拱墅区中国智慧信息产业园 M 座 12 楼 福利情况：五险一金、年度体检、住房补助、餐补、带薪假期 招聘情况：主要招聘 Java、产品经理等岗位 面试 ： 京东的技术面试采用常规面试，并且问的相对简单一些，而且可以部门直招，不需要笔试。技术面试有时候是两轮，有时候是三轮。在京东如果两轮面试以后你直接遇到了 HR 对你面试，你一般就是普通 offer 了。第三轮的主管面会决定是否给你 sp。但是！据我所知，京东 HR 面挂掉的人还挺多的，所以京东的技术面走完以后还不太稳。HR 面完你以后，如果隔一段时间问了你身份证号，并核对你毕业时间后，这就很稳了。我是 HR 面完的当天下午，HR 找我核对的。  网易  基本情况 ：网易在杭州有一个研究院，成立于 2006 年 6 月。 业务方向 ：⽹易杭州研究院，简称“杭研”。杭研是⽹易内部的基础技术研发中⼼和前沿技术研究中⼼，在云计算、⼤数据、安全、⼈⼯智能等⽅⾯进⾏前沿技术研究、关键技术攻关和基础技术平台研发，服务⽹易系游戏、邮箱、⾳乐、电商、新闻、在线教育等产品，触达近 10 亿⽤户。 工作地点 ：杭州滨江区网易大厦二期网商路 399 号 福利情况：运动设施、生日礼物、免费班车、五险一金、补充医疗险、重疾险、意外险、定期寿险 招聘情况：主要招聘 Java 、前端、区块链等岗位。 面试 ： 技术面试通常由 2 轮，最后 1 轮一般是 hr 面。注重项目和基本功 , 既要有广度还要有深度。  华为  基本情况 ：华为在杭州有一个研究所。 业务方向 ：智能摄像机、云服务 工作地点 ：杭州滨江区华为技术有限公司杭州研究所 福利情况：员工股权激励、薪资非常有竞争力。华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。 招聘情况：主要招聘软件开发（Java、C++）、嵌入式开发、测试等岗位。另外，华为社招一般都是 OD 模式。 面试 ： 面试的话，难度一般，主要看学历。 补充 : 华为加班比较多，压力可能会比较大。不过，薪资收入在全国绝对是 Top 级别。  其他 除了上面介绍到的这些一二线大厂之外，杭州还有下面这些不错的公司：\n 旷视科技 : 人工智能产品和解决方案，Face++云平台就是他们家的产品。 商汤 : Ai 领域独角兽，业务涵盖智慧商业、智慧城市、智慧生活、智能汽车四大板块。 \u0026hellip;\u0026hellip;  国企 中移杭研  基本情况 ：中国移动的一个全资子公司，2014 年在杭州成立。 业务方向 ：统一认证、融合通信、魔固云 工作地点 ：杭州余杭区中国移动(杭州研发中心)余杭塘路 1600 号 福利情况：五险两金（企业年金）、补充医疗保险、意外保险、带薪假期 招聘情况：主要招聘前端、后端、安卓、算法等岗位。 面试 ： 面试的话，难度一般，主要看学历。  之江实验室  基本情况 ：之江实验室是浙江省委、省政府贯彻落实科技创新思想，深入实施创新驱动发展战略的重大科技创新平台。 业务方向 ：智能感知、智能计算、智能网络、智能系统 工作地点 ：杭州市余杭区文一西路 1818 号中国人工智能小镇 10 号楼 福利情况：五险一金、Top 薪资、住房保障、优惠税收、带薪假期、餐补 招聘情况：主要招聘软件开发、芯片设计、DevOps 、测试等岗位 面试 ： 对学历要求特别高！  金融相关 同花顺  基本情况 ： 同花顺成立于 2001 年,总部位于杭州未来科技城，是国内第一家互联网金融信息服务业上市公司。同花顺作为一家互联网金融信息提供商，致力于为各类机构提供软件产品和系统维护服务、金融数据服务和智能推广服务，为个人投资者提供金融资讯和投资理财分析工具。 业务方向 ：旗下有多款热门投资理财类 APP。 工作地点 ：杭州余杭区同花顺新大楼总部同顺街 18 号 福利情况：薪资中等偏上，其他福利情况未知 招聘情况：主要招聘 Java、C++、前端、机器学习、产品经理等岗位 面试 ： 技术面试难度一般，而且通常就只有一轮技术面试。这是一位去面试同花顺后端开发的朋友给我反馈的面经：“面试官非常和善。上来就让你做个自我介绍，回答哪里毕业，毕业之后在哪工作，熟悉的技术栈。然后问了为什么离职之类的。之后开始问之前做的项目，重点问你做了哪些有亮点的项目，随便答了个高并发下保证原子性的项目，然后和面试官一起讨论会不会有更好的解决办法。”  51 信用卡  基本情况 ： 51 信用卡（母公司为杭州恩牛网络技术有限公司），公司创立于 2012 年，是一家服务于中国亿万信用卡用户的互联网金融公司。 业务方向 ：旗下有“51 信用卡管家”、“51 人品”、“51 人品贷”等 APP 工作地点 ：杭州西湖区中节能·西溪首座 B3、杭州西湖区西溪谷 G 座 福利情况：六险一金、生日礼物、节日贺礼、生育关怀、精彩团建、年度体检、年度旅游 招聘情况：主要招聘 Java、前端、安全、数据仓库等岗位 面试 ： 面试难度一般。技术面试一般会有 2 面，最后一面是 HR 面。  本土互联网公司 蘑菇街  基本情况 ：2011 年，蘑菇街正式上线，2016 年 1 月与美丽说战略融合，公司旗下包括：蘑菇街、美丽说、uni 等产品与服务。 业务方向 ：电商 工作地点 ：杭州西湖区黄龙万科中心 G 座 福利情况：无限的零食饮料供应、健身房、咖啡厅、 招聘情况：主要招聘 Java 后端、前端、移动开发等岗位。 面试 ：面试难度中等。技术面试一般会有 2 面，最后一面是 HR 面。 补充 : 据说公司的工作体验还不错！  有赞  基本情况 ：有赞，原名口袋通，2012 年 11 月 27 日在杭州贝塔咖啡馆孵化成立，是一家主要从事零售科技 SaaS 服务的企业，帮助商家进行网上开店、社交营销、提高留存复购，拓展全渠道新零售业务。2014 年 11 月 27 日，口袋通正式更名为有赞。2018 年 4 月 18 日，有赞完成在港上市。2019 年 4 月，腾讯领投有赞 10 亿港元融资。 业务方向 ：SaaS 服务（帮助商家网上开店、社交营销\u0026hellip;\u0026hellip;）、PaaS 云服务。 工作地点 ：杭州西湖区杭州有赞科技有限公司西溪路 698 号、杭州西湖区黄龙万科中心 G 座 福利情况：全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘后端、前端、移动开发等岗位。 面试 ：面试难度中等偏上。一般由 3 轮面试，前 2 面是技术面，最后 1 面是 HR 面。这是我的一位去面试有赞 Java 后端开发的朋友给我反馈的面经：“确定通过。面试官 nice，看中专业技能，1 小时以上。1 面问基础，很细很广，能问的基本都问了个遍。Java 基础、多线程、JVM、RPC、限流算法、降级算法、分布式事务中间件、Redis、分布式锁\u0026hellip;\u0026hellip;面了 70 多分钟，面的头晕眼花，还好大多都答出来了。直接约第二天 2 面 2 面，面试我的是未来的 leader,跟 1 面相比差不太多，有些偏重解决问题思路。3 面 leader 很年轻也很有个人魅力，交流了下个人情况也提了很多建议，离开的时候还送我下电梯送出大门面试体验很棒，公司环境也不错。” 补充 : 公司技术不错！主要招聘 Java 开发，做 Java 的可以优先考虑这家。  外企 Zoom  基本情况 ：Zoom 是一位美国华人企业家创办的公司，主营业务就是提供视频会议服务。总部位于硅谷，国内的话，杭州、苏州、合肥均有研发中心。 业务方向 ：视频会议 工作地点 ：杭州滨江区海康威视东流路 700 号 福利情况：全额五险一金、商业保险、餐补、年度旅游 招聘情况：主要招聘算法、测试、Web 前端、全栈、C/C++（后端开发这块 C++招聘偏多一些）、Java、Go。 面试 ：难度一般，外企一般比较重视计算机基础知识。 补充 : Zoom 的工作环境、企业文化什么的好评度在国内外都挺高的。不过，据说也存在部分项目组加班的情况。965 不加班，work life balance。技术氛围好，相处简单。  Cisco(思科)  基本情况 ：思科系统公司（Cisco Systems, Inc.），简称思科公司或思科，1984 年 12 月正式成立，是互联网解决方案的领先提供者，其设备和软件产品主要用于连接计算机网络系统，总部位于美国加利福尼亚州圣何塞。 业务方向 ：路由器、交换机等网络基础设施 工作地点 ：杭州上城区中豪·望江国际 4 幢 20 层 福利情况：全额五险一金、商业保险、餐补、年度旅游 招聘情况：主要招聘 Java、前端等岗位 面试 ：难度中等偏上，外企一般比较重视计算机基础知识。  其他 除了上面介绍的这几个外企之外，杭州的外企还有 ArcSoft(虹软) 、MicroStrategy (微策略) 、RingCentral、State Street (道福) 、Tata (塔塔) \u0026hellip;\u0026hellip;\n生活环境\u0026amp;生活成本 我们再来看看生活环境和生活成本。\n房价 杭州的房价不忍直视啊！！！涨的实在是太厉害了！个人感觉泡沫很大。\n以下房价数据来源于安居客，可以作为参考。\n教育 杭州只有一所 985，也就是浙江大学。除了浙江大学之外，浙江省就没有 211 工程院校了。不过，杭州电子科技大学虽然不是 211，但是实力很强，外界也很认可。\n交通 杭州的交通情况一般，经常听杭州的朋友吐槽杭州的交通很智障。\n根据杭州地铁官网上的数据，杭州目前一共有 10 条线路。\n从杭州这边去其他城市也都比较方便，大部分地方都有高铁或者飞机直达。\n美食 杭州饮食的包容性比较强，你想吃的在这边基本都能找到，种类非常多。\n各种火锅烤肉、川菜粤菜什么的随处可见。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/hangzhou/","summary":"杭州 一二线大厂 字节跳动 基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。今年 6 月，抖音电商落户杭州。 业务方向 ：抖音电商","title":""},{"content":"南京 大家好呀，我是大白。被读者催了好久，我终于开始调研南京的互联网公司了。南京是很有吸引力的一座城市，我在西安读研时听我导师和其它老师闲聊，就说很多我们学院看上的老师，最后都被南京的学校抢走了。最近我也发现许多安徽人都选择去南京工作生活。有句话说的很对，”安徽不能没有南京，就像东北不能没有三亚“。不过我调研中也发现，对于程序员来说，想要在南京留下也不是件很容易的事情，因为南京程序员的工作机会只能算一般，薪资水平这两年许多大公司选择在南京设立分部后才带起来一些，但是南京的房价已经很高了。\n提一下哈，在这个系列里说的校招薪资都是常规招聘计划的薪资，说的常规招聘计划给出的 offer 包含普通 offer，sp (special offer) 和 ssp。不包含那些比如华为天才少年、美团北斗之类的。那种神仙 offer 怎么样我这种凡人还真不了解。这些招聘的薪资也都是针对本科生和研究生的。如果你是博士，薪资方面和公司都好商量。\n南京的信息感觉相对较少，调研过程中几次自闭。所以校招薪资大家就当个参考，不是特别的准确，不过公司整体的基调应该都反映出来了。\n私企 阿里巴巴 校招薪资：招的人不多，具体薪资情况不太清楚。据说和总部薪资水平差不多。阿里的薪资水平可以参考下链接。\n个人评价：阿里巴巴在南京招人的部门主要是 CCO，阿里云也会有一些名额。岗位是挺齐全的，前端、后端、测试、算法都有。今年的校招 CCO 也就招了 20 个左右。\n字节跳动 校招薪资：字节在南京的薪资是字节在北京上海深圳薪资的 0.9。感觉薪资水平挺不错了。今年字节校招薪资也可以点这个链接查看。\n个人评价：南京这边字节的部门还是挺多的，游戏中台、客户端、数据平台、广告算法这些团队都在招人。团队也不能算边缘，在南京字节工作的话还是挺不错的。\n荣耀 校招薪资：月薪 17k - 27k（对应13-15级），每年 14-16 薪。\n个人评价：对于不太关注新闻的学生荣耀可能不太熟悉，今天展开介绍一下，你会发现接下来连着几家都是卖手机做通讯的。华为之前有荣耀手机的业务线，荣耀手机一直走价格较低的大众化路线，后来因为美国制裁，所以荣耀被拆了出来。目前荣耀大部分人员都是华为过来的，最近也在大量招人。所以荣耀目前可以看作一个翻版华为，各方面都是在学华为，但是后期能不能学的像就另说了。\n荣耀和华为校招面试时方法一样，根据你面试的表现给你定级，然后通过所定的级别来和你谈薪。大部分本科生是13级，面试表现很好的话可能会定到 14 级。研究生大部分是 14级，一些面试表现一般的可能也会定到13级。15级基本上需要读书期间发过有含金量的论文或者参与过重大开源项目。南京荣耀工作制度基本上就是 996。\n华为 校招薪资：13级月薪 20-21k，14 级 23-25k，15级月薪 26-27k。每年 14-16 薪。16级我就不清楚了。\n个人评价：感觉华为今年校招薪资水平提升了不少，我校招那年抠的要死，14a 才能给到 19k。要是今年这薪资水平我很可能就留到西安华为了，也就不北漂了。不过华为只给 5% 的公积金是有点低。感觉华为想要评到15级以上是需要你在读书期间有一些能证明你能力的东西，比如比较有含金量的论文，或者参与过重大的项目。如果手里没含金量的东西，靠面试表现来说最多也就是给到14级了。（反正我面试那年是这样）。华为对于部分特别牛逼的硕士会给到 16级。南京华为在几个研发中心算是加班比较少的，只是相对啊.\n小米 校招薪资：小米的薪资是挺抠，不过放在南京来看也还行。看校招薪水上南京的薪资爆料今年有 11k，14k，16k，18k，19k，21k，23k 几个档。11k，14k基本都是本科生，硕士做开发岗的大部分是16k，18k，19k这几个档。20k 以上的基本都是做算法的。\n个人评价：南京的小米算是一个比较大的研发中心，有些小米比较核心的部门。南京小米大部分组周末双休是能保证的，周内上班到几点各组情况不一致，总体上就是 995 这么个情况。\nVivo 校招薪资：南京这边目前看到给应届生的价钱分为月薪17k，20k，24k三个档，，每年15薪。额外每个月有 1500 的租房补贴。住房公积金5%。\n个人评价：之前 Vivo 是有大小周的（就是隔一周一次单休），去年九月份统一成双休了，工作制度差不多 995 或者 9105 的样子。周内就没时间干别的事了，不过 Vivo 这个薪资在南京确实算是还不错了。\nOPPO 校招薪资：具体薪资不太清楚，大致应届生月薪在 20k 上下，每年 14 -15 个月薪资。\n个人评价：OPPO 的薪资没调查清楚，信息比较少，不过应该和 VIVO 差不多。蓝绿两厂都是从步步高拆分出来的，两兄弟从薪资上以及工作模式上都很像。OPPO 和 VIVO 在南京都算是不错的选择。\n中兴 校招薪资：中兴常规计划（指的是普通 offer)的月薪基本都在20k 以内，蓝剑计划年薪会在 40w 以上。\n个人评价：中兴这两年的竞争力一直处在一个下滑的状态，感觉蓝剑计划还不错，但是名额很少，一个部门只有一两个名额。当时中兴蓝剑计划来我们学校宣讲过，我和一个部门的 leader 下来聊了下，看了我的情况以后说常规批次的最高的 offer 给我没问题，但是蓝剑他们目前备选的两个人手上都有含金量很高的论文和项目，我和人家差距很明显。中兴常规招聘计划的 offer 和大部分大公司就没法比了。\n360 校招薪资：没调查清楚，年薪差不多 23w 左右。\n个人评价：南京360有建邺区和九龙湖两个办公区，九龙湖的业务比较核心。360 目前工作生活比较平衡，在介绍北京时详细介绍过 360，大家可以点这里进去看下，来北京 360 我还是比较推荐的。南京 360 主要做 toB 业务，目前南京 360 的状况不太好，还传出过南京业务团队会被撤掉的传言（这只是传言啊，真实性不是很高，但是也反映出 360 南京业务情况不太好）想要去的话大家自己一定要问清楚。\n深信服 校招薪资：开发岗有3个档，月薪分布在15.6 - 22.8k 这个区间，算法岗也是三个档，月薪分布在19 - 25.2k 这个区间。每年13 - 15 薪\n个人评价：深信服总体来说加班挺严重的，不过南京的深信服相对深圳稍微好一点。比较好的就是深信服技术还不错，另外付出和收入成正比，其实大部分人不是吃不了苦，而是工作时付出和收入不成正比。\n趋势科技 校招薪资：看到校招薪资爆料有三个档，分别是年薪 20w，23.5w 和 25w。\n个人评价：趋势科技是一家外企，在南京很多年了，在安全方面做的不错。可以看出来，趋势科技的工资不算高（这个薪资在前两年还可以，但在今年各大厂校招薪资大涨的情况下就不太够看了），工资低伴随着公司很多技术大神流失。并且公司在20年底有次大的人员架构调整，也走了很多人。目前公司只是胜在工作轻松加班少了。\n亚信安全 校招薪资：基本上月薪在15-18.5k 这个区间，每年 13- 15薪。\n个人评价：亚信安全主要做运营商的项目。亚信科技知乎上被喷的还挺多的，不过亚信安全目前风评还可以，加班少些。\nSHEIN 校招薪资：目前看校招薪资爆料月薪基本集中在16-23k，有个说自己 27k 的不知道真的假的（如果是真的，感觉 SHEIN 大部分老员工要RUN了）。每年14薪。\n个人评价：SHEIN 我曾经还拿过这家公司的 offer。公司做跨境电商的，主要卖女装。面试相对容易一些，基本就是问些常问的八股文，都没让我手撕代码。SHEIN 技术还行，一些拿不到大厂 offer 的同学，先去这里也还不错。另外就是我听说南京的 SHEIN 越来越卷了，不是曾经的 965 了。\n满帮集团 校招薪资：校招薪水上的爆料开发月薪基本都在 20-30k 这个区间，算法基本都在 27-36k 这个区间。大部分人每年 14 薪。\n个人评价：满帮就是南京的本土企业，主要是做货运业务的。南京这边能给出上面的薪资，确实难得，不过从给这么多钱就能看出来，加班肯定少不了。满帮目前招人挺多的。\n国企 中电系列 南京有中电 28 所、中电 14 所、中电 841 所。有一些读者跟我说想去研究所，想法是去研究所可以工作生活平衡。但是现在有很多的研究所其实很忙的，工作生活平衡的研究所尤其不包括南京这几个。841 所还不是特别清楚。大部分互联网公司和中电 28 所以及 14 所 比起来还真是弟弟，不过根据南京的薪资的水平来说，这两个所得福利待遇算是顶级了。刚毕业的应届生进去工资大概每月到手是一万出头吧，有食堂有宿舍，出差会有出差补贴，差不多一天三四百，这几个所出差会非常的多。\n南瑞集团（国网电科院） 南瑞集团是国家电网直属的科研企业单位，主要做电力系统自动化相关设备，所以会招很多程序员。年薪 14 万左右。南瑞要给各个省公司做电力软件，所以出差的情况会非常多。面试上南瑞以后你还没有国家电网编制，想要编制还要去参加电网的考试。感觉性价比一般，不如去省公司，听说省公司工资还挺高的。\n运营商 几个运营商里只有联通在南京有研究院专门做软件相关，除此之外想去运营商就只有省公司了。一些运营商的子公司我就不多介绍了，我是感觉国企的子公司性价比一般，既没有国企的稳定也没互联网的高薪。\n烽火 简单说下烽火，下面有烽火星空还有烽火通信。是国企，不过感觉一直处于一个乙方的位置。项目很多是涉密项目，但是我劝大家尽量少碰涉密类型的项目。如果手头没大公司可以去烽火锻炼下，如果有其它大公司的 offer，我感觉还是优先其它大公司了。\n生活 房价 房价这里想多说一点，有些还没毕业的同学问我应该怎么选择幸福感高的城市。其实我的感觉是你在一座城市的幸福感很大程度取决于你工资和房价的比值，其它因素都是次要的。平均下来你每月的工资接近你所在城市还可以的区域的房价，那么你生活的就很舒服。就比如你工资每月到手一万二三，你所在城市房价也一万二三或者稍多点，那你买房压力并不大。但是如果你所在城市房价很高，就比如北京。你每月到手两三万的工资已经很厉害了，然而像昌平差不多的地段房价都四万以上了，那你买房压力肯定很大，换而言之你生活的幸福感肯定不高。天天租房还和人合租，能有啥生活幸福感？当然对于那些想待几年学点东西就撤的同学另当别论哈，我说的是定居的考虑。\n南京的房价还是比较高的，比较好的区域的房价直逼一线城市了，对于刚毕业的学生来说压力很大了，感觉这个房价应该逼走不少人。 另外南京物价也不低噢。下面这张图是网上找的，不一定准，可以当作参考。\n教育 南京高校资源方面很强。南京大学、东南大学、南航、河海大学、南理工等等都是很不错的学校。另外南邮、南京工业大学这些双非学校的计算机也很强。感觉近几年各个大厂陆续在南京设分布也是看中了南京有大量的计算机相关专业的毕业生。 江苏高考题的难是出了名的，当然江苏省的中小学教育资源也很优质，所以在教育这方面选择南京还是不错的。\n交通\u0026amp;风景\u0026amp;气候\u0026amp;美食 南京拥堵程度是上过全国前十榜单的，我租房是喜欢宁愿住的小一点差一点也尽可能离上班地方近一点，我比较抗拒通勤。宏观上来说，南京的地理位置特别好，离苏州、杭州、上海都很近，另外离安徽也很近，这也是安徽人喜欢往南京跑的原因。\n南京的风景不用多说，六朝古都的文化底蕴加上江南细腻的风景足够让人流连忘返，周末出去转一转还是挺令人放松的。\n南京气候感觉不怎么好，很潮，另外南京到夏天总会下很大的雨，我同学本科在南京上的，校园经常就被淹了。\n南京菜是挺有名的，南京菜比较杂，融合了很多地方的风味。大家应该都能找到适合自己口味的菜。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/nanjing/","summary":"南京 大家好呀，我是大白。被读者催了好久，我终于开始调研南京的互联网公司了。南京是很有吸引力的一座城市，我在西安读研时听我导师和其它老师闲聊，","title":""},{"content":"青岛 最近我发现青岛的呼声很高，所以我就先把青岛安排了。我和青岛的缘分来自于我的山东舍友、同学以及师兄。在三年的研究生生活中，以及我山东舍友带我们宿舍去青岛的毕业旅行，让我深刻的体会到了山东文化。我身边的山东同学一直给我一种努力并且踏实的感觉，还很热心。另外我发现山东人大部分都能哈酒，特别讲究酒文化，那个山东舍友带我们宿舍去青岛还有日照哈了一周的酒，最后真顶不住了。\n山东这边有个说法是不孝有三，没有编制为大。最初我还不理解，不过去山东转了一圈以后发现，如果是在青岛生活的话，还是去有编制的好。因为好私企真的有限呀。下面我就把招程序员的公司来捋一遍吧。\n工作机会 青岛软件行业的发展太滞后了，没有大规模的软件公司，做软件的公司大部分都是外包公司，而且规模还很小。\n海尔 海尔在青岛多年了，曾经有段辉煌期的。我舍友带着我在山东哈酒时，一个老大哥在酒桌上就跟我们聊起来，说他当初在海尔买家都是要请他们吃饭才卖给产品的。不过近些年海尔就不太行了，但依然在青岛是个工作上的好选择。海尔 Java 岗位给应届 985 硕士的报价是年薪 14 万。本科生相对少一点，年薪大概在 8万 到 12万 左右。我路过海尔时感觉海尔的园区还修的挺漂亮的。另外说一句，感觉海尔卡奥斯还行，在工业互联网领域做的还可以。\n海信 我之前总觉得海信和海尔有某种联系，不过我查了下并没有，路过海信的园区时觉得海信也修的挺漂亮的。一个 211 硕士爆料的薪资是每月 10k，然后一年 13 个月工资。福利待遇方面感觉还可以，前两年有免费宿舍，交通补贴每月 200，住房补贴 800 每月，可以领三年。试用期 6 个月，试用期间 90% 薪资，免费班车，公积金 10%，社保全额。工作早9晚6，中午休息一小时。\n另外就是如果还是喜欢互联网氛围的话去海信聚好看比较好，就是海信电视上那个 APP ，听说技术还不错，给的工资也相对较高。不过加班多啊。\n光大银行青岛研发中心 待遇听说还不错，以前是归分行管，现在归总行管。青岛这边主要开发云缴费业务。据说是有末尾淘汰机制。近几年好多员工都跑到青岛银行了。\n青岛银行 青岛银行总行的技术岗。薪资不算高，有薪资爆料是年薪12w，不过算是摸鱼的天堂了，活大部分是外包干。\n青岛凯亚 在青岛软件企业能算中上游了，不过全靠同行衬托。加上各种补贴，一年的工资差不多是是十二三万吧。试用期工资打五六折。技术还可以，不过有人爆料说他加班还挺多的。\n青岛鼎信 主要做通信的公司，一个应届硕士的爆料是税前13k，每年13个月的工资，有食堂，每个月600的饭补。\nYeelight Yeelight 算是在青岛为数不多的小而美的公司了，目前团队330人，研发人员超过一半，主要做智能照明，有小米的投资。听说团队氛围还不错，比较重视技术。我在网上没找到校招待遇的介绍，社招的话 BOSS 招聘 3-5年 Java 经验的报价是 12k-24k。\n中车四方 中车四方是国有控股公司，薪资待遇在青岛算中上。也招程序员。应届毕业生是6个月试用期，转正以后每年工资税前差不多15w左右。不过他这个工资构成和别人不一样呀。每月税前一万左右的工资好像其中六千左右是绩效，然后每年年中会发一个业绩奖金，不同部门的奖金差别很大。\n中电41所 说实话，我一直对中电系列的研究所印象不是很好，不过听说中电28所的薪资后对中电系列的印象有所改观（这里是闲扯一句哈，中电28所在南京，和青岛没啥关系）。注意41所得总部是在安徽，青岛只是一个分部，我了解到是加班会比较严重。\n好嘛，好不容易凑出来这几个程序员的工作机会，大家要是还知道一些比较好的工作机会，欢迎来补充呀。\n生活 房价 青岛房均价两万多了吧。崂山和市南比较贵，其它地相对好一些。下面这张图有各区的房价，不是太准，不过可以参考下呀。感觉程序员在北京干几年，攒个首付，然后回青岛找个相对稳定的公司上班，买房压力还不是很大（除了买崂山和市南啊）。\n教育 感觉青岛的教育方面很不错。\n大学方面，山东大学在青岛是有校区的，虽然离市区是真的远，但是人家有地铁呀。我记得坐那趟地铁去山东大学青岛校区找我舍友时穿越崂山，窗外的风景是真的漂亮。中国海洋大学也是一所985，校区是真的漂亮。中国石油大学是一所211，也挺不错的。另外像青岛大学、青岛理工大学、山东科技大学这些院校也是不错的。这几年各个高校也在青岛修建了研究院，感觉还是挺有发展前景的。\n高中方面，青岛二中、青岛一中、青岛五十八中、青岛九中、即墨一中等都非常好。不过山东高考的压力是真的大，感觉我大学和读研时身边的山东同学，当年高考都是英雄般的人物。\n风景\u0026amp;美食 青岛是真的挺美的，感觉在青岛既能感觉到现代化大都市的感觉、又能体验到民国风情还能体验到欧式风情。另外我同学带我在青岛转时，经常走着走着就见到了大海，这让我这个多年身居内陆，没见过海的少年来说还是挺欣喜的。感觉青岛比西安冷很多，今年4月西安已经很热了，花都开了，但是去了青岛以后发现柳树才刚有一点点绿，还挺凉快的。\n青岛的海鲜是挺丰富了，让我这个很少吃海鲜的少年一次吃了个够，还买了些海鲜给家里面寄了点。果然内陆的海鲜吃起来和沿海城市的海鲜差好多，另外山东菜是真的能倒酱油。\n交通 感觉青岛交通还是不错的，地铁线路挺发达，尤其是有条地铁线直接从市里通到山东大学让我觉得很赞。坐车在市里游荡的时候不知道是不是因为避开了拥堵的地区，我感觉堵车不太严重。不过山东人开起车来是真的有点猛。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/qingdao/","summary":"青岛 最近我发现青岛的呼声很高，所以我就先把青岛安排了。我和青岛的缘分来自于我的山东舍友、同学以及师兄。在三年的研究生生活中，以及我山东舍友带","title":""},{"content":"上海 大家中午好啊！我是大白。\n程序员视角观城市系列已经更新有 6 期了，我们一起看了西安、长沙、天津、广州、青岛。除了广州之外，其余的都是二线城市。\n最近，上海的呼声比较高（在上海工作的小伙伴很多啊）。于是，我利用晚上下班回家之后的自由支配时间整理了一下上海的互联网公司和生活情况。\n由于上海的互联网公司实在太多，这篇文章也只是挑选出一些比较有代表性的来简单介绍一下。\n希望能够对你们有帮助！整理不易，希望大家能够多多帮忙扩散转发支持一下。大白在这里谢过了！\n国内一线大厂 作为一线城市，绝大部分大厂即使总部不再这里，也会选择在这里设立分部，吸引当地的人才。\n腾讯 腾讯总部在深圳，在广州、上海、北京、成都、武汉、香港等地都有办公室。\n腾讯把长三角作为重要业务布局区域，2002 年进入上海，2008 年落户徐汇。腾讯华东总部预计在 2021 年正式迁入徐汇滨江的总部大厦。\n腾讯上海分部主要发展人工智能、游戏、腾讯云等业务。\n招聘这块的话，上海腾讯主要招聘 C++、安卓开发、测试、游戏工程师、后端开发等岗位。\n腾讯的各种福利非常不错的，各种福利补助，上班也不需要打卡。\n校招的话，一般会先让你做一个笔试。笔试考察的内容比较全面，既有计算机基础又有编程题。实习的话，一般是先进行一波电话面试，主要问你一些比较编程基础相关的问题。\n不过，腾讯的 KPI 面试比较严重，你的简历指不定被哪个部门捞起来。\n字节跳动 字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。\n字节跳动 2014 年在上海设立分部，上海的员工总数 6000+，其中设计师、研发工程师、信息技术科学家等专业技术人才的人数已经超过 2000+。\n字节跳动预计在未来 2 年之内，将上海员工的人数增加至 2 万，重点扩张张音乐、游戏、电商团队。并且，抖音电商业务相关的所有团队有预计会整合到上海。\n招聘这块的话，上海腾讯主要招聘数据分析、Java 后端、前端、 C++、安卓开发、iOS、测试等岗位。\n面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。\n字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。\n阿里巴巴 阿里巴巴总部在杭州，在北京、上海、广州、成都等地都有办公室。\n阿里巴巴三个总部和三个中心落户上海，其中三总部是支付宝总部、盒马总部、本地生活总部，三中心是阿里上海研发中心、阿里新零售中心、蚂蚁科技中心。\n加班的问题比较严重，受不了 996 的小伙伴慎重考虑。\n招聘这块的话，上海阿里巴巴主要招聘 Java 后端开发、产品经理、算法工程师等岗位。\n阿里进入面试后就很少问代码题了，但是对原理性的问题问的比较深，经常会问一些你对技术的思考，比如，你觉得Sring好在哪？如果答的比较浅的话，通常不能让面试官满意。\n美团 美团总部本身是位于北京，由于旗下产品大众点评起源于上海，因此，美团在北京和上海设立双总部。\n除了北京上海之外，美团还在厦门、成都，深圳等地有办公室。\n美团旗下产品有美团、大众点评、美团外卖、美团优选以及美团买菜。\n招聘这块的话，上海美团主要招聘 Java 后端、前端、测试、安卓等岗位。\n面试这块的话，一般也会有手撕算法环节，总体难度一般。美团几乎没有部门直招，都是先把简历投在池子里，然后由部门从池子里进行打捞。内推可以定向推事业群，但是感觉内推作用不太大。美团的面试是五道代码题（我记得应该是，这记忆有些模糊）。做出三道就稳进面试了，做出两道也有可能进面试。\n美团的技术面有时候两轮，有时候三轮。不过美团只进行两轮技术面就给你 offer，有可能也是 sp，因为我就是~\n拼多多 拼多多还是挺厉害的，创建于 2015 年 4 月，现在应成为中国第二大电商平台。\n拼多多的研发部门主要在上海，其他地方虽然也有办公室，不过基本不招技术人员。\n招聘这块的话，上海拼多多主要招聘 Java 后端、前端、数据分析等岗位。\n拼多多秋招会有很多轮，拼越计划、提前批、正式批。我当时投的是拼越计划。面试也是常规面试。我当时一面通过，二面代码题写的有点问题，思路有了但是代码一直有个 bug 。面试官就把我调客户端了，又加了一轮面试。对了，客户端这两年各大厂都急缺，面试也相对容易。面 java 的完全可以没有客户端经验，然后转到客户端岗位面试，客户端考核计算机网络会比较多。\n拼多多客户端技术面完以后迎来的是 HR 面，但是不知道怎么回事 HR 面没过。这也是我唯一的一场 HR 面没过。另外给大家说明下，拼多多开出的 offer 的薪资几乎是业界最高，但是拼多多是真的累，常态化的一周六天上班时间大部分人是顶不住的。\nPDD 工资非常高，不过，据说办公环境非常一般，工作强度也非常大（一周 6 天，上午 11 点到晚上 11 点）。\n其他 除了上面介绍到的这些一线大厂之外，上海还有哔哩哔哩、携程、快手、百度、京东、网易等不错的互联网公司。\n金融相关 平安 平安诞生于深圳，旗下包括平安寿险、平安产险、平安养老险、平安健康险、平安银行等涵盖金融业各个领域的 30 多家子公司，像比较出名的金融科技公司陆金所就是平安旗下的。\n招聘这块的话，上海平安主要招聘 Java 后端、前端、测试、数据分析、算法等岗位。\n面试这块的话，一般会有两轮技术面，一轮 HR 面。技术面试的提问内容主要根据你的项目经历来问。\n东方财富 东方财富主要做金融相关的服务，包括证券、基金销售、金融数据、公募基金、私募基金等等业务。\n招聘这块的话，上海东方财富主要招聘 Java 后端、测试、.Net、C++、前端等岗位。\n面试这块的话，加上笔试一般技术面试有两轮。第一轮笔试通常会有上级测试，上机的编程题难度一般。第二轮技术面试会根据你的项目经历来针对性提问。\n浦发银行 招聘这块的话，上海浦发银行主要招聘 Java 后端、前端、算法等岗位。\n面试这块的话，总体难度比较简单，通过率非常高！\n招商银行 招聘这块的话，上海招商银行主要招聘 Java 后端、前端、算法等岗位。\n因为很多项目都外包出去了，所以，招的技术人员实际不多。\n面试这块的话，总体难度比较简单，通过率非常高！\n其他 除了上面介绍到的这些公司之外，上海还有汇添富、众安在线等和金融相关的公司。\n外企 如果想追求 Work and Life Balance 的话，下面这些外企会是非常适合你的选择。\nMicrosoft(微软) 国内的话，微软在北京、上海、苏州、深圳都有办公室，业务涉及 Office365、Azure、Bing、Cortana 等微软自家的产品。\n虽然薪资比不上国内的一线大厂，但是相对来说还是薪资和福利还是很不错的！性价比非常高！\n除了每天免费的水果饮料零食咖啡这种基本福利，公司还有自己健身房，平时还会组织很多活动。并且，上班是完全不需要打卡的，可以相对更自由的安排自己的工作时间。\n微软提供的硬件环境非常可以，一般入职的时候就有 Dell 双屏幕、 MacBook 或 Surface Book 等提高生产效率的工具。\n暑期实习生除了有导师指导做项目外，也有多姿多彩的业余活动比如 Hackathon 大赛可以参加。\n招聘这块的话， 上海微软主要招聘 Web 前端、全栈、算法、设计、C/C++、Java。\n总的来说，如果你想在国内找一份相对轻松、不加班的工作的话，微软会是一个非常好的选择。\nCisco(思科) 思科于 1994 年进入中国市场，目前在中国拥有员工超过 4000 人。\n思科最早在上海成立了一个研发中心，到现在，已经在上海、北京、杭州、苏州、合肥、深圳等地有办公室。\n招聘这块的话， 上海思科主要招聘测试、软件研发工程师、C++。\n面试这块的话，一般会有三轮。第一面和第二面的时候就是问一些计算机基础知识以及你面试的岗位需要的技术知识，可能会有英文能力的考察，比如让你使用英文介绍你的项目。第三面的话，就是聊聊自己的过往经历、兴趣爱好、职业规划这些东西。\nThougtWorks(思特沃克) 国内的话，ThougtWorks 在北京、上海、成都、武汉、西安、香港等地都有分部。\n据我一位朋友说，在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。\n招聘这块的话，上海 Thoughtworks 主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、.NET、C/C++。\n面试这块的话，一般会先给你一个作业让你做，时间是 3 天左右。一定要注意代码质量以及代码的可扩展性！作业通过之后，会进行下一步的面试。面试官通常会让你在作业的基础上做一些功能的增加或者修改，并且，还会问你一些和简历相关的技术性问题。\nThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。\nPayPal(贝宝) PayPal 这家公司大家应该也知道，主要做移动支付的，主要是海外市场。\n国内的话，PayPal 在上海、北京有办公室，主要做支付方向的业务。\nPayPal 提供的硬件环境也很不错，一般入职的时候就有 2 台 MBP、34 寸显示器等提高生产效率的工具。\n招聘这块的话，PayPal 主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、NodeJS、Python。\n面试这块的话，PayPal 通常是三轮技术面+主管面。第一面和第二面的时候主要问一些计算机基础知识以及你面试的岗位需要的技术知识，第三面的可能会让你做算法题。\n其他 除了上面介绍到的这些外企之外，上海还有 Intel（英特尔）、SAP（思爱普）、Amazon（亚马逊）、Booking 等不错的外企。\n生活 我们再来看看生活环境和生活成本。\n房价 上海的房价就不需要多说了，一个字：“贵”！\n一般人奋斗一辈子都买不起，如果你的收入比较高的话，还是有可能在上海拥有一套属于自己的房子。\n以下房价数据来源于安居客，可以作为参考。\n教育 上海的教育资源还是非常不错的！目前上海共有 10 所 211 大学（含 985），其中有 4 所 985 院校，分别是复旦大学、上海交通大学、同济大学、华东师范大学； 6 所 211 院校，分别是中国人民解放军海军军医大学、华东理工大学、东华大学、上海财经大学、上海大学、上海外国语大学。\n虽然上海的教育资源比不上北京，但是对比教育资源比较好的二线城市比如武汉和长沙还是有很大优势的。\n湖北省省会武汉有 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。湖南省省会长沙有 4 所 985/211 高校，分别是国防科大、中南大学、湖南大学、湖南师范大学。\n医疗 2020 年的一份报道显示：每千人口拥有医师数最多的三个地区为依次是北京（4.63 人）、浙江（3.33 人）和上海（2.95 人），已经可以与高福利的欧洲国家比肩。 不过，上海的每千人均医疗机构床位数排名中等，深圳垫底。\n另外，上海的三甲医院数量一共有 66 座，仅次于北京。\n交通 截至 2021 年，上海地铁已开通运营 19 条线路、是世界上客运规模第二大的城市地铁系统，仅次于北京地铁。\n郊区的话，地跌一般还没有覆盖到，可以乘坐公交。\n堵车情况的话总体还好，一般就是上下班高峰那会，核心路段可能会堵车。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/shanghai/","summary":"上海 大家中午好啊！我是大白。 程序员视角观城市系列已经更新有 6 期了，我们一起看了西安、长沙、天津、广州、青岛。除了广州之外，其余的都是二线城市","title":""},{"content":"苏州 大家好呀，我是大白，许多读者想让我写一下苏州，我们今天就来看下苏州的互联网环境。\n有句话叫做上有天堂，下有苏杭，不过有一说一，互联网环境方面苏州和杭州可是差了一大截。但是我个人还是很看好苏州的，而且从 18 年左右开始，苏州的互联网环境开始有了明显的改善。生活方面无论是苏州的地理位置，还是人文环境，都是十分适合居住生活的。\n老规矩，下面我们还是按照程序员的工作机会和生活环境来介绍苏州。\n因为苏州目前可供程序员选择的好的就业机会还是不像北上广深等地那么多，我就不把苏州的工作机会分互联网、国企、外企等介绍了。我把比较不错的工作机会直接混在一起详细介绍下，然后其它我知道的工作机会就在最后列一下了。\n工作机会 微软 微软可以说是程序员在苏州最好的工作机会了。微软近些年也一直扩大在苏州的投资力度，目前微软苏州研究院的研发团队已经有 2000 人左右了，并且还在近一步扩建。2022 年微软将启动微软苏州三期新大楼的建设，建成后预计微软在苏州的研发团队会达到5000人。所以，目前想拿微软苏州的 offer 的难度，相比于拿北京上海等其它几个工作地 offer 的难度会低一些，大家抓紧呀。\n许多人对微软的印象就是养生，但是我问了一些微软的职工后发现还是要看组，在微软天天干到 9 点多才能下班的组也是有的，不过大部分组养生起来是真养生，支持居家办公这种工作方式是真的爽。\n微软的薪资相对于国内的互联网大厂来说会低一些。苏州微软今年校招开出的 offer 是白菜价年薪 29 万左右（26万 base + 10%的年终奖），Special offer 年薪是 31万左右（28万 base + 10% 年终奖）。额外签字费加搬家费一次性发放 6 万元，4.5 万元的股票分 4 年发放。在校招薪水上也看到一个 2 年经验的老哥爆料自己拿到的苏州微软 61 级 offer 薪资，年薪 35 万左右（32万 base + 10%的年终奖），额外签字费加搬家费一次性发放 5 万元，8万美元的股票分4年发放，还有每年7200元的餐补，健身补贴每年 1800 元。\n我有点按捺不住想给苏州微软投简历了。微软校招面试对于手撕代码的考察是很严格的，如果想要去微软的一定要多刷代码题。如果你走社招进微软的话，不止是要刷好题，还要多准备系统设计的相关知识，这个也是可以针对性准备的，可以看我这篇文章\u0026ndash;大型系统设计方案，另外如果想准备面试常问八股文，也可以看这里-八股文合集\nZOOM 在苏州，Zoom是除微软外的另一个好选择。Zoom 曾经被评为全球最佳雇主。根据 zoom 员工的说法，zoom的技术水平大概和国内二三线厂的水平差不多。薪资方面，比国内互联网也要低一些，看到一个校招薪资的爆料，一个做前端的硕士在苏州zoom的薪资是17k * 14。额外有 7 万美元的股票，分 4 年发完。虽然 base 薪资方面相对低一些，但是 zoom 工作是真的爽呀，没有 996，没有 kpi，办公环境好，无限零食和水果供应，这还要啥自行车。\n华为 华为在苏州的研究院设立时间不长。华为的苏研院的加班在各地所有的研发中心中是排的上号的。华为各地研发中心的忙碌程度差不多是成都 》= 西安 》= 苏州 \u0026gt; 武汉 \u0026gt; 东莞 \u0026gt; 杭州 \u0026gt; 南京 \u0026gt; 深圳 \u0026gt; 北京 \u0026gt; 上海（整体感觉是这样，每个研发中心各部门的加班情况也不同）。不过华为有一个好处就是你挣的钱能和你的付出成正比，所以想快速挣钱的还是建议去。\n360 360 来苏州时间不长，2018年才逐渐开始在苏州设立开发部门。目前 360 苏州包含了未来安全研究、360政企、安全等部门。目前 360苏州的薪资水平是北京上海薪资水平的 8 折，看到 21 年毕业的一个应届硕士爆料月薪是 16k，工资有点少，不过感觉在苏州也不错呀。\nMomenta !\n一开始我对 Momenta 还真没什么了解，直到我有一天突然在校招薪水上搜了下 Momenta，然后我不由得直呼卧槽，这特么是给应届生的薪资？认真的？\n然后我详细的了解了下这家公司，这是一家做自动驾驶的公司，创立时间也不长，2016年创立的。不过据说这家公司加班特别猛，有的组 10 10 5，有的组 996，有的组比 996 还要累。Momenta 现在能给的起这么高的工资，实力还是有的，不过对于发展的前景来说，领域这么垂直的公司风险性是比较大的。\n企查查 跟上面的公司相比，企查查算是一个小而美的公司。企查查是苏州的本地企业，目前来说口碑还是很不错的。目前企查查的业务很赚钱，自己的大楼也差不多修好了。没有强制加班，全额社保和公积金。我没有查到企查查的校招薪资，看 boss 上的社招薪资水平不算太高，只能算还可以了。\n收钱吧 这个公司大家应该都听说过，每次你用支付宝或者微信给商家付钱时都能听到“收钱吧到账xx元”。收钱吧的技术不错，加班也比较少，收钱吧的风评不错。不过就是工资相对给的少点，月薪 17k 左右（在苏州也还行了），每年14 个月的月薪。\n中国移动苏州研究院 中国移动苏州研究院又叫苏小研，其实犹豫了很久要不要把他放在推荐里。苏小妍在知乎上的争议很大，有说待遇福利很好的，也有狂喷的。苏小研肯定有国企的通病，这个我确认，但具体怎么样就靠大家自己判断了，贴两张知乎上对苏小研的评价，好坏要大家自己去具体确认了。这两张图评价完全是两个极端呀。\n上面是我认为苏州的比较不错的程序员就业机会，其它的一些苏州比较成规模的提供程序员就业机会的公司就列在下面，并且快速的简单介绍一下。\n同程艺龙：之前算是苏州最大的互联网公司，但是目前员工对公司的吐槽比较多，详情可以在知乎和脉脉上搜下。\n京东工品汇：工品汇是之前苏州的企业，被京东收购了，据说目前算是京东比较边缘的业务部门。\n科大讯飞：科大讯飞在苏州是有岗位的，不过岗位很少。\n思必驰：和科大讯飞一样做语音的，不过现在网上对思必驰的负面评价孩挺多\n建信金科、中银金科：看名字就可以看出，这两公司属于银行的子公司，也可以说是外包。大家要把这些公司和银行的软件开发中心区分开来。其实银行的子公司给人的感觉有点尴尬，就是它们既没有互联网公司的高薪，也没有银行软件开发中心直属总行的稳定。当然这也就是相对于大互联网公司来说，如果手上没有一二线互联网公司的 offer，也可以考虑去的。\n锐捷：许多同学应该听说过锐捷，专门做校园网的，比较偏底层，对 Linux 内核感兴趣的可以看看呀。薪资相对较低，校招开出的薪资在13~15k 这个区间。\n金蝶：国内 ERP 巨头，在苏州貌似岗位不多。\n科沃斯：主要做智能硬件的，公司很强，市值都一千多亿了。也有很多编程的岗位。。\n生活 许多人想在苏州定居，也主要是觉得在苏州生活很惬意。下面还是分教育、房价、交通、娱乐等方面介绍下。\n教育 高等教育方面。其实就苏州本身而言，高校并不多，只有苏州大学一所 211（苏大的自然语言处理挺强的）。但是前些年许多地理位置偏北的高校为了打造自己在南方的影响力，提高生源质量，都会选择在南方办学。其中一部分选择了深圳，另一部分选择了苏州。西交大、中科大、中国人民大学、东南大学、西工大等院校都在苏州设有校区。所以虽然苏州本地院校不多，但是苏州计算机软件相关的高校毕业生并不少。不过这种现象随着西工大太仓校区刚修好，异地办学就被叫停了，我瓜实惨~\n中小学教育方面，苏州的教育质量肯定是不错的，不过江苏的高考压力可不小。有些人定居苏州也会担心下一代的高考问题。\n房价 相比于苏州的工资水平，其实苏州的房价也不低了，看网站上的新房均价大约两万五一平。但是和旁边的城市一比，那苏州的房价就比较香了。在苏州咬咬牙还是能考虑买房的。\n娱乐\u0026amp;交通\u0026amp;美食 娱乐方面苏州好玩的地方很多，传统的苏州园林风格和苏州现代风格都让人十分留恋。周末在苏州园林逛一逛真的很惬意。\n交通方面堵车是肯定会堵的，还没见过哪个二线以上城市不堵车的。但是苏州的交通相比于其它同量级的城市还是要好很多。另外苏州地理位置上靠近上海南京，出去玩也很方便。\n美食方面，苏帮菜貌似在全国并不多见，口味偏甜。这就不知道大多数北方人能不能吃得惯了~\n好了，就介绍这么多，我感觉我还真有点想给苏州微软投简历去工作生活一段时间~\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/suzhou/","summary":"苏州 大家好呀，我是大白，许多读者想让我写一下苏州，我们今天就来看下苏州的互联网环境。 有句话叫做上有天堂，下有苏杭，不过有一说一，互联网环境方","title":""},{"content":"天津 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越来越全面了，但相同公司不同部门不同组的情况也差别很大，这里只能介绍一个总体情况，如果大家有更多的信息，欢迎联系我补充呀。\n白师傅，你嘛时候成为津门第一呀？不是不是，你嘛时候介绍天津呀？来了来了，天津是肯定要安排的。我和天津的故事起源于上大四的时候，学院直接把我们打包到外面的培训机构培训（学校把我们的学费给培训班一部分让他们培训我们，解决我们就业），当时有天津、北京、苏州、上海等地我们可以选择（话说我的经历还真的是丰富 ~ 自学过编程，也在学校安排的培训机构培训过！考过研也找过工作！搞过开发也做过算法！）。因为我当时想着准备考研（我们专业的考研党和天津的培训机构商量好先让我们准备考研，等我们考完研再给我们培训），有点不习惯南方的气候，北京又物价太贵，就选择去天津培训。当我第一次坐着飞机在傍晚时分的天津上空盘旋，感觉天津的夜景真的是太美了。\n好了，情感从天津这么美的夜景中收回来，收！天津的互联网环境是真的不怎么好，当准备下笔时我竟想不出一个在天津设点的互联网大厂。我在天津时曾经问在天津的朋友，为嘛天津的互联网环境介么差呢？朋友说因为这些大厂都在北京已经设点了，离这么近再设点不划算。当时我觉得挺有道理，但是我过了一会又问朋友，那为嘛杭州苏州离上海那么近互联网产业还发展那么好呢？朋友叹了口气没有说话~\n不过在天津的话眼光就不要仅局限于互联网了。感觉去一些国企和研究所也可以呀。下面的数据仅代表我的调查结果，如果大家有要补充的直接在评论区留言呀。\n读者补充：天津有个补充公积金挺吸引人的，有的单位的补充公积金能到工资的一半，有意去天津生活的大家可以详细去了解一下呀。\n互联网 我在写天津的互联网公司的时候的经历是这样的，首先我想到了我的一个同学，我记得他在天津的神州优车做的还不错，于是我给他打通了电话。喂，老哥，最近在神州优车干的怎么样？啊？天津神州优车没了？你现在在哪呢？哦，在家呢，行，改天出来一块吃饭哈，我先写文章了。于是我又想到一个曾经有印象的，华为海洋应该还行吧，我去查查。嗯？卖了？这\u0026hellip;再看看别的，这家是个外企，应该不错，我去了解了解去，这咋最近还大幅裁员呢？这都啥嘛\u0026hellip;我不写了。\n我把现在还存在的互联网公司列在这，大家想了解自己去了解吧。话说现在天津的互联网公司是真的没几个像样的。\n紫光云、捷信、科大讯飞、云账户、卓郎科技、联想云、浪潮云、中交智运。\n大家如果知道有不错的互联网公司，快点告诉我呀。\n国有控股 中兴\n中兴天津在空港经济区，那边去了你就知道了，是真的人少，不过环境倒是不错，离机场也很近。硕士能给到每月 17k。感觉还可以吧。\n麒麟软件\n本科每月 10 k，硕士我查是 15 k，不过我问一个老哥，看他的表情好像不一定能到？年终奖 1-3 个月的工资，加班狠。不过还好有人才公寓包住。\n南大通用\n南大通用在天津算是不错的公司了，做国产数据库的。不过听说公司情况有点复杂。\n中科曙光\n在天津来说还是不错的，中科曙光的实力还是有的，不过加班严重。去年校招硕士给的价钱是月薪 13k 左右。\n联想\n刚在天津设立部门，最近招聘量很大。因为刚成立，所以目前的待遇情况和加班情况都未知，但感觉在天津的话去联想是不错的选择呀，大家如果想去赶紧投简历呀。\n银行软件开发中心 感觉程序员在天津工作的话，银行的软件开发中心是不错的选择了。工资水平不错，工作稳定，而且加班还比较少。\n农行软开\n农行软开天津基本是程序员在天津工作的最好的几个选择之一了。属于总行编制，薪资水平和西安持平，转正以后每月到手 12 k，很香了。加不加班看部门，有的部门加班多，有的部门加班少，你在哪个部门应该是统一分配，看运气喽。\n渤海银行\n感觉渤海银行特别香，给应届硕士的年薪总包 20 w，还有补充公积金。网上的评价比较好一些。\n渣打银行\n渣打银行是个国际银行，本科每月税前 12 k，硕士每月税前 14 k，年终奖是按年薪的 15% 发放。我调查过程中感觉这里的网上评价不太好。大家如果想去自己要详细了解下呀。\n另外感觉去四大行的天津分行也是一个不错的选择，不过薪资水平我就不太清楚了，大家有意向自己再去了解。\n研究所 天津的研究所是真不少，考虑在天津定居的话，去研究所感觉性价比还是相对高一些的。不过学历要求都是硕士起步呀。所以提升学历也是有必要的，可以让你选择面多一些。有想考计算机相关专业研究生的同学也可以来找我聊聊。\n中航工业602所\n602所是主要做直升机的，在景德镇和在天津都有。硕士年薪 15w 左右，另外有 3w 的安家费。博士 28w 左右，给 20w 的安家费。\n航天科技集团研究所\n天津有航天科技 518 所、8357 所、8358 所。具体待遇不太清楚。不过根据我的了解，航空航天类型的研究所目前是所有研究所中效益最好的了，福利待遇应该相对于其它类型的研究所会好些。不过这些年中国航空航天方面的研究所加班也越来越多了，几个在航空航天研究所的朋友都挺累的。\n国家超级计算天津中心\n应届硕士应该是一年到手 10-12w，嗯，这样算那税前年包差不多就是 15w 嘛，看来天津这几家研究所的价钱都差不多呀。新职工有宿舍。\n中国电子科技集团\n中电 18 所、46 所、53 所都在天津，硕士的起薪差不多是 15w 左右。\n中国船舶集团\n中船舶 707 所，718 所在天津都有。薪资水平只能大家自己去打听了，研究所的薪资水平都不是太透明，我是没打听到。\n生活 房价\n话说天津的房价和天津的工资水平是真的不匹配，地段好一点的区新房均价基本都 3 万以上了，咱们来看下天津的各区房价统计。按照在天津的工资水平想在比较好的几个区买房是真的不容易。\n教育\n天津的教育还是不错的。大学有天大和南开两所 985 实力强劲，211 院校只有一个，就是河北工业大学（河北人民有点惨）。像天津理工大学、天津科技大学、天津师范大学、中国民航大学等也不错。天津的高中也非常不错，天津的耀华中学、南开中学、天津一中、实验一中、静海一中等都非常好。天津的高考也相对容易，孩子们的竞争压力相对小一点。感觉这是天津比较吸引人的地方。\n读者补充：天津医科大学也是211。\n医疗\n天津的医疗水平也是排在全国前列的，天津的肿瘤医院、血液病医院在全国来看也能排到前三。环湖医院、泰达心脑血管医院等部分科室水平也处于全国前列。天津的医疗条件完全能够满足本地的需求了，基本上看病不用出津。\n交通\u0026amp;气候\u0026amp;娱乐\u0026amp;美食\n天津的交通最值得称道的地方就是他半个小时到北京的高铁了，车次基本平均每 5 分钟就有一趟，所以好多人在北京上班在天津住 ~ 感觉天津的房价就是这样起来的\u0026hellip; 最近一段时间天津修地铁修的很猛，一直在传来新线路开通的消息。堵车嘛，目前还没哪个二线城市不堵车的，我知道的也就太原堵车相对没那么严重。\n天津因为沿海，夏天比较潮湿，到了冬天风非常的大，我在天津的那年冬天还把我脸吹伤了。春天的气候比较舒服。\n天津的夜景一直是我非常喜欢的，周末的晚上在五大道、滨江道吃个饭，沿着海河两岸转一转，或者去民园跑跑步都是十分惬意的。\n美食方面的话我感觉天津人是真的不怎么吃狗不理包子 ~ 天津到处是卖煎饼果子，还有麻花的。\n以上就是介绍天津的全部内容了，爱之深责之切，我是真的希望天津的互联网环境能再发展的好一点，让程序员有更多的工作机会。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/tianjin/","summary":"天津 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越","title":""},{"content":"武汉 国内一二线大厂 字节跳动  基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。字节跳动 2018 年来到武汉，近几年的招聘规模非常大，研发人员的数目也越来越多！ 业务方向 ：效率工程（Efficiency Engineering）、飞书、aPaaS（对标业内顶级 PaaS 和 SaaS 平台产品）、抖音电商。 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况：六险一金(12%)、包三餐、免费下午茶+零食、免费健身房、Top 薪酬、住房补贴 招聘情况：主要招聘后端（Java、Go）、前端、测试等岗位。 面试 ： 面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。  华为  基本情况 ：华为不属于传统意义上的互联网公司，不过算得上是大厂。华为在武汉有一个研究所，规模还是挺大的！ 业务方向 ：传接、光产品、消费者（平板、笔记本电脑、音箱等）。 工作地点 ：武汉未来科技城，目前已自建办公园区基地。 福利情况：员工股权激励、薪资非常有竞争力。华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。 招聘情况：主要招聘软件开发（Java、C++）、嵌入式开发、测试等岗位。 面试 ： 面试的话，难度一般，主要看学历。 补充 : 华为加班比较多，压力可能会比较大。不过，薪资收入在武汉绝对是 Top 级别。  腾讯  基本情况 ：腾讯目前在武汉有腾讯武汉研发中心和腾讯云计算（武汉）有限责任公司，前者是分部后者是全资子公司。 业务方向 ：腾讯云主要负责腾讯云后台开发维护及智慧产业相关产品的研发，旗下有腾讯会议、智慧校园、数字政府等产品。 福利情况：全额公积金 （12%）+饭补+带薪年假 招聘情况：主要招聘前端开发、后台开发、数据库工程、云储存技术专家、云原生架构师等岗位。 面试 ： 面试的话，难度较大。校招的话，一般会先让你做一个笔试。笔试考察的内容比较全面，既有计算机基础又有编程题。实习的话，一般是先进行一波电话面试，主要问你一些比较编程基础相关的问题。 补充 : 全资子公司和腾讯本部还是不一样的，加入之前请慎重考虑。不过，即使是全资子公司的待遇在武汉也是属于非常不错的了。  小米  基本情况 ：雷总是武大的毕业，把小米总部也设立在了武汉。小米在武汉的发展还挺迅速，目前，小米在武汉员工已经超过 2000 人。小米在北京、深圳、上海、武汉、南京都有办公室。 业务方向 ：新零售、国际化、人工智能、互联网金融 工作地点 ：武汉东湖高新九峰一路小米武汉研发中心（自建） 福利情况：待遇不错，公积金 12%全额缴纳。 招聘情况：主要招聘 Java、Go、前端、服务端、测试等岗位。 面试 ： 面试的话，难上中等偏上。过程一般是：网申 → 简历初筛 → 测评 → 笔试 → 简历复筛 → 面试 →offer。 补充 : 小米在武汉确实是一个非常不错的选择！  金山软件   基本情况 ：金山软件（以下简称金山）是国内最早的互联网软件企业之一，2017 年来到武汉，未来将武汉作为重要的研发基地和人才培养基地。\n  业务方向 ：涉及金山办公（WPS Office）、西山居（美术中心为主，也有游戏研发）、金山云（云服商）3 条业务线。\n  工作地点 ：光谷 APP 广场\n  福利情况：待遇不错，公积金 12%全额缴纳。\n  招聘情况：主要招聘前端开发、后端开发、移动开发、算法等岗位。\n  面试 ：面试难度中等偏上，面试前记得好好吃透简历上写的技能。\n  补充 : 部分项目组可能会存在加班情况。\n  有赞  基本情况 ：有赞是 2021 年才来武汉成立研发中心。 业务方向 ：SaaS 服务（帮助商家网上开店、社交营销\u0026hellip;\u0026hellip;）、PaaS 云服务。 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况：全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘后端、前端、移动开发等岗位。 面试 ：面试难度中等偏上。一般由 3 轮面试，前 2 面是技术面，最后 1 面是 HR 面。 补充 : 公司技术不错！  神策数据  基本情况 ：神策数据是国内专业的大数据分析和营销科技服务提供商，为企业提供神策营销云、神策分析云、神策数据根基平台三大产品方案。公司总部在北京，2019 年 4 月 ，神策武汉研发中心正式成立。 业务方向 ：互联网、品牌零售、金融、融合媒体、企业服务、高科技、汽车、互联网+ 工作地点 ：洪山区关山大道光谷新发展国际中心 福利情况：七险一金、定期体检、带薪年假、不限量零食、下午茶、节日礼品、生日礼物、团建等 招聘情况：主要招聘后端、前端、机器学习、大数据。 面试 ：面试难度中等偏上。一般由 4 轮面试，前 3 面是技术面，最后 1 面是 HR 面。 补充 : 公司发展比较快，技术氛围不错。  其他 除了上面介绍到的这些一二线大厂之外，武汉还有下面这些不错的公司：\n 木仓科技 ： 专注于汽车生态的一家公司，驾考宝典和买车宝典就是他们的产品之一。成立于北京，目前在北京/武汉/上海/广州拥有办公地点，近 500 名员工。 青云 ：云计算服务提供商。成立于北京，目前在北京/武汉/成都拥有办公地点。 科大讯飞 ：智能语音及语言技术、人工智能技术研究和软、硬件产品应用开发。 京东武汉京喜事业部 ：京东 2021 年成立了京喜事业群，京喜通事业部就是其中一员。 旷视科技 ：人工智能产品和解决方案，Face++云平台就是他们家的产品。 多益网络 ：游戏相关，神武系列、梦想世界就是他们家的游戏。 \u0026hellip;\u0026hellip;  国企 远光软件  基本情况 ：2011 年远光武汉研发中心成立，2015 年创建全资子公司远光软件（武汉）有限公司。 业务方向 ：集团管理、智慧能源、智能物联、社会互联。 工作地点 ：东湖高新技术开发区光谷大道 77 号光谷金融港 B3 栋 。 福利情况：有通勤车和食堂，整体待遇不错。 招聘情况：主要招聘 Java、Go、前端、人工智能、测试等岗位。 面试 ：面试难度一般，基础考得多。 补充 : 部分项目组可能会存在加班情况。  烽火通信科技  基本情况 ：烽火通信成立于 1999 年，前身是通讯业内闻明显著的武汉邮电科学研究院，1976 年成功制作出国内第一根光纤。不过，目前的发展情况不行，前景堪忧。 业务方向 ：通信系统设备、光纤及线缆、数据网络产品。 工作地点 ：东湖开发区高新四路 6 号 福利情况：待遇一般，五险一金，免费班车，餐补。 招聘情况：主要招聘 Java、.Net、人工智能、算法等岗位。 面试 ：面试难度一般。 补充 : 武汉本土国企，不过，据说内部的情况比较坑，不太适于追求技术发展的朋友。  金融相关 众邦银行  基本情况 ：专注于服务个人小微的互联网交易银行。 业务方向 ：互联网金融 工作地点 ：汉口北国际商品交易中心 D2 区 福利情况： 六险二金、节假日福利、带薪年假、生日福利 招聘情况：主要招聘大数据、前端、后端、运维、测试等岗位。 面试 ：面试难度一般，面试氛围一般。  微众银行  基本情况 ：科技驱动的国内首家民营银行、互联网银行。 业务方向 ：微众银行武汉研发中心主要负责承担微众各类业务系统设计、开发、运维等工作，与相关科技部门充分协作，为业务提供高质量且成本可控的系统功能交付，以支持银行业务整体可持续发展。 工作地点 ：中建·光谷之星科技产业园 福利情况： 年底双薪，年终奖，节日京东卡，日常团建、公司旅游，生日 party，下午茶，12%的公积金，员工险，年度体检，周末双休.etc 招聘情况：主要招聘前端、后端、运维、测试等岗位。 面试 ：面试难度中等。一般由 4 轮面试，第 1 面是技术面，2，3 面试领导面，最后 1 面是 HR 面。  长江证券  基本情况 ：武汉本土，总部就设在武汉、业务网络覆盖全国的一家综合类上市证券公司。 业务方向 ：互联网金融 工作地点 ：新华路特 8 号长江证券大厦 福利情况： 五险一金，餐补，交通补贴，通讯补贴 招聘情况：主要招聘 Java、前端、运维、算法等岗位。 面试 ：面试难度中等，问的问题比较细，框架，项目经历等等。  其他 除了上面介绍到的这些银行之外，武汉还有农业银行武汉研发中心、建设银行武汉研发中心、浦发银行武汉研发中心等不错的银行研发中心可供选择。\n证券类公司，除了长江证券，还有中信证券、国泰君安证券等证券公司。不过，这些公司大多不招聘技术人员。\n本地互联网公司 斗鱼  基本情况 ：斗鱼是武汉比较大的一家本土互联网公司，直播行业的龙头，武汉市第一家“独角兽”级互联网创业公司。目前的话，虎牙和斗鱼已经合并。2019 年 7 月 17 日，斗鱼在美国纳斯达克交易所上市，成为湖北首家海外上市的本土互联网公司。斗鱼的办公环境不错，据说伙食也还可以，最重要的是你还有机会见到一些知名主播。 业务方向 ：直播 工作地点 ：洪山区光谷软件园 福利情况： 全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘 Java、前端、运维、算法等岗位。 面试 ：难度中等偏上。校招一般主要问计算机基础，会附带问一些你要面试的岗位所涉及到的技术问题以及根据你的项目经历来提问。社招主要就是针对你的项目经历来提问。  微派网络  基本情况 ：武汉微派网络科技有限公司（WePie Team）成立于 2013 年 8 月，主要致力于移动互联网休闲游戏和社交产品的研发和运营，旗下产品有贪吃蛇大作战、会玩、微派桌游助手、青藤之恋。 业务方向 ：泛娱乐 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况： 武汉 TOP 薪酬+丰厚绩效年终奖（普遍 15 薪+）+节日福利+租房优惠 招聘情况：主要招聘 Go 开发工程师、测试、运维和移动端开发等岗位。 面试 ：难度中等，通常会有两轮技术面试。  盛天网络  基本情况 ：盛天网络早期是靠网吧系统发家的，易乐游就是它家的网吧管理系统，目前已经上市！ 业务方向 ： 工作地点 ：武汉东湖高新技术区光谷金融港 B7 栋 福利情况： 全额公积金，住房补贴，团建活动 招聘情况：主要招聘 Java 后台开发和运维等岗位。 面试 ：难度中等，通常会先让你做一个笔试，技术面比较重视基础。  其他 除了上面介绍到的这些武汉本地互联网公司之外，武汉还有下面这些不错的本地互联网公司：\n 石墨文档 ： 核心产品就是石墨文档。 常相伴 ：互动娱乐和社交产品，伴伴实时场景社交就是他们家的产品。 \u0026hellip;\u0026hellip;  外企 武汉这边的外企好像就只有一个 ThougtWorks。\nThougtWorks(思特沃克)  基本情况 ：国内的话，ThougtWorks 在北京、上海、成都、武汉、西安、香港等地都有分部。武汉是 ThougtWorks 在国内的研发总部。据我一位朋友说，在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。 业务方向 ：咨询服务、软件外包 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况： 全额公积金，住房补贴，团建活动 招聘情况：主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、.NET、C/C++。 面试 ：一般会先给你一个作业让你做，时间是 3 天左右。一定要注意代码质量以及代码的可扩展性！作业通过之后，会进行下一步的面试。面试官通常会让你在作业的基础上做一些功能的增加或者修改，并且，还会问你一些和简历相关的技术性问题。 补充 ：ThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。  生活 我们再来看看生活环境和生活成本。\n房价 武汉的房价相对全国来说还是比较有性价比的，泡沫相对也小一些。\n不过，武汉的工资收入相对一线城市来说也要低很多。\n以下房价数据来源于安居客，可以作为参考。\n教育 武汉的教育资源那是相当可以！不然，大学生也不会全球数量第一。\n作为湖北省省会，武汉有 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。\n去武汉大学看看樱花是多少情侣的愿望啊！\n医疗 武汉的医疗资源还是非常不错的！\n根据《2018 年武汉市卫生健康事业发展简报》，截至当年末，武汉市有三级医院 61 个，其中三级甲等医院 27 个。\n交通 武汉的交通还是非常便利的，地铁线路非常多！\n不过，武汉人也多，路上的车也多，上下班堵车是常有的事。\n武汉算的上是“交通枢纽”的存在，你从武汉出发坐高铁，你去国内大部分地方都非常方便。\n美食 武汉的包容性比较强，你想吃的在这边基本都能找到，种类非常多。\n早饭可以一个月不重样，各种火锅烤肉、川菜粤菜什么的随处可见。\n生活 本地人不排外，还算比较热情。\n武汉这边天气状况不好的原因？感觉武汉人脾气差，容易发火，尤其是汉口那边的本土居民。\n光谷这边其实还好，因为光谷这边还是年轻人巨多，很多都是在这边工作的大学生。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/wuhan/","summary":"武汉 国内一二线大厂 字节跳动 基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。字节跳动 2018 年来到武汉，近几年的招聘规模非常","title":""},{"content":"西安 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我把我最近收集到的信息以及读者的补充添加到了文章中。\n另外我想说明下的是，虽然我这些数据都是经过实际调查，并且有很多在下面公司上班的读者补充，已经尽可能的接近客观。但依然只能反应一个公司的总体情况，同一公司的不同部门，不同组可能也会有较大的差距。\n最近越来越多的人关注到西安这座城市。作为一个刚在西安完成三年研究生学业的打工人，我就在这篇文章中替大家以程序员的视角看一看西安。我会从程序员在西安的工作机会、在西安的生活环境以及生活成本两个角度进行分析，给大家讲述一个程序员在西安生活的利弊。\n工作机会 其实西安在前些年，还被称为互联网荒漠，程序员生存的空间很小。\n在 18 年我刚到西安上研究生的时候，我们专业的学长学姐想留在西安，可选择的也只有华为、中兴以及几个研究所。但也正好是我读研的这几年，不断的有大企业在西安设点，并且将研发部门搬到西安。目前西安的互联网环境已经初具规模，对于计算机相关专业的学生，毕业留在西安也是一个不错的选择。同时这些年西安的互联网环境也在持续向好，不断有大公司在西安设立研发中心。\n同时，西安的互联网环境还处在一个开拓期，几乎所有的大企业都在西安设立研发中心不久，所以除了有限的几个公司和部门比较轻松外，其它加班都比较严重，并且有限的几个公司和部门的情况也在变化中。\n下面就分私企、国企、银行软件开发中心、研究所几大类来介绍西安招计算机相关专业的公司。各个公司的信息是根据我的了解以及和留在西安各个公司的同学打听所收集的，并且收集了部分网上信息。由于社招薪资水平根据每个人的情况相差较大，所以在介绍的时候比较多的提到的是校招的薪资，大家可以参考西安和其它城市的校招薪资来评估西安社招的薪资水平。\n互联网 华为\n如果想在西安快速挣钱的话，华为几乎是最好的选择了，按照华为的工资水平在西安买房根本没有压力。华为在西安的建制很齐全，消费者、CloudBu、云核心等事业群以及华为海思，2012 实验室都有。但是因为去年美国对华为的打压，消费者、华为海思以及 2012 实验室这些之前很香的事业群目前日子都不太好过。\n西安华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。华为在西安的校招薪资水平还是很高的，几乎和北京持平了。\n华为在西安的社招我不是特别清楚，只是知道华为社招大部分给的是 OD ，社招想拿正式 offer 基本都需要 16 级以上的评级。\n在华为上班是压力比较大，也比较累的。据我了解，西安华为的 CloudBu 这个事业群下的部门还相对轻松。这个事业部下的部门基本上半年轻松半年忙。在项目不忙的时候，一般工作的节奏是早上 9 点，周二和周四常态化加班到晚 9 点，周一三五 6 点 以后就可以走。每个月的最后一个周，周六要常态化加班。华为产品线的部门是相当忙的，加班到几点就说不好了。不过华为的加班费是给的相当到位的，不会让你白加班的。另外外界对华为员工的技术认可度是比较高的，从华为跳出来去西安的任何一家技术公司都没太大压力。\n读者补充：华为现在除非是应届生，否则基本是OD（Outsourcing Dispacth，也是一种外包，和FESCO签合同，但直系领导都是华为的人，而不是在乙方公司的团队里给甲方华为干活），不能拿股票。如果你想赚钱，可以放弃一切顶住压力，去华为还不错，但也要注意部门，无线网，核心网，还有现在的车联网还不错，但是不建议考虑现在的终端了。\n阿里巴巴\n阿里巴巴还没大范围的在西安招人，情况目前还不太清楚。我问过阿里巴巴的员工，只知道目前在西安设点的部门是阿里云，需要半年在杭州上班，半年在西安上班，工资水平和杭州一致。不过目前招的量比较小，基本都是招高p，主要是做售前的业务架构设计，只有很少的校招名额。\n京东\n京东把京东物流的团队设在了西安航天城，目测团队规模在几百人，工资水平大约是京东在北京工资的 80%。大家可以参考一下，京东去年在北京的部门，校招普通 offer 是年包 28 万，sp 是年包 32.9 万。\n一位在西安京东的读者补充：上班早9点晚7点，周六没有培训不用来。\n腾讯云\n腾讯云是腾讯的全资子公司，目前对这里褒贬不一。校招薪资水平本科和硕士生大概是月薪 13-16k，每年 16 薪，大家可以参考一下，腾讯 21 届校招的薪资是 17-21.5k ，每年 18 薪。社招我看一个本科毕业四年经验的老哥拿到的年包是 33 万。腾讯云的职级和腾讯不是对齐的，并且业务比较边缘，这也是网上被喷的一个主要原因。目前西安腾讯云创立时间不久，加班强度是比较大的。\n字节跳动、小米、ViVO、OPPO\n小米已经确定在西安设立研发中心了，但具体是哪些部门还不太清楚。字节跳动之前在西安的部门是审核相关的岗位，目前也有较为确定的消息会在西安设立研发中心，大家感兴趣的话持续关注。今年vivo在线高新环普也设立研发部门了，听说待遇不错。OPPO在西安也是刚设立研发部门不久，招人比较疯狂，听说加班也很疯狂。\n广联达\n广联达西安的部门在针对 21 届毕业生的校招中开出的薪资是很有诚意的。给应届硕士的 sp 是 19k x 15，普通 offer 是 17k x 15，本科生每月基本都在 13-17k 之间。广联达工作制度基本是 965 或者 975，每个月还有一天的带薪病假。这还要啥自行车？不过广联达曾经也有过黑料，大家自行上网了解。\n浙江大华、海康威视\n海康威视其实是国企，但是海康威视和大华工作强度和待遇方面特别一致，就放一块说了。大华和海康威视在西安都有设立研发基地的，并且招人很多。这哥俩目前在网上被喷的比较狠，据说工作强度很大，但工资水平又很低，并且涨薪缓慢。大家如果想去进一步了解可以去找这两个厂子的员工哈。\n360\n360 在西安只有一个几十人的团队。没听说过这里有校招，社招的话 3 年以上经验的差不多能每月给到 20k 。有说在这里待的舒服的，也有喷的。\n奇安信\n奇安信在校招的工资和中兴差不多，年薪 20 万 左右，工作制度是 1085。在西安招的人还是挺多的。\n科大讯飞\n科大讯飞西安丝路总部主要是算法岗，不过我看网上喷的比较多。据说是活多钱少。\n大疆\n在西安的岗位只有相机嵌入式和测试岗位，工资比华为还要略高。\nOPPO\n21 年年初刚在西安成立，最近疯狂招人。加班严重。\n绿盟\n绿盟算是中型企业里比较香的，绿盟在安全领域还是比较强的。工资比较低，硕士校招才能给到 14k x 14，但是这家公司几乎不加班，员工的离职率也一直很低，我同学有违约中兴三方去绿盟的。\n读者补充：最近在绿盟科技实习测试，深切体会到养老型公司。不加班。\n当当网\n早 9 晚 8 点半，周末双休。组内氛围还不错\n交叉信息核心技术研究院\n主要做人工智能。背景很强大。大佬姚期智带队，有 30 位清华交叉信息研究院的教授参与运营。招人的要求很高。\n寒武纪\n寒武纪是做智能芯片的公司，背后站着中科院计算所。2019 年落户的西咸新区，相关信息比较少。我知道的是加班比较多，不过薪资也高。\n其他\n其它的中型私企我就不一个个点评了，我把在西安设立研发部门的公司名字列在这里，大家感兴趣自己去了解。\n诺瓦科技（西电的老师开的）、优信二手车、美林数据、交大捷普、交大长天、西电捷通、葡萄城、全时云、神策数据。\n国企 感觉西安几家国企的性价比略低，工资不高，且大部分加班严重。校招应届硕士工资税前年薪基本都在 15w-20w 之间，本科生的年薪比硕士少 3w 左右。国企相较于私企涨薪会慢很多，不过相对稳定一些。\n中兴\n中兴校招的蓝剑计划还是给的挺多的，去年蓝剑计划给出的薪资包是 40 万以上，不过名额很少，一个大部门就一两个名额。除蓝剑计划外，其它等级的 offer 月薪在 10-15k 之间，每年 14 薪或 15 薪。\n移动\n移动西安研究院和移动雄安研究院都在西安，对，你没听错，雄安研究院也在西安设点了。硕士总包大约 16-19 万，移动的工资一部分会在年底按年终奖的形式发，平常每月发的工资比较少。\n联通\n西安联通软件研究院，应届硕士的总包和移动差不多，大约 16-19 万。不过联通比较清闲，大部分部门都能下午六点就下班。目前在网上的评价相对好一些。\n大唐\n大唐的加班挺严重的，周内需要有三天加班到九点。周末需要加够 8 个小时的班。\n烽火星空\n当时来学校校招时，说工资会在 10-20k 之间，根据面试表现进行工资评定。最近在听说加班比较严重。\n太极集团\n最初 12306 主要就是太极开发的 ，刚搬来西安不久，硕士工资水平是到手 7-8k 每月，每年 13 薪。工作稳定。出差多，加上出差补助的话每个月收入还可以。\n荣耀\n荣耀目前的招人需求是很大的，工作强度未知，薪资水平目前是完全对标华为的。\n南瑞\n南瑞是国家电网的技术型研究院，目前的项目也基本都是围绕电力行业的。南瑞的校招工资会在基础上根据学历来价钱。西安的校招工资年薪也在 15-20w 这个范围内。大部分部门出差比较多。\n润联科技\n工作稳定、薪资还可以。不过润联科技深圳那边相对好一点。\n银行软件开发中心 除了银行软件开发中心，各省分行的科技部门大家也可以去考虑，这里就不展开介绍了。银行的软件开发中心待遇水平是不错的，且基本都属于总行编制，生活稳定。目前对于准备留在西安的同学来说，去银行的软件开发中心是一个不错的选择。但近年来有一股银行软件开发中心子公司化的浪潮，今后的稳定性未知。\n农行软开\n农行软开目前是在西安工作的最好的几个选择之一，硕士每月到手 12k，本科生少几百块钱，年终奖 2-4 个月。大部分部门都能晚上 7 点以前下班，并且周末双休。目前农行软开有子公司化软件开发中心的计划，听消息说可以选择去子公司，也可以留在软开。目前西安的农行软开也越来越卷，大部分的 offer 都给了西电、西交、西工大这三个学校了，另外这三个学校的学生现在也不是想去农行就能去了。农行软开有个硬性规定是必须通过六级才能报。\n工行软开\n西安的工行软开属于总行序列。本科生和硕士生进入工行后职级都是助理经理，年薪总包 20 万左右，本科生每月工资就比硕士生少几百块钱。工行软开每月发的工资会少一些，然后年终会一下发好几万的年终奖。本科生需要两年才能升经理一，硕士需要一年就可以升 经理一。升到 经理一 后表现好一年就可以升 经理二，不过从助理经理到经理二的薪资涨幅不大。从毕业到升职成为经理三（相当于组长）最快需要五年，经理三的年薪还是很可观的。\n读者补充：西安工行周一、周二、周四需要加班\n中行软开\n西安的中国银行软件开发中心给应届硕士的报价是年薪 13 万，大家可以参考一下。\n中行软开的技术面试一般问的技术问题比较少，都是最基本的问题，比较简单。\n浙商银行\n浙商银行在银行软开中给的工资算多的，西安硕士的年薪包是 25-28 万，本科生的年包是 19-23 万。也算一个还不错的选择了。\n浦发银行\n浦发银行在西安的软件开发中心被子公司化了。工资本科是（5-7k）*24，硕士是 7.5k *24。这个工资是什么意思呢，就是每个月给你 5-7k，然后年底再一下子给你发 12 个月的工资当成年终奖。\n邮政银行\n邮储银行软件开发中心在西安刚成立，还不太确定。目前宣传是年包 28 万以上，工作强度目测比较大。\n中信建投\n中信建投刚落在西安不久，今年已经开始校招了。中信建投目前在西安算是性价比最高的几个好去处之一，工资水平较高，每年发18个月的工资，而且大部分部门加班不怎么严重。中信建投YYDS。不过目前中信建投学历卡的比较严，要求硕士985，同时本科还要求211，偶尔会放宽松一点本科的条件。\n外企 一般情况下，外企的工作强度会更小一点，基本都是 955 和 965 的样子。\n三星\n大部分应届生都是（11-14)k *13.5k。965 工作制。几乎都是芯片、运维相关岗位。\n有读者补充：三星工作制度是855，16薪。可以参考。\nSAP\nSAP 是一家做企业软件的德企，技术十分强大。硕士年薪 20 万左右，本科生年薪 15 万左右。\n不过，我有一个同学去 SAP 面试之后回来说面试体验非常差。\n读者补充：西安现在的SAP是原来的SyBase西安分公司，由于后者整体被前者收购了，所以后者在西安的分公司自然而然的变成了前者的分公司，和北京SAP分公司，上海、成都的研究员的文化都不太一样。\nThougtworks\n在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。工资本硕都是 13k x 14。\nThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。\n其他\n听说汇丰和爱立信在西安也有软件开发中心，大家感兴趣可以自行去了解。\n读者补充：爱立信在西安的不是研发中心（其研发在上海、成都，北京也有但是小，硬件研发在南京），而是运维和交付中心。\n读者补充：汇丰在西安的不是汇丰总公司的软开，而是收购的的一家子公司，也是家银行的软开，但是待遇也不差，有在招开发和测试。\n研究所 西安航空航天类的研究所特别多，我知道的招计算机方面的研究所有航天 504 所、771 所，航空 631 所、618 所、603 所，中电 20 所、39 所，兵器工业 203 所、204 所、205 所。\n这些研究所中，待遇最好的是航天 504 所，但是招人的要求很高，目前校招进去的大部分是博士，双 985 硕士（就是本科和研究生都毕业于 985 高校）想进都很难。其次 618 所和兵器工业的研究所待遇还不错，这几个研究所招聘有一个隐形的要求就是双 985 硕士。其它所的性价比就比较差了。631 所曾经被誉为西北第一神所，但目前的效益也不行了，现在的待遇是年薪 10 万，第一年额外会给 5 万的安家费。\n外包 西安有的几家比较大的是中软国际、软通动力和文思海辉。中软国际和软通动力主要是在给华为做外包，工作强度几乎和华为基本一样。外包的性价比不太高哈。\n生活 陕西的资源基本都集中在西安，从人口上也能看出西安的资源有多集中。整个陕西三千多万人，在西安就有一千多万。并且这些年中央对西安的扶植力度越来越大。\n房价 西安的房价从 18 年到现在翻了一倍，但就目前的房价相较于其它同类型城市算是比较友好的。现在西安的房价最贵的在曲江、第二贵是高新区。其它地方的房价差不多一万六左右吧，不过今年的全运会过后可能会长一波。按照程序员的工资来说，在西安买房的问题不算很大，这也是程序员待在西安比较舒服的地方。对于程序员来说，租房的压力相对较小，我同学有在农行软开工作的，在附近租了一个一居室的开间四十平左右，一个月一千五，上班步行用不了十分钟。高新那边租房贵一些，你愿意合租的话压力也不大。\n西安住建前段时间出了二手房交易参考价格，我贴在下面大家可以参考下，不过这个价格感觉低于市场价了。我感觉这直接打了个八折~西安住建发布二手房交易参考价格的链接在这里 https://mp.weixin.qq.com/s/Gis7kIJklWygTseztydDaw\n教育资源 西安的教育资源很好。高中教育资源方面，西安的名校众多。西工大附中、西安铁一中、高新一中、交大附中、陕师大附中这些学校在全国都是很有名的，另外还有一批在陕西省很有名的高中也很不错。大学教育资源方面，整个陕西有三所 985，西工大和西安交大都在西安，西北农林科技大学就在离西安不远的杨凌。\n另外，还有像西安电子科技大学、西北大学、陕西师范大学、长安大学、第四军医大学这些不错的 211，还有像西安邮电、西安理工、西安科技大学、西安工业大学等等这些不错的双非院校。西安每年产出的人才的数量是很庞大的。这是很值得西安自豪的一点，但是这也造成了一个问题，西安就业十分的内卷。有一个现象是陕西人都愿意在西安，不愿意出来，计算去外面上学的陕西人毕业也大部分都回到了西安，另外在西安上过学的也大部分留在了西安。西安的几个效益比较好的研究所、银行软开的应聘难度比在北京的同级别单位都难很多。内卷不仅表现在计算机，计算机算好的，我了解到目前好多西安的小学老师都敢只要 211 以上毕业的硕士生。\n医疗资源 医疗资源方面西安也很给力，交大一附院、交大二附院、唐都医院、西京医院、红会医院都是放在全国都很强的，另外其他一批省内比较有名的医院也很不错。\n交通 西安的交通方面不敢恭维，堵车那是一绝，我的感觉是西安比北京都要堵。西安的地铁 21 年初新开了 3 条线路，目前共有 8 条线路才勉强够的上需求。每逢法定节假日，旅游的人都会把西安挤炸。说到旅游，近年来西安对游客的吸引力是越来越大，一方面西安在弘扬大唐文化，另一方面西安的美食也叫一个美滴很。\n另外，大唐不夜城这里的人是真的多，尤其是夏天，晚上的时候基本打不到车！\n气候 气候方面，西安从 5 月初开始就开启高温模式，一直延续到 10 月中旬。我第一次去西安时是 8 月份，坐着动车，每个从动车下来的人都会情不自禁的喊一声妈呀。西安的热不止是白天热，晚上也很热，每年七八月份不开空调是别想睡觉的。\n不过，西安的天气相比于武汉来说要好很多。我之前也去过武汉，又热有潮湿，天气还多变，真的顶不住！\n做个总结 综上所述，西安目前正处在高速上升的阶段，互联网行业相对北上广深杭还有一定的差距，相比与成都也还稍差一点。但是西安绝对是有潜力的，并且目前西安的房价还是比较友好的。大家如果能选择在西安发展，生活幸福感会比较高。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/xian/","summary":"西安 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我","title":""},{"content":"郑州 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。\n由于我本人对郑州不是很了解，于是我咨询了很多在郑州工作和上学的朋友之后才把郑州的给安排了！\n以下分享的仅仅代表我个人的调研结果，如有有误或者需要完善的地方，欢迎在评论区指出！\n首先我们来看工作机会！\n一位读者的评论我觉得特别的好，我贴到这里给大家看下：\n网名\u0026quot;咔嚓\u0026quot;：作为在郑州工作的前端，表示遇见好厂的话，生活节奏还是很爽的，房租不贵，直接住公司旁边，通勤5分钟，不加班的话，每天晚上6点下班，双休。确实郑州互联网不强，但是，我们也不应该忘了生活本该有的样子啊。\n工作机会 郑州的互联网资源还是比较匮乏的，究其原因，我觉得和教育资源的匮乏有非常大的关系。\n教育资源极度匮乏导致好的企业不来，好的企业不来又导致人才外流，恶性循环。\n数字郑州 这个是阿里和郑州的政府合作的，目前评价大家对数字郑州的评价很不错呀，薪资也挺给力的，大家可以看下 Boss 上数字郑州的招聘岗位以及薪资报价呀。\n中原银行 中原银行的工资比较高，在郑州生活的话去中原银行是很不错的选择，不过想进中原银行的话，不是校招想进去有点难。薪资水平可以看下 Boss 上的招聘薪资水平。\n浪潮 浪潮在郑州的研发中心法定节假日加班是有加班费的，但平时加班就没有加班费了，每月要求加够50个小时的班。薪资水平大家也可以参考下 Boss 上放出的招聘薪资水平。\n新华三 新华三大部分情况下能双休，周末加班也有加班费，不过涨薪很缓慢。在网上看到一个帖子，有人问 offer 选西安中兴还算郑州新华三，中兴和华三的职工都在互相劝退，说这是一个送命题。薪资水平大家还是参考下Boss上的招聘薪资水平吧。\nUU 跑腿 UU 跑腿主要提供同城送件服务，是郑州本土最大的互联网公司，隶属于郑州时空隧道信息技术有限公司，地址位于郑州市金水区。\nUU 跑腿的工作环境以及各种福利都还算不错！\n面试的话，总体体验还不错，技术面试一般问的还比较全面。拿 Java 后端开发来说，像 SQL 优化、分布式、缓存这些一般都会问到。\n薪资的话，看准网上的平均薪资是 10k 附近，其中后端开发的薪资在 14k 附近，前端开发的薪资在 10k 附近，软件测试的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n中原消费金融 河南中原消费金融股份有限公司是一家全国性非银行金融机构，地址位于郑州市郑东新区。\n中原消费金融的办公环境非常不错，薪资福利相对也还不错。\n整体面试体验不错，效率也非常高，像技术面试的话一般是三轮或者四轮。不过，中原消费金融比较看重学历，985/211 上岸的几率比较大。\n薪资的话，看准网上的平均薪资是 16k 附近，其中后端开发的薪资在 17k 附近，前端开发的薪资在 16k 附近，软件测试的薪资在 14k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入，应该到不了这么高)。\n注意：大家注意一个情况，中原消费的软件研发岗位大部分都搬迁到上海了，目前在郑州的大部分是行政岗位，只有少部分研发岗位。\n刀锋互娱 刀锋互娱是一家专注游戏服务市场的互联网公司，2019 年完成 A+轮融资，平台注册用户量突破千万。\n旗下比较出名的产品有租号玩、一派陪玩，都是和游戏领域相关的产品。相信比较喜欢玩游戏的小伙伴应该对这个两个产品有了解。\n整体面试不是很难，薪资相对来说也还可以。\n薪资的话，看准网上的平均薪资是 16k 附近，其中后端开发（C++）的薪资在 20k 附近，前端开发的薪资在 8.5k 附近，软件测试的薪资在 9.5k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n新开普 新开普也是郑州的一家本土互联网公司，成立于郑州高新技术产业开发区，主要做 NFC 近场移动支付、金融 IC 卡等业务。\n新开普是目前国内一卡通行业唯一一家上市公司，已经为全国千所高校，千万名大学生提供服务。\n技术面试的话，一般第一面是笔试，笔试之后会再问你一些相关的技术问题。\n薪资的话，看准网上的平均薪资是 7.6k 附近，其中后端开发（Java）的薪资在 9k 附近，前端开发的薪资在 9k 附近，软件测试的薪资在 5.5k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n中移在线 中国移动旗下的一家“互联网”公司，实际不像是“互联网”公司。\n对于技术开发来说，去中移在线一是对技术没有提升或者挑战，二是工资是真的低（看准网上的 Java 开发薪资在 8k 附近）。\n真心不太建议去，除非你没有其他更好的选择。\n我能想到唯一的优势可能是公司相对来说能提供给你的一个相对稳定的工作。\n爱云校 爱云校常见于 2014 年，主要做的是在校教育这块，致力于通过 AI 建一所云上的学校。\n单看公司所做的业务方向来说，发展相对来说还是不错的。不过，据说公司的管理真的是渣到了一定程度。\n另外，根据大部分面试求职者的反馈来看，这家公司的整体面试体验比较差。\n薪资的话，看准网上的平均薪资是 12k 附近，其中后端开发（Java）的薪资在 14k 附近，前端开发的薪资在 8k 附近，软件测试的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n妙优车 妙优车主要做的是汽车方面的业务，涵盖整车销售、汽车金融、汽车保险、汽车用品、汽车美容等方面。\n公司发展一般，网上也有一些黑历史(可以自己查一下)。\n不过，根据大部分面试求职者的反馈来看，这家公司的整体面试体验还是可以的。\n薪资这块的一般偏上，看准网上的平均薪资是 11k 附近，其中后端开发（Java）的薪资在 12k 附近，前端开发的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n腾河 腾讯是河南腾河网络科技有限公司的最大股东，第二大股东是河南日报。\n主要做的业务方向是河南城市生活第一网。\n工资比较低，另外，后端这块好像只招 PHP。\n真二网 不得不说，这个名字有点东西！\n真二网创立于 2014 年，也是郑州本土的一家互联网公司，主要做 C2C 模式的 0 中介费真实二手房交易平台。\n工资比较低，另外，后端这块好像只招 PHP。\n硕诺科技 硕诺科技创立于 2014 年，总部位于上海，主要做物流软件系统高端定制的软件开发。\n网上可以查到的消息比较少，感兴趣的小伙伴可以自己去查一下相关信息啊！\n另外，如果有小伙伴对这家公司比较了解，也可以在评论区说一下啊！\n科大讯飞 科大讯飞在郑州金水区有一个小分部，大部分招聘的都是和技术无关的岗位，不过也有一个 Java 开发岗。\n字节跳动 郑州也有字节跳动分部，不过都是和市场拓展与运营相关的岗位，像技术开发岗是没有的。\n类似的还有美团、华为、阿里巴巴等大厂，这些公司在郑州招聘的基本也都是非技术岗位。\n其他 其他还有像郑州点读电子科技有限公司（旗下产品有咿啦看书）、羲和网络（河南唯一一家游戏上市企业）、米宅（中国知名的楼市自媒体，新三板上市企业）等互联网公司，感兴趣的小伙伴可以自行查阅相关信息呀！\n读者补充：海康威视、APUS、云鸟、亚信科技、牧原食品、小鱼易联、神州信息、云智慧都在郑州招开发工程师。\n生活环境\u0026amp;生活成本 我们再来看看生活环境和生活成本。\n房价 郑州的房价对于其发展来说还是比较贵的。当然了，相比于一线城市肯定还是要便宜很多的！\n以下房价数据来源于安居客，可以作为参考。\n教育 郑州的教育资源极度匮乏！据统计郑州一共有 65 所高校，其中，本科 26 所，专科 39 所。\n不过，211 院校仅有一所——郑州大学。\n是的！作为偌大的河南省的省会，国家历史文化名城，也就只有一所 211！\n我们来对比一下湖北省省会武汉，武汉 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。\n再来对比一下湖南省省会长沙，长沙有 4 所 985/211 高校，分别是国防科大、中南大学、湖南大学、湖南师范大学。\n医疗 郑州的每万人床位数排名比较靠前。\n另外，郑州市的优质医疗资源，在金水区、中原区、管城区比较集中；\n本地居民 网上有很多“河南黑”，让很多人对河南的影响不好！\n实际情况可能并不是这样的！郑州本地居民不排外，绝大部分都特别老实，本本分分。\n我去过很多城市，郑州人的友善程度我觉得是可以排在 Top 级别的！\n另外，郑州这边的居民还是比较恋家的。有很多在北上广混的还不错的人，最后也还是选择回来！\n交通 作为一个北方内陆城市，郑州可以说是一个“交通枢纽”。从郑州出发坐高铁，你去国内大部分地方都非常方便。\n下图中的部分高铁线路正在修建，比如郑万高铁全线大概是 2021 年中旬通车。\n郑州的地铁规划情况如下图所示。\n目前的话，郑州地铁有 1 号线、2 号线、3 号线、4 号线、城郊线、5 号线、14 号线一期 7 条地铁线。\n美食 郑州的各种商业设施还是比较齐全的，有很多大型的商场，商场里面基本是样样俱全。\n郑州好吃的还挺多的！去了郑州之后，一定要去喝胡辣汤，真的不要太好喝！\n本地的美食还有烩面、焖饼、烧鸡等等都非常不错。\n巩义那边有一家花雕醉鸡真心不错，价格便宜，2 个人不到 100 元就能吃的很好！最关键的是味道真的好！！！\n像浙菜、豫菜、火锅串串这边都能找到比较好吃的店子，可以满足绝大部分小伙伴的味蕾。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/zhengzhou/","summary":"郑州 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。 由于我本人对郑州","title":""},{"content":"\r小任同学\u0026#39;s Blog\r小任同学的博客\r\r\r\r\rBanTanger\r这是半糖先生的博客\r\r\r\r\r小林coding\r这是林佬的网站\r\r\r\r\r添加\r期待加入...\r\r\r\r👉友链格式 名称： 小任同学 网址： https://coderrenxy.github.io/ 图标： https://coderrenxy.github.io/img/icon-512.png 描述： 小任同学的博客\n👉友链申请要求\n-秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://coderrenxy.github.io/links/","summary":"小任同学\u0026#39;s Blog 小任同学的博客 BanTanger 这是半糖先生的博客 小林coding 这是林佬的网站 添加 期待加入... 👉友链格式 名称： 小任同学 网址： https://coderrenxy.github.io/ 图标","title":"🤝友链"}]
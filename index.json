[{"content":"\r\r/* 手机适配 */\r@media screen and (max-width: 500px) {\r.search{\rpadding-right: 25px;\r}\r.search input{\rwidth: 100%;\r}\r.search button{\rdisplay: none;\r}\r}\r/* 电脑适配 */\r@media screen and (min-width: 500px) {\r.search{\rwidth: 500px;\r}\r.search input{\rwidth: 444px;\r}\r}\r/* 通用样式 */\r.search{\rmargin: auto;\r}\r.search input{\routline: none;\rborder: 2px solid #c05b4d;\rheight: 32px;\rpadding: 10px;\r}\r.search button{\routline: none;\rborder: 0px;\rheight: 56px;\rwidth:56px;\rposition:absolute;\rbackground-color:#c05b4d ;\r}\r.search .icon{\rwidth: 28px;\rheight: 28px;\r}\r\r\r\r\r\r\r\r\r搜索中，请稍后 ...\r\r// enter\rwindow.onload = function() {\rdocument.onkeydown = function(ev) {\rvar event = ev || event\rif (event.keyCode == 13) {\rsearch()\r}\r}\r}\r// search\rfunction search() {\rkey = document.getElementById(\"search-key\").value;\rif (key === \"\") {\rreturn;\r}\rdocument.getElementById(\"search-key\").value = \"\";\r// tip\rdocument.getElementById(\"search-tip\").innerText = \"搜索中，请稍后 ...\";\rdocument.getElementById(\"search-tip\").style.display = \"block\";\r// clear\rvar el = document.getElementById('result');\rvar childs = el.childNodes;\rfor (var i = childs.length - 1; i = 0; i--) {\rel.removeChild(childs[i]);\r}\r// xml\rxmltext = new XMLHttpRequest;\rxmltext.open(\"GET\", \"/index.xml\", false);\rxmltext.send();\rresp = xmltext.responseXML;\ritems = resp.getElementsByTagName(\"item\");\r// search\rvar i = 0;\rhaveResult = false;\rwhile (i -1) {\rhaveResult = true;\rtitle = items[i].getElementsByTagName(\"title\")[0].innerHTML;\rlink = items[i].getElementsByTagName(\"link\")[0].innerHTML;\rtime = items[i].getElementsByTagName(\"pubDate\")[0].innerHTML;\rmark = items[i].getElementsByTagName(\"description\")[0].innerHTML;\raddItem(title, link, time, mark)\r}\ri++;\r}\rif (!haveResult) {\rdocument.getElementById(\"search-tip\").innerText = \"搜索完毕，未发现结果 ...\";\rdocument.getElementById(\"search-tip\").style.display = \"block\";\r}\r}\r// add\rfunction addItem(title, link, time, mark) {\rdocument.getElementById(\"search-tip\").style.display = \"none\";\rtmpl = \"\" +\r\"\" +\r\"\" + title + \"\" +\r\"\" +\r\" \" + time + \"\" +\r\"\" +\r\" \" +\r\"\" +\r\"\" + mark + \"\" +\r\"\" +\r\"阅读更多\" +\r\"\" +\r\" \" +\r\"\"\rdiv = document.createElement(\"div\")\rdiv.innerHTML = tmpl;\rdocument.getElementById('result').appendChild(div)\r}\r","permalink":"https://coderrenxy.github.io/search/","summary":"/* 手机适配 */ @media screen and (max-width: 500px) { .search{ padding-right: 25px; } .search input{ width: 100%; } .search button{ display: none; } } /* 电脑适配 */ @media screen and (min-width: 500px) { .search{ width: 500px; } .search input{ width: 444px; } } /* 通用样式 */ .search{ margin: auto; } .search input{ outline: none; border: 2px solid #c05b4d; height: 32px; padding:","title":"🔍搜索"},{"content":"这一周工作 第一天拿到需求，前一天因为学校考试和只睡了1h，一直在赶火车，甚至来公司都是带着行李，第一天状态很差，看代码还没库，完全蒙蔽。 好在导师及时疏解，把库给我，把我没有理解的需求重讲了一遍，然后我也录音周末看代码+听录音。\n经过了8天，需求算是尘埃落定了。当然整个过程多亏了导师的鼎力支持。\n我的反思 这一周有许多值得反思的，例如：对代码触觉不灵敏，写代码少+粗心，导致初版上灰度就出现好几次线上问题。\n判空、mapper实体字段写成表字段名，一系列 nt 事情在我的操作中接二连三。\n还有很多开发常识反应不灵敏、git 操作不熟悉、linux 命令不熟悉 、排查代码问题的思路不够清晰。\n我的周末计划  整理这周笔记，犯过的错，走过的误区，有疑点的开发知识翻阅资料。 安装 mac 的环境，拿到mac卧槽太爽了！！！ 熟悉云效流水线的代码，不然等需求过来临时看是地狱体验。 如果还有时间 or 不想看代码：git找文章甚至自建项目熟悉一下，熟悉 linux 命令。要用的时候不会真的很尴尬，总不能句句都去 gpt 吧？  我的下周计划  把失败发布的记录拉出来。 把需求上线，并学习记录整个发布上线的流程（应该跟 灰度、日常环境 差不多）。 继续看代码，并排查《保存流水线 的接口很慢的问题》。 迎接下一个需求，熟悉那块代码。  我的长期计划 由于后续开发基本都是云效，所有云效代码必须全部熟悉，首当其冲是流水线，我需要接触的 90%+ 代码都在这。\n持续产出，熟悉完代码后续学 docker、k8s 之类的云原生，体系很大，做好长线打算。\n产出尽量向正式工靠拢，跟着神级导师冲，起码四个月后在早会能听得懂大家的每句话，半年后有自己的想法。\n争取转正，早日上岸，脱离秋招苦海。\n","permalink":"https://coderrenxy.github.io/posts/life/%E5%AE%9E%E4%B9%A0%E5%91%A8%E8%AE%B01/","summary":"这一周工作 第一天拿到需求，前一天因为学校考试和只睡了1h，一直在赶火车，甚至来公司都是带着行李，第一天状态很差，看代码还没库，完全蒙蔽。 好在","title":"实习周记1"},{"content":"这周进度 还不错吧，一直在动。\n英语六级 有点困难。\nredis 结束了。\nJUC 开始了 先黑马的教材，再看电子书。\n写了两天数据库作业。\n算法落下了两天，但是把桶排序搞明白了。\n操作系统复习了一些。\n下周计划  六级。 lc照常。 操作系统+数据库 继续复习。 JUC 优先级 \u0026gt; lc。  others 好好睡觉。学校的课真的好磨人好恶心。\n学习感悟 不要钻牛角尖！\n该摆就摆，能学就学！\n","permalink":"https://coderrenxy.github.io/posts/life/november.no3-weekly-summary/","summary":"这周进度 还不错吧，一直在动。 英语六级 有点困难。 redis 结束了。 JUC 开始了 先黑马的教材，再看电子书。 写了两天数据库作业。 算法落下了两天，但是把桶排序搞","title":"November.No.3 Weekly Summary"},{"content":"最近学习 计网完了，已经 redis了，LC 一直在刷，剑指刷的比 随想录勤快，毕竟剑指是新题。当没时间完成所有任务的时候，new题 \u0026gt; old题，new 知识 \u0026gt; old。 效率真的很一般，经常因为有事完不成任务，但是时长应该少不了太多。\n最近生活 该聚的聚，不想再聚了，买了个洗衣机、电动车。欠了1000了，日子难过。\n生活质量不错，睡眠充足，规律。早上吃两个鸡蛋，中午多吃肉，补充动物蛋白。\n10月 比较 9月 好点了，比刚来天天聚效率当然没话说。但是被蓝桥杯耽误了几天。\n10月任务完成了。随想录四刷了。\n11月计划 redis结束掉，比较困难。起码过一遍。\n英语六级复习。\n剑指offer 拿下。\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\nredis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：四刷 + 剑指offer（一个零十天） \u0026ndash;\u0026gt; 五刷 + hot100（两个月）\u0026ndash;\u0026gt; 算法开始 acm 模式\n","permalink":"https://coderrenxy.github.io/posts/life/10%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 计网完了，已经 redis了，LC 一直在刷，剑指刷的比 随想录勤快，毕竟剑指是新题。当没时间完成所有任务的时候，new题 \u0026gt; old题，ne","title":"10月总结"},{"content":"最近学习 已经断了两个月没更新，至于为什么没更新，原因有如下几点。\n 考英语六级 复习 准备期末考试 逐渐忘记了规划，但是事情还在做。  最近生活 一般\u0026hellip;\u0026hellip;.\n在学校疫情爆发了，还有点小刺激，下一天就好了，又焦灼的选择到底留不留校考六级。\n情绪起伏比较大.\n疫情开放，味觉没了，感冒两周没好，咳嗽，应该是🐏了。\n家人已经阳了，我也跑不了。\n不爱出去但是老出去。\n12月 比较 10月 效率低很多，虽然期末考不重要，但是这些不起眼的东西到时候可能会害了我自己，让我实习中途回来补考。\n所以我要好好准备考试（教考分离）。\nLC 没刷了，因为双非二本专升本刷这个确实性价比低。\n花了一周半做了一个外卖平台 。 redis 解决了，现在在学 JUC ，不打算精学，准备面向面试题学，但是给自己的时间是20天，学得快就把 黑马、尚硅谷（两位老师）都看一遍加深理解。\n1月计划 JUC 15号之前结束。\n开始 JVM。\n尽量一月剩下的15天结束 JVM 再深化简历再去复习。\n关于复习，能专门写一篇文章准备。\n长期计划 juc、jvm。开始复习（大概2个月）再投递。\n","permalink":"https://coderrenxy.github.io/posts/life/12%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 已经断了两个月没更新，至于为什么没更新，原因有如下几点。 考英语六级 复习 准备期末考试 逐渐忘记了规划，但是事情还在做。 最近生活 一般\u0026he","title":"12月总结"},{"content":"这周进度  每天2道以前刷过的 LC+剑指offer 2题。 完成度60%，有时候碰到难题（old/new）花很久或者摆烂了。 每天在学 计网。   计网：效率不错，思维导图做了很多。 算法：三刷LC，摆烂很少，因为上网课时间充裕。周赛日了狗，第一题写了20分钟，第二道题自己没想出来辗转相除，三四都是 hard，不干耗。  下周计划  计网最后一天时间结束，记得做笔记。 开始学习 Redis。 算法接着刷。 算法遗漏：优先队列，TreeMap、十大排序。  XXX  别想的太远。 避免信息洪流中让我有 “快进” 想法的信息。  赖酒攻略  不要空腹喝酒，喝酒前喝浓酸奶。 吃肥肉。 不小心弄掉东西，蹲下去捡 吐掉酒。 多喝水，上厕所排出酒精，喝到还剩一点就喝白酒的时候往里面吐。 手里攥卫生纸，吐在卫生纸里。 开始难受就 装吐，不然酒醒了痛的是自己。  ","permalink":"https://coderrenxy.github.io/posts/life/october.no3-weekly-summary/","summary":"这周进度 每天2道以前刷过的 LC+剑指offer 2题。 完成度60%，有时候碰到难题（old/new）花很久或者摆烂了。 每天在学 计网。 计网：效率","title":"October.No3 Weekly Summary"},{"content":"这周进度  每天2道以前刷过的 LC+剑指offer 2题。 每天在学 刷题 + 计网。   计网：效率不错，开始消化了。 算法：三刷LC，有1天摆烂，另外一天因为前缀和一道题目一直在思考，没有进度。 赖了上周的一篇总结。  下周计划  计网继续啃，做笔记。 算法接着刷。 优先队列，TreeMap，还有十大排序。慢慢来。  ","permalink":"https://coderrenxy.github.io/posts/life/october.no2-weekly-summary/","summary":"这周进度 每天2道以前刷过的 LC+剑指offer 2题。 每天在学 刷题 + 计网。 计网：效率不错，开始消化了。 算法：三刷LC，有1天摆烂，另外一天因为","title":"October.No2 Weekly Summary"},{"content":"最近学习 效率可想而知的烂，开学的第一个月，课程、新朋友、小聚、过节。\n代码随想录二刷完成，但是在推进 剑指offer+代码随想录 时碰到很多困难，难坚持，编码环境的细微差别就不好适应，更别说以后的 acm模式编码，只能硬着头皮冲。\n计网二刷意料之内的未完成，毕竟内容多、抽象、杂。\n最近生活 间断式熬夜，但是整体睡眠比以前要好很多，每天都在8小时以上的睡眠时间，其它都很麻木，一下认识这么多新的人，一个月恍如隔世。新鲜感拉满，让平衡反复摇摆。\n想让自己一切都不过度，开心、难过、兴奋、沮丧 都把握在可掌握的度，因为一切的过度都会引起反噬。\n9月 比较 8月 从家到学校，从一个牢房到另一个牢房，明显这个复杂的牢房效率很低。\n9月计划 计网 二刷 过完 + 代码随想录三刷过半 + 剑指offer过半，（2 old + 1/2 new）模式。\n是1还是2看题目难度，第一题easy就必须要做第二题，每天要保证在算法上有深度思考。\n计网5-10天结束，开始\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\n计网 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 + 剑指offer（一个半月） \u0026ndash;\u0026gt; 四刷 + hot100（两个月）\u0026ndash;\u0026gt; 算法开始 acm 模式\n","permalink":"https://coderrenxy.github.io/posts/life/9%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 效率可想而知的烂，开学的第一个月，课程、新朋友、小聚、过节。 代码随想录二刷完成，但是在推进 剑指offer+代码随想录 时碰到很多困难，","title":"9月总结"},{"content":"这周进度 效率还是一样，shit 常态，天天为了“上课”忙的跟筛子一样，摆了两天，虽然非自愿，但是以结果导向来看，必须遏止。\n想尽办法杜绝，周六也在忙学习，7点就起了(周五9点多就睡了)，周六相当难受，动态规划最后的几道题，让人想哭，想到下周要搞几题新的动态规划就绷不住了，还有单调栈，全是hard。\n计网二刷也是让我相当痛苦，明天又要出去，世界末日！！！\n下周计划  计网继续二刷。 lc照常，周赛走着。  others 现在最想做的事就是每天做的宿舍摆烂也好，学习也好。自己起码是个自由的人，自由到随意思考，随意躺平。\n必须尽快克服别人的目光，让自己在“上课”的时候能以自己最舒服的心态做自己的事情。\n关于以后我是越来越迷茫了，行业风口变来变去。这种不确定性让我很难受，但人生就是靠着不确定维系，最近看到某博主讲：精神内耗符合热力学定律，一定会有内耗这种损耗，有才代表活着，才代表能找到进步。\n既然未来很多事情不可控，那就把可控因素拿捏到最好吧，毕竟不得不承认我也就是个争做中产阶级的普通人。\n不要太在意别人看法了，上周因为别人几句话内耗了一整天，然后有的人已经说到没做到了，那么在意别人的话干什么？\n午饭后冲牙\n睡觉可以听正念催眠\n学习感悟 不要钻牛角尖！\n该摆就摆，能学就学！\n","permalink":"https://coderrenxy.github.io/posts/life/september.no4-weekly-summary/","summary":"这周进度 效率还是一样，shit 常态，天天为了“上课”忙的跟筛子一样，摆了两天，虽然非自愿，但是以结果导向来看，必须遏止。 想尽办法杜绝，周六也","title":"September.No4 Weekly Summary"},{"content":"这周进度 效率跟 shit 一样，上课，课程质量就不描述了，非得走个形式，一天的闲情、精力、时间全都被这套形式组合拳磨灭了，非常 down ，救命吧。\n只想有自己的时间，就算无聊到反复喝水也算不上折磨，就算被计网lc按在地上摩擦也比时间剥夺强一万倍。鬼天气\n下周计划  计网二刷。 lc照常，周赛走着。  长远 越发感觉互联网这条路不能一条路走到黑了，但是现在改变方向未必是及时止损。\n先找到工作，再边工作边提升技术，这样保证自己不淘汰，薪资也在涨，攒点钱。\n30之前存好一笔钱边工作边考公，这时候技术差不多成熟了，空出大部分时间备考江西省直。\n其它城市买不起房，性价比当然高，工资也高，但是考虑家人的低于归属感还是留在江西比较好。\n考研估计是明日黄花了，缩招+就业形势疯狂下滑。三年前的本科生还能找到不错的工作，现在读完研反而找不到了。\n学习感悟 学不下去的时候很容易拧巴，为啥学不进去，然后又去学，反复焦虑，形成一个圈，破这个 circle 就是索性不学，直接摆烂，好听一点就是让自己 at ease。只要 at ease，身体处于舒适状态，看什么都容易思考，静得下来并且愿意慢慢咀嚼。\n到学校14天，完全没感觉到，因为这14天心理历程波动比前两个月明显多了，两个月学下来心理波动不大，两个月如一日，痛苦一下嗖的过去了，是没那么难受，但是会少很多感悟，毕竟做人，不就是 get various feelings 吗?\nno matter that ，anything is my choice，is my way on my life，just like me，accept change and challenge.\nlast but not least, just do it !!!\n","permalink":"https://coderrenxy.github.io/posts/life/september.no3-weekly-summary/","summary":"这周进度 效率跟 shit 一样，上课，课程质量就不描述了，非得走个形式，一天的闲情、精力、时间全都被这套形式组合拳磨灭了，非常 down ，救命吧。 只想有自己的","title":"September.No3 Weekly Summary"},{"content":"这周进度  每天3道以前刷过的 LC。 每天在学 刷题 + 计网。   计网：效率很差，文章太硬核。 算法：二刷LC，周赛 ac两题，刷题一天3题。中秋节没刷，有一天摆烂。  下周计划  计网改变策略，太硬核了，搜常见面经针对性突破。 算法接着刷。 算法多重背包、前缀和、TreeMap、优先队列 ，任重道远。  ","permalink":"https://coderrenxy.github.io/posts/life/september.no2-weekly-summary/","summary":"这周进度 每天3道以前刷过的 LC。 每天在学 刷题 + 计网。 计网：效率很差，文章太硬核。 算法：二刷LC，周赛 ac两题，刷题一天3题。中秋节没刷，有一","title":"September.No2 Weekly Summary"},{"content":"这周进度  每天3道以前刷过的 LC。 每天在学 刷题 + 操作系统。   操作系统：二三遍操作系统过去了，第一遍就很烂，第二篇不错，但是到后面几篇文章着实看不懂。 算法：二刷LC，周末打周赛，一天3题，开学前完成二刷没做到。  下周计划  计网一天2-3篇文章。 算法接着刷。 开学一堆破事。  ","permalink":"https://coderrenxy.github.io/posts/life/september.no1-weekly-summary/","summary":"这周进度 每天3道以前刷过的 LC。 每天在学 刷题 + 操作系统。 操作系统：二三遍操作系统过去了，第一遍就很烂，第二篇不错，但是到后面几篇文章着实看不","title":"September.No1 Weekly Summary"},{"content":"前置知识填充篇：\n满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。\n完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。\n二叉搜索树：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。\n平衡二叉树（AVL）：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。\n二叉树的存储：\n二叉树可以链式存储，也可以顺序存储。\n链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历：\n 深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。 广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）  144.二叉树的前序遍历 \u0026amp; 145.二叉树的后序遍历 \u0026amp; 94.二叉树的中序遍历 递归做法：三个遍历一个方法代码挪一下位置。\n迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。\n注意：\n 迭代中序是复杂点，不断地往左推，到最左再依次弹出，弹出要注意父节点的 right 有没有，就这条思路。 后序 不是 直接 前序 倒转，而是把 前序 的左右孩子入栈顺序倒转再 反转。 前序：中左右。 后序：左右中。前序调转入栈顺序：中右左，反转：左右中=后序。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution {//中序遍历  public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); if(root == null) return list; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()){ if(cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); list.add(cur.val); cur = cur.right; } } return list; } }   102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。\n是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n二刷思路：用 deep 和 list 的 size 来判断是否需要 new 新的 listSon。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { list = new ArrayList\u0026lt;\u0026gt;(); bfs(root,0); return list; } public void bfs(TreeNode root,int deep){ if(root == null) return; deep++; if(list.size() \u0026lt; deep){ List\u0026lt;Integer\u0026gt; item = new ArrayList\u0026lt;\u0026gt;(); list.add(item); } list.get(deep-1).add(root.val); bfs(root.left,deep); bfs(root.right,deep); } }   迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n二刷思路：把 root 放进去队列，poll 出来 add(val)，然后放入左右孩子，poll 出来 add(val)。一层孩子 new 一个 list，而结束条件是 !queue.isEmpty() ，控制层层分离的则是 最初操作的 queue.size() 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); if(root == null) return list; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); TreeNode temp = null; while(!queue.isEmpty()){ List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); int len = queue.size(); while(len \u0026gt; 0){ temp = queue.poll(); listSon.add(temp.val); if(temp.left != null) queue.offer(temp.left); if(temp.right != null) queue.offer(temp.right); len--; } list.add(listSon); } return list; } }   107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n//需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg\u0026hellip;..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..\n226.翻转二叉树 递归：确定参数类型、返回值 —\u0026gt; 确定终止条件 —\u0026gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026amp;\u0026amp;。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n二刷：实在没想到思路，竟然是这样。递归一个求深度方法；\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n二刷：主要就是用左右孩子为空当作依据来操作，先去 List 出来 path ，再去操作字符串，不然append(root.left.val).append(”→”) 这样很难回溯。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 ”左闭右开“ 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n二刷构建树 前序：[root,root.left,root.right]\n中序：[root.left,root,root.right]\n后序：[root.left,root.right,root]\n前序遍历的第一个，后序遍历的最后一个元素就是树的根节点，根据这根节点可以在 中序遍历 中找到 val 相同的节点，也就是这棵树的根节点，这个节点的左边就是左子树的所有节点，右边就是右子树的所有结点。这样我们知道了左右子树各自的节点个数。根据前序数组，root,左子树所有节点，右子树所有节点，可以拿到左子树的所有节点的前序遍历、右子树所有节点的后序遍历，继续递归。后序遍历同理。结束条件是中序 left \u0026gt; right,left == right 时 new这个节点。\n654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if \u0026hellip; else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left \u0026gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\n二刷：类似建树，比建树简单多了。\n617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略\u0026hellip;\u0026hellip;\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子\u0026hellip;\u0026hellip;.）、右子树的最左后代是值最接近根节点的结点。\n二刷：左子树最右子节点的递归方法，右子树最左子节点的递归方法。\n501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List\u0026lt;TreeNode\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;TreeNode\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; i\u0026lt;list1.size(); i++){ for(int j=0; j\u0026lt;list2.size(); j++){ if(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List\u0026lt;TreeNode\u0026gt; list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026amp;\u0026amp; right != null) return root; if(left != null \u0026amp;\u0026amp; right == null) return left; if(left == null \u0026amp;\u0026amp; right != null) return right; return null; } }   二刷：从root向下找如果找到了p||q就return，否则就向下遍历，递归到了最深处还没找到返回值就是null，把左边找到的值用 left 传递，没找到就是 null 返回，然后做判断，左右孩子都是null就返回null，找到 p、q 任意一个都返回，也就是 left、right 会层层传递，左右孩子都不为空就返回 root。\n235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val \u0026gt; p.val \u0026amp;\u0026amp; root.val \u0026gt; q.val) return lowestCommonAncestor(root.left , p, q); if(root.val \u0026lt; p.val \u0026amp;\u0026amp; root.val \u0026lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val \u0026gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 \u0026gt; \\ \u0026lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。\n1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val \u0026gt; root.val) root.right = insertIntoBST(root.right, val); if(val \u0026lt; root.val) root.left = insertIntoBST(root.left , val); return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点左右孩子都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val \u0026gt; key) root.left = deleteNode1(root.left , key); if(root.val \u0026lt; key) root.right = deleteNode1(root.right, key); if(root.val == key){ if(root.right != null \u0026amp;\u0026amp; root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026amp;\u0026amp; root.left == null){ return root.right; }else if(root.right == null \u0026amp;\u0026amp; root.left != null){ return root.left; }else{ return null; } } return root; } }   二刷：root.right 节点当作新的 root，root.left 变成 root.right 的最左节点的孩子\n注意：用 root.left = 递归(root.left , key) 的方式，来传递，这样才能把 key 对应的 node 删除并且 让 node 的父节点去链接 noder.right 节点。找右孩子的最左祖孙时可以 while 循环来找。\n669. 修剪二叉搜索树 思路：分别处理不正常结点，正常的节点。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null) return null; //处理不正常的节点  if(root.val \u0026lt; low) return trimBST(root.right, low, high); if(root.val \u0026gt; high) return trimBST(root.left , low, high); //处理正常节点  root.left = trimBST(root.left , low, high); root.right = trimBST(root.right, low, high); return root; } }   108.将有序数组转换为二叉搜索树 思路：分别递归左右区间\n注意：\n 左右开闭一定要统一起来，我都是都闭着。 左右区间去递归一个方法。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public TreeNode sortedArrayToBST(int[] nums) { return method1(nums, 0, nums.length-1); } public TreeNode method1(int[] nums,int left,int right){ if(left \u0026gt; right) return null; if(left == right) return new TreeNode(nums[left]); int mid = left + (right-left)/2; TreeNode root = new TreeNode(nums[mid]); root.left = method1(nums, left, mid-1); root.right = method1(nums, mid+1, right); return root; } }   538.把二叉搜索树转换为累加树 思路：这道题最难的就是看懂题，如果换成数组看就比较好看出来，从右下角的 right 到 root 到 left。相当于就是一个反转了的中序 dfs。\n二刷：最难的是题意，注意，变化后左子树也变成了左孩子大于右孩子，已经不是二叉搜索树了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { dfs(root); return root; } public void dfs(TreeNode root){ if(root == null) return ; dfs(root.right); sum+=root.val; root.val = sum; dfs(root.left); } }   持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/","summary":"前置知识填充篇： 满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。 完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层","title":"LeetCode 二叉树(二)"},{"content":"232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内元素全 pop 到出栈的栈中。\n注意：想清楚为什么 pop、peek stackIn要判空 Out 栈？因为什么？自己手动模拟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); stackOut = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { stackIn.push(x); } public int pop() { outputIsNull(); return stackOut.pop(); } public int peek() { outputIsNull(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } public void outputIsNull(){ if(!stackOut.isEmpty()) return; while(!stackIn.isEmpty()) stackOut.push(stackIn.pop()); } }   225. 用队列实现栈 思路：挪到其中一个队列只剩一个元素再操作。\n注意：API ：poll 相当于 pop、offer 相当于 push、其他不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class MyStack { Queue\u0026lt;Integer\u0026gt; queueIn; Queue\u0026lt;Integer\u0026gt; queueOut; public MyStack() { queueIn = new LinkedList\u0026lt;\u0026gt;(); queueOut = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { queueIn.offer(x); } public int pop() { while(queueIn.size() \u0026gt; 1) queueOut.offer(queueIn.poll()); Queue\u0026lt;Integer\u0026gt; temp = queueIn; queueIn = queueOut; queueOut = temp; return queueOut.poll(); } public int top() { while(queueIn.size() \u0026gt; 1) queueOut.offer(queueIn.poll()); int num = queueIn.peek(); queueOut.offer(queueIn.poll()); Queue\u0026lt;Integer\u0026gt; temp = queueIn; queueIn = queueOut; queueOut = temp; return num; } public boolean empty() { return queueIn.isEmpty() \u0026amp;\u0026amp; queueOut.isEmpty(); } }   20. 有效的括号 思路：遇见左括号就 push 右括号，否则就看栈是否提前空了、栈顶元素匹配当前括号，否则就 pop。\n栈提前空了会导致后面就算有没匹配上的括号，最后 return 的依然是 true 。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(char ch : s.toCharArray()){ if(ch == \u0026#39;(\u0026#39;) stack.push(\u0026#39;)\u0026#39;); else if(ch == \u0026#39;{\u0026#39;) stack.push(\u0026#39;}\u0026#39;); else if(ch == \u0026#39;[\u0026#39;) stack.push(\u0026#39;]\u0026#39;); else if(stack.isEmpty() || ch != stack.pop()) return false;//判空是为了防止pop异常，也可以说是为了最后数量不匹配。  } if(!stack.isEmpty()) return false; return true; } }   1047. 删除字符串中的所有相邻重复项 思路：不用栈也行，直接 sb 的最后一个字符去匹配。\nTips：StringBuilder的删除是 deleteCharAt(int index)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public String removeDuplicates(String s) { StringBuilder sb = new StringBuilder(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;s.length();i++){ if(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==s.charAt(i)){ sb.deleteCharAt(sb.length()-1); stack.pop(); } else{ sb.append(s.charAt(i)); stack.push(s.charAt(i)); } } return new String(sb); } }   150. 逆波兰表达式求值 Tips：与本题无关：数字（int）转字符（char）要强转( char ) ( 0 + ’ 0 ’ )，字符转数字隐式就可以了不用声明出来 ‘ 2 ’ - ’ 0 ’ ，但是为了书写统一，还是都强转一下。\nAPI：Integer.valueOf( str );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; tokens.length; i++){ if(tokens[i].equals(\u0026#34;+\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b+a); }else if(tokens[i].equals(\u0026#34;-\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b-a); }else if(tokens[i].equals(\u0026#34;*\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b*a); }else if(tokens[i].equals(\u0026#34;/\u0026#34;)) { int a = stack.pop(), b = stack.pop(); stack.push(b/a); }else stack.push(Integer.valueOf(tokens[i])); } return stack.pop(); } }   239. 滑动窗口最大值 思路：自己用双端队列实现一个队列，add 方法来保证单调（队头始终为最大值），poll 方法保证窗口的滑动。每次取队头给记录窗口最大值的数组赋值就行了。如何设计 add 、poll ？\nadd：一直比较队尾，如果小于要 add 的 val，就杀掉这个队尾，直到上一个元素大于 val，此时 add 这个 val。\npoll：拿到 ”窗口最后一个值” 与 队头（最大值）去比较，如果相等，就杀死队头，因为这个本该从滑动窗口走出的元素影响最大值的判断了。否则就不操作。\n注意：\nDeque 双端队列才可以取队尾（getLast（ ）、removeLast（ ）），Queue 单端队列不可以。\nDeque 双端队列中，add（）才是在队尾添加元素。\npeek、poll 必须保证队列不为空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(nums ==null || nums.length == 0 || nums.length == 1 || k == 1) return nums; int q = 0, max; int [] res = new int[nums.length-k+1]; MyQueue deque = new MyQueue(); //填充前k个  for(int i = 0; i \u0026lt; k; i++) deque.add(nums[i]); res[q++] = deque.peek(); for(int i = k; i \u0026lt; nums.length; i++){ deque.pop(nums[i-k]); deque.add(nums[i]); res[q++] = deque.peek(); } return res; } } class MyQueue{ Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); int peek(){ return deque.peek(); } void pop(int val){ if(!deque.isEmpty() \u0026amp;\u0026amp; val == deque.peek()) deque.pop(); } void add(int val){ while(!deque.isEmpty() \u0026amp;\u0026amp; val \u0026gt; deque.getLast()) deque.removeLast(); deque.add(val); } }   347.前 K 个高频元素 暴力解法：留意语法错误、API。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution { public int[] topKFrequent(int[] nums, int k) { int p = 0, q = 0; int[] res = new int[k]; Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) if(map.containsKey(nums[i])) map.put(nums[i],map.get(nums[i])+1); else map.put(nums[i],1); int[] temp1 = new int[nums.length]; int[] temp2 = new int[nums.length]; for(int i : map.keySet()) temp1[p++] = i; for(int i : map.keySet()) temp2[q++] = map.get(i); for(int i=0;i\u0026lt;nums.length-1;i++){ for(int j=i+1;j\u0026lt;nums.length;j++) if(temp2[i] \u0026lt; temp2[j]){ int temp = temp2[i]; temp2[i] = temp2[j]; temp2[j] = temp; temp = temp1[i]; temp1[i] = temp1[j]; temp1[j] = temp; } } p = 0; for(int i = 0; i \u0026lt; k; i++) res[p++] = temp1[i]; return res; } }   持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E6%A0%88%E9%98%9F%E5%88%97%E4%BA%8C/","summary":"232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内","title":"LeetCode 栈、队列(二)"},{"content":"344. 反转字符串 1 2 3 4 5 6 7 8 9 10  class Solution { public void reverseString(char[] s) { char temp; for(int i=0;i\u0026lt;s.length/2;i++){ temp = s[i]; s[i] = s[s.length-1-i]; s[s.length-1-i] = temp; } } }   541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字符 .\n判断条件没有很复杂,就是拿到的个数 \u0026gt; k 就操作反转前 k 个, \u0026lt; k 直接全反转.\n就是 ≥2k 和 2k ≥ len ≥ k ,两个区间都是用一操作,融合了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0; i \u0026lt; ch.length; i+=2*k){ char temp ; int begin = i, end = Math.min(i+k-1,ch.length-1); while(begin \u0026lt; end){ temp = ch[begin]; ch[begin] = ch[end]; ch[end] = temp; begin++; end--; } } return new String(ch); } }   剑指Offer 05.替换空格 注意 : 只有 String 转换为了 StringBuffer or StringBuilder 才能用 append \u0026amp;\u0026amp; toString 方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public String replaceSpace(String s) { int count = 0,i = 0; for(char c : s.toCharArray()) if(c == \u0026#39; \u0026#39;) count++; char[] ch = new char[s.length()+2*count]; for(char c : s.toCharArray()){ if(c == \u0026#39; \u0026#39;){ ch[i++] = \u0026#39;%\u0026#39;; ch[i++] = \u0026#39;2\u0026#39;; ch[i++] = \u0026#39;0\u0026#39;; } else ch[i++] = c; } return new String(ch); } }   151. 翻转字符串里的单词 思路：先全部反转、再依次反转各个 word。\n记住几个 API ： charAt、setChatAt，操作 String 先转换成 StringBuilder or StringBuffer 再操作。\n注意要移除开头结尾的 space、word 间连续的 space。\n其中去除连续的 space 注意判断条件 当前 char != space || sb最后一个 char 不为 space（上一个 char 不为 space），两个判断条件反了会短路。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public String reverseWords(String s) { //删除开头结尾中间的空格  StringBuilder sb = removeSpace(s); reverseString(sb,0,sb.length()-1); reverseEachWord(sb); return sb.toString(); } public StringBuilder removeSpace(String s){ int left = 0, right = s.length()-1; StringBuilder sb = new StringBuilder(); while(s.charAt(left) == \u0026#39; \u0026#39;) left++; while(s.charAt(right) == \u0026#39; \u0026#39;) right--; while(right \u0026gt;= left){ if(s.charAt(left) != \u0026#39; \u0026#39; || sb.charAt(sb.length()-1) != \u0026#39; \u0026#39;) sb.append(s.charAt(left)); left++; } return sb; } public void reverseString(StringBuilder sb,int left,int right){ while(left \u0026lt; right){ char temp = sb.charAt(left); sb.setCharAt(left,sb.charAt(right)); sb.setCharAt(right,temp); left++; right--; } } public void reverseEachWord(StringBuilder sb){ int left = 0,right; while(left \u0026lt; sb.length()-1){ right = left+1; while(right != sb.length() \u0026amp;\u0026amp; sb.charAt(right) != \u0026#39; \u0026#39;)//为什么不是len-1？ 因为最后是right-1当右边界操作。并且\u0026amp;\u0026amp;先后顺序乱了就会越界。  right++; reverseString(sb,left,right-1); left = right+1; } } }   剑指Offer58-II.左旋转字符串 思路：把 n 后面的先 append 到 new 的 sb 上，再把 n 之前的 append 到 sb 。\n1 2 3 4 5 6 7 8 9 10  class Solution { public String reverseLeftWords(String s, int n) { StringBuilder sb = new StringBuilder(); for(int i=n;i\u0026lt;s.length();i++) sb.append(s.charAt(i)); for(int i=0;i\u0026lt;n;i++) sb.append(s.charAt(i)); return sb.toString(); } }   28. 实现 strStr() KMP\n459. 重复的子字符串 KMP\n持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%8C/","summary":"344. 反转字符串 1 2 3 4 5 6 7 8 9 10 class Solution { public void reverseString(char[] s) { char temp; for(int i=0;i\u0026lt;s.length/2;i++){ temp = s[i]; s[i] = s[s.length-1-i]; s[s.length-1-i] = temp; } } } 541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字","title":"LeetCode 字符串(二)"},{"content":"242.有效的字母异位词 暴力哈希：map1.put(ch,++map1.get(ch))会报错，+1就不会。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public boolean isAnagram(String s, String t) { Map\u0026lt;Character,Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character,Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); for(Character ch : s.toCharArray()){ if(map1.containsKey(ch)) map1.put(ch,map1.get(ch)+1); else map1.put(ch,1); } for(Character ch : t.toCharArray()){ if(map1.containsKey(ch)) map1.put(ch,map1.get(ch)-1); else return false; } for(Character ch : s.toCharArray()) if(map1.get(ch) != 0) return false; return true; } }   巧用数组：\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public boolean isAnagram(String s, String t) { int[] nums = new int[26]; for(char ch : s.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]++; for(char ch : t.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]--; for(int num : nums) if(num != 0) return false; return true; } }   349. 两个数组的交集 注意：set.add()、set.contains()、map.put()、map.get()、map.containsKey()。结果用 set 来放就不用来回倒腾。剪枝优化一下 length==0 || nums==null.\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set\u0026lt;Integer\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for(int i : nums1) set1.add(i); for(int i : nums2) if(set1.contains(i)) set2.add(i); return set2.stream().mapToInt(x-\u0026gt;x).toArray(); } }   202. 快乐数 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。\n所以进主函数的循环条件为 ≠1 \u0026amp;\u0026amp; !set.contains(?); 只要能进这个循环就进去拿到 nextNumber ，进到该方法里再进行拿到 各数上的平方和。\n注意：res += n % 10 * n % 10; 一定要写成 res += (n % 10) * (n % 10); 因为四则运算的优先级会先 n%10 再 *n 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public boolean isHappy(int n) { int sum = n; Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while(!set.contains(n)){ set.add(n); if(n == 1) return true; sum = 0; while(n != 0){ sum += (n%10) * (n%10); n /= 10; } n = sum; } return false; } }   1. 两数之和 暴力冒泡只要注意初始化： j=i+1即可。\n进阶版本：主要熟悉几个常用 API：map.containsKey(key)、map.get(key)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] array = new int[2]; for(int i = 0; i \u0026lt;= nums.length; i++){ if(map.containsKey(target-nums[i])){ array[0] = map.get(target-nums[i]); array[1] = i; return array; }else{ map.put(nums[i],i); } } return array; } }   454. 四数相加 II 思路：先把前两个数组之和（key），该和出现的次数value 存入map，再遍历后两个数组拿到 0-（c+d）去查map是否存在，存在 count+=value。\n注意：可能有数组传入为 null，计算值的时候默认为 0 就行，如果两个普通的 for循环嵌套，有空数组会被判断条件拦截下来，但如果用的是 foreach 就没问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int count = 0; for(int i : nums1){ for(int j : nums2){ if(map.containsKey(i+j)) map.put(i+j,map.get(i+j)+1); else map.put(i+j,1); } } for(int i : nums3){ for(int j : nums4){ if(map.containsKey(-i-j)) count += map.get(-i-j); } } return count; } }   383.赎金信 思路：长度为26的数组。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] nums = new int[26]; for(char ch : magazine.toCharArray()) nums[ch-\u0026#39;a\u0026#39;]++; for(char ch : ransomNote.toCharArray()) if(nums[ch-\u0026#39;a\u0026#39;] == 0) return false; else nums[ch-\u0026#39;a\u0026#39;]--; return true; } }   15.三数之和 先记住两个 API：Arrays.sort(nums)、``Arrays.asList(nums[i], nums[left], nums[right])\n思路：先排个序，方便很多，测试用例里也是排序号的！再用双指针 left、right 来定位。SUM\u0026gt;0 就right—，反之 left++。\n注意：\n 如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”。 if 要匹配 else，否则进多个 if 就会导致上一条注意失效。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;nums.length;i++){ if(nums[i] \u0026gt; 0) return list;//剪枝  if(i\u0026gt;0 \u0026amp;\u0026amp; nums[i]==nums[i-1]) continue; int left = i+1,right = nums.length-1; while(left \u0026lt; right){ if(nums[i]+nums[left]+nums[right] \u0026lt; 0) left++; else if(nums[i]+nums[left]+nums[right] \u0026gt; 0) right--; else if(nums[i]+nums[left]+nums[right] == 0){ list.add(Arrays.asList(nums[i],nums[left],nums[right])); while(right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right-1]) right--; while(right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; right--; left++; } } } return list; } }   18.四数之和 思路 : 就是三数之和多了一个 for 循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length-3 ; i++){ if(nums[i]\u0026gt;0 \u0026amp;\u0026amp; nums[i] \u0026gt; target) return list;//也可能负的越来越多，第一个是正数才成立。  if(i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; for(int j = i+1; j \u0026lt; nums.length-2; j++){ if(j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) continue;//因为i和第一个j一定是可以用的，而i和其第二个j（与j-1值相同）就导致元组重复。  int left = j+1,right = nums.length-1; while(left \u0026lt; right){ long sum = (long) nums[i]+nums[j]+nums[left]+nums[right]; if(sum \u0026gt; target) right--; else if(sum \u0026lt; target) left++; else{ list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right-1]) right--; left++; right--; } } } } return list; } }   注意:\n1  if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;}    这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 . 还有就是 \u0026gt; target \u0026lt; target == target 绝对 if\u0026hellip;else 而不是单独的多个 if .  持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C/","summary":"242.有效的字母异位词 暴力哈希：map1.put(ch,++map1.get(ch))会报错，+1就不会。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","title":"LeetCode 哈希表(二)"},{"content":"203. 移除链表元素 思路：先处理头结点 null 或者 val ，再去处理移除节点。\n注意：返回值返回 head。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public ListNode removeElements(ListNode head, int val) { //处理头结点为 val 或为 null  while(head != null \u0026amp;\u0026amp; head.val == val) head = head.next; if(head == null) return null; ListNode p = head; ListNode q = p.next; while(q != null){ if(q.val == val){ p.next = q.next; q = p.next; }else{ p = q; q = q.next; } } return head; } }   707. 设计链表 思路：先定义好 class ，然后在已有的 class 定义一个 size 和 头结点 head，然后写出 addAtIndex，其它都可以调用或者抄代码 ；\n注意：size 要变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class ListNode{ int val; ListNode next; ListNode(){} ListNode(int val){this.val = val;} } class MyLinkedList { ListNode head; int size; public MyLinkedList() {//初始化链表  int size = 0; head = new ListNode(0); } public int get(int index) { if(index \u0026gt;= size || index \u0026lt; 0) return -1; ListNode p = head; for(int i = 0; i \u0026lt;= index; i++) p = p.next; return p.val; } public void addAtHead(int val) { addAtIndex(0,val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index \u0026gt; size) return; if(index \u0026lt; 0) index = 0; size++; ListNode Node = new ListNode(val); ListNode p; p = head; for(int i = 0; i \u0026lt; index; i++) p = p.next; Node.next = p.next; p.next = Node; } public void deleteAtIndex(int index) { if(index \u0026gt;= size || index \u0026lt; 0) return; ListNode p; p = head; for(int i = 0; i \u0026lt; index; i++) p = p.next; p.next = p.next.next; size--; } }   206. 反转链表 思路：先写出循环体再思考细枝末节，例如最后一个节点要单独写并返回一个新的头结点，再比如在循环之前要判空 head ，防止 next = cur.next 报异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public ListNode reverseList(ListNode head) { if(head == null) return null; ListNode pre = null; ListNode cur = head; ListNode next = cur.next; while(next != null){ cur.next = pre; pre = cur; cur = next; next = cur.next; } cur.next = pre; return cur; } }   24. 两两交换链表中的结点 思路：创建一个虚拟头结点再用 pre 指向它，最后返回的是 虚拟头结点.next 这个新的头结点，额外加一个 temp 节点缓存 pre.next.next 其实也就相当于 next ，head 节点已经可以自由使用了，因为返回的头结点与 head 无关，head 用来缓存 pre.next 相当于 cur ，三个节点都缓存了，这三个节点相互操作就很容易，先把三个节点外的节点操作完成。然后去操作里面，再在循环中移动这几个节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public ListNode swapPairs(ListNode head) { if(head == null) return null; ListNode pre,temp; ListNode dummyNode = new ListNode(0); dummyNode.next = head; pre = dummyNode; while(pre.next != null \u0026amp;\u0026amp; pre.next.next != null){ temp = head.next; head.next = temp.next; pre.next = temp; temp.next = head; pre = head; head = head.next; } return dummyNode.next; } }   19.删除链表的倒数第N个节点 暴力解法：注意考虑传入的值的合法性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null) return null; ListNode cur; cur = head; int i = 0; while(cur != null){//计算长度  cur = cur.next; i++; } if(i == n) //删除的是头结点（单独讨论），也避免只有一个节点时 cur.next.next 为 null  return head.next; i = i-n; cur = head; while(i \u0026gt; 1){ cur = cur.next; i--; } cur.next = cur.next.next; return head; } }   进阶版本：首先一边扫描肯定无从下手，想想，倒数第 n 个结点，是正着数的第几个 ?\n显而易见：size-n 个，那如何拼凑出 size ？那是肯定要扫描一遍完整的链表结点的。\n如果扫描 size++ 出长度那必然要再操作一遍，落入了扫描多次的圈套，so what？\n定义一个 fast 指针、一个 slow 指针，fast 扫描全文，而 slow 指向要被删除的结点的上一结点。如何凑出 size -n？先让 fast 走 n 次，再让 fast 和 slow 一起走剩下的 size-n 次，此时 fast 指向了最后一个元素，slow 指向了删除的结点的上一结点。用 虚拟头结点 会减少很多麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null || head.next == null) return null; ListNode fast,slow,pre; ListNode dummy = new ListNode(0); dummy.next = head; pre = slow = fast = dummy; int i = 1; while(i \u0026lt; n){ fast = fast.next; i++; } while(fast.next != null){ pre = slow; fast = fast.next; slow = slow.next; } pre.next = slow.next; return dummy.next; } }   面试题 02.07. 链表相交 暴力：两层循环遍历，注意有的在 A 链表的位置不一定对应 B 链表的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode node1 = headA; ListNode node2 = headB; while(node1 != null){ node2 = headB; while(node2 != null){ if(node2 == node1) return node2; else node2 = node2.next; } node1 = node1.next; } return null; } }   巧解：AB一定在某一点会相遇并且之后的链表重合，后面重合有个特点，节点数相等。也就是说要在某点相遇必定要链表后半段节点数相等，也就是前面可以有一个长度差不去扫描，从 “剩余共同长度“ 的位置开始，也就是跳过前一小段。两条链表一起扫描，避免了双层扫描。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode node1 = headA, temp; ListNode node2 = headB; int lenA = 0, lenB = 0, gap = 0; while(node1 != null){ lenA++; node1 = node1.next; } while(node2 != null){ lenB++; node2 = node2.next; } node1 = headA; node2 = headB; if(lenA \u0026lt; lenB){ node1 = headB; node2 = headA; } gap = Math.abs(lenA-lenB); while(gap-- \u0026gt; 0) node1 = node1.next; while(node1 != null \u0026amp;\u0026amp; node1 != node2){ node1 = node1.next; node2 = node2.next; } return node1; } }   142.环形链表II 两个重要点\n 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 快指针永远走的是慢指针的两倍长度。  解释一下：\n先判断有没有环，while 下 快指针走 2 步，慢指针走 1 步，如果两个结点 位置一致，即为有环，否则无环则一定会 fast.next || fast.next.next ==null。\n从头节点到环入口结点距离为 A，环入口节点到相遇结点正向距离为 B，相遇节点正向到入口节点距离为 C。一定是在环内相遇，且 A == C。\n~~为什么 (x + y) * 2 = x + y + n (y + z)，其中没必要纠结 y ≥ b+c 即圈长与否，也就是说走了多少圈的 y 都可以，因为 y+z 一定是整圈，因为 y 要么是 环入口到相遇点的距离 要么是 ~~ n*(y+z)+y ，总之会多余一个 y ，再加上 c 一定是整圈。\nfast在slow前面一步，那么下一步追上。\nfast在slow前面两步，那么下一步变成只差一步。\nslow 进 环入口走不到一圈一定会被追上，这种走一圈的极端条件 fast 走了两圈，而即使第一圈擦肩而过，第二圈也一定会相遇。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class Solution { public ListNode detectCycle(ListNode head) { if(head == null) return null; ListNode fast = head ,slow = head; while(fast.next != null \u0026amp;\u0026amp; fast.next.next != null){ fast = fast.next.next; slow = slow.next; if(slow == fast){//必定有环  fast = head; while(slow != fast){ slow = slow.next; fast = fast.next; } return slow; } } return null; } }   ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E9%93%BE%E8%A1%A8%E4%BA%8C/","summary":"203. 移除链表元素 思路：先处理头结点 null 或者 val ，再去处理移除节点。 注意：返回值返回 head。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode removeElements(ListNode head,","title":"LeetCode 链表（二）"},{"content":"最近学习 这个月效率不错，但也只是不错。反复有几天是真的厌恶自己学的东西，太tm抽象了。\n好在坚持下来了，操作系统 过完了，等轮询复习过来到时候再看。\n最近生活 anxious，麻木，幸福指数乱七八糟，疫情连续做25天核酸。\n在家确实可以安心好好学习，不会出去玩不会有人找，但是生活幸福指数还是乱七八糟，上个月经常出去觉得不出去学习就会很舒服。 现在仍然是天天醒来不愿意面对学习的东西，晚上潜意识想玩手机，但已经在逼自己睡觉了，想睡睡不着是真难受，听点相声真的会想起小时候捧着《XX动漫》的电视台看动漫版的相声，生活味十足，刚开始听能睡着，后来听着听着就跟着笑就睡不着， 听那种听不大懂的，连贯性强的《三体》能睡着，喜马拉雅 我真的是爱了。争做早睡早起好青年，杜绝熬夜，熬夜太伤了，自己脑子变笨都发现不了。\n8月 比较 7月 随想录二刷进度中规中矩，回溯马上刷完了，就是贪心、动归了，周赛都还行，2次1题，一次2题，一次ac三题，能稳定2题偶尔冲三题我就开心死了。\n操作系统整完了，细的地方真细，不懂的地方是真不懂，看10遍也不懂。效率比7月应该算稳健提高。\n9月计划 计网（两遍） 过完 + 代码随想录二刷彻底结束，并且开始（2 old + 1/2 new）模式。\n是1还是2看题目难度，第一题easy就必须要做第二题，每天要保证在算法上有深度思考。\n计网半个月过完第一遍（平均一天两篇）、第一遍适当快，第二遍必须深度思考。\n长期计划 首先 去做 \u0026raquo;（远大于） 计划。 just do it\n计网 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 + hot 100 \u0026ndash;\u0026gt; 四刷 + 剑指 offer（ACM模式）\n","permalink":"https://coderrenxy.github.io/posts/life/8%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 这个月效率不错，但也只是不错。反复有几天是真的厌恶自己学的东西，太tm抽象了。 好在坚持下来了，操作系统 过完了，等轮询复习过来到时候再","title":"8月总结"},{"content":"这周进度 都还好，操作系统上周定的目标太高了，也不算高，只是方向变了，想详细的再看一遍这一遍才是真正的学懂，才真正的静下心吸收进去了，以后学东西也要先大概过一遍再 detail，二叉树刚好刷完，没有超额没有未完成。\n下周计划  看完操作系统。 二刷刷完回溯（有点难，一天三题）。 周赛，明天周末打周赛。  本月  到结尾了已经，那就给下周开个好头吧。  ","permalink":"https://coderrenxy.github.io/posts/life/augest.no4-weekly-summary/","summary":"这周进度 都还好，操作系统上周定的目标太高了，也不算高，只是方向变了，想详细的再看一遍这一遍才是真正的学懂，才真正的静下心吸收进去了，以后学东","title":"Augest No.4 Weekly Summary"},{"content":"这周进度 都还好，有时候题目刷多一点，有时候操作系统看多一点，每天侧重点不同。\n有一点收获：前几天看操作系统都不顺利，突然有一天茅塞顿开，学的很专注。这种专注真的是可遇不可求，只能说边学边做笔记，带着自己大脑的索引能力去主动获取一个知识的相关信息，这样就算以后不看笔记，至少在学的这一刻，他让我印象深刻，也让我有了更好的理解。 文件系统、设备管理、调度算法都看了一遍，LC有时候一天5题有时候一天2题，还不错。还超额看了网络系统，这周看完了。\n下周计划  看完Linux命令。 二叉树刷完。 周赛，明天周末打周赛。 看视频的《操作系统》再复习书面知识。  本月 1. 一定要结束操作系统，开始计网的学习。 ","permalink":"https://coderrenxy.github.io/posts/life/augest.no3-weekly-summary/","summary":"这周进度 都还好，有时候题目刷多一点，有时候操作系统看多一点，每天侧重点不同。 有一点收获：前几天看操作系统都不顺利，突然有一天茅塞顿开，学的很","title":"Augest No.3 Weekly Summary"},{"content":"这周进度  每天2-3道以前刷过的 LC，有一天 hard 当天没写出来也没看懂题解，下一天写出来了，还写出一道 一刷 没写出来的题，但是是 暴力解 ，因为用大小顶堆的优先队列有的 API 不熟悉，而且不常用，用过一次又忘记，死循环。 Linux命令过完了，操作系统的面经看了进程管理，这周完成进程管理。  下周计划  完成内存管理、调度算法、文件系统。 二叉树刷一半以上。 周赛，明天周末打周赛，进程管理多过几遍。  本月 1. 一定要结束操作系统，开始多线程。发现操作系统进程管理和线程联系很深。\r2. 再来看操作系统和 jvm、redis、计网 哪个联系深。 ","permalink":"https://coderrenxy.github.io/posts/life/augest.no2-weekly-summary/","summary":"这周进度 每天2-3道以前刷过的 LC，有一天 hard 当天没写出来也没看懂题解，下一天写出来了，还写出一道 一刷 没写出来的题，但是是 暴力解 ，因为用大小顶","title":"Augest No.2 Weekly Summary"},{"content":"关于总结 周总结不谈生活，只谈学习进度，月总结、年度总结全维度谈。\n这周进度  每天2-3道以前刷过的 LC。 每天在学 Linux、刷题、以及学车。   Lunix：大概有了个框架，知道什么操作 属于 什么模块，然后对应去查命令，也安装了相关东西：centOs、VMWare、jdk、tomcat、mysql、xShell（据说finalShell更好）、xftp，明天是本周最后一天，完结 shell 编程。 算法：二刷LC，周末打周赛，一天2-3题，开学前完成二刷。  下周计划  Linux 刷完视频 并浏览相应的面经 并记录 Blog 。 11号考科二。 算法接着刷。  ","permalink":"https://coderrenxy.github.io/posts/life/augest.no1-weekly-summary/","summary":"关于总结 周总结不谈生活，只谈学习进度，月总结、年度总结全维度谈。 这周进度 每天2-3道以前刷过的 LC。 每天在学 Linux、刷题、以及学车。 Lu","title":"Augest No.1 Weekly Summary"},{"content":"最近学习 最开始学习效率有点低，后来非常重视这件事，白天学新知识，晚上刷 leetcode ，每天大概 2h-3h 的 leetcode，3h 左右的 Linux。\n最近生活 科二练的特别好，加了老顾的技术群，希望以后能擦出一点不一样的火花。\n学习的枯燥又无精打采的时候，就睡一觉，睡醒就好了。\n7月 比较 6月 随想录二刷进度中规中矩，学习Linux的速度没有想象那么快，但是也还好，总算开始学了点新东西。\n六月前半段都在 考升本 + 摆烂 + 回家 + 焦虑，后半段才刷题。\n七月考科目1练科目二 + Linux + 刷题。 效率比6月明显高了，大概每天有效学习时长 5-6h ，加上中间穿插摆烂看手机斗地主吃饭看b站的时间大概是10h，是个人看到这里都会想如果 10h 都在学习那效率多高啊。但人不是永动机啊，不保养就会消磨殆尽。\n8月计划 Linux 过完 + reids 过完基础篇进入到高级篇。\n长期计划 首先 去做 \u0026raquo; 计划。\n操作系统 \u0026ndash;\u0026gt; redis \u0026ndash;\u0026gt; 计网 \u0026ndash;\u0026gt; JVM \u0026ndash;\u0026gt; 并发\n算法一直刷\n算法思路：二刷 \u0026ndash;\u0026gt; 三刷 \u0026ndash;\u0026gt; hot 100 \u0026ndash;\u0026gt; 剑指 offer\n","permalink":"https://coderrenxy.github.io/posts/life/7%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近学习 最开始学习效率有点低，后来非常重视这件事，白天学新知识，晚上刷 leetcode ，每天大概 2h-3h 的 leetcode，3h 左右的 Linux。 最近生活 科二练","title":"7月总结"},{"content":"704. 二分查找 思路：首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-1，不然有的用例会超时，循环条件则是 right ≥ left 不然藏在边界的 target 就查不到了。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length-1, mid; while(right \u0026gt;= left ){ mid = (right-left)/2+left; if(target == nums[mid]) return mid; else if(target \u0026gt; nums[mid]) left = mid+1; else right = mid-1; } return -1; } }    27. 移除元素 暴力解法：需要注意，i\u0026ndash;；是因为既然当前值为 val 的点的右边所有点一切都左移了一位，所以现在的 i 指向的是已删除（被覆盖）的位置，该位置补了后面那位没被扫描的数字，而该次循环结束就要 i++了，所以会指向这个没扫描的下一个进行扫描，就漏掉一个了。还有一个就是无限循环容易发生是因为 for 循环条件不能是 \u0026lt; length。而应该是 \u0026lt; len 这个自定义的，会随着更新而更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public int removeElement(int[] nums, int val) { int len = nums.length; for(int i = 0; i \u0026lt; len; i++) if(nums[i] == val){ for(int j = i; j \u0026lt; len-1; j++) nums[j] = nums[j+1]; len--; i--; } return len; } }   快慢指针法：fast 位置是 val 值，就 fast++，不是 val 值就 nums[slow] = nums[fast]，slow 后移一位，为了不影响 非val 的值，并且slow可以计数（非 val 个数）。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int removeElement(int[] nums, int val) { int slow = 0, fast = 0; for(; fast \u0026lt; nums.length; fast++) if(nums[fast] != val){ nums[slow] = nums[fast]; slow++; } return slow; } }    977. 有序数组的平方 思路：暴力就是先平方再 arrays.sort( ); 但是时间复杂度为 O(n)+nlogn; 所以这么解不行，用双指针的方法要注意，一定要从两头找最大的放入新数组的最右侧，因为两头只能找最大，最小的有可能类似：{-3，0，3}，最小在中间。注意循环条件是 left ≤ right，而不是 left \u0026lt; right，因为有边界要处理。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int[] sortedSquares(int[] nums) { int left = 0, right = nums.length-1,i=nums.length-1; int[] array = new int[nums.length]; while(left \u0026lt;= right) if(nums[left]*nums[left] \u0026gt; nums[right]*nums[right]) array[i--] = nums[left]*nums[left++]; else array[i--] = nums[right]*nums[right--]; return array; } }    209. 长度最小的子数组 思路：滑动窗口，这样写法虽然时间复杂度是 O(n)，但是效率比另一种 O(n^2) 要低很多，另一种在 for 循环嵌套一个 while 循环，让达到 ≥ target 的 sum 一直减去 nums[left] ，而 sum 不需要反复初始化为 0. 注意循环自增 end。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //双指针 class Solution { public int minSubArrayLen(int target, int[] nums) { int begin = 0, end = 0, sum = 0, min = Integer.MAX_VALUE; for(; end \u0026lt; nums.length; end++){ sum += nums[end]; if(sum \u0026gt;= target){ min = Math.min(min,end-begin+1); sum = 0; end = begin; begin++; } } return min == Integer.MAX_VALUE ? 0 : min; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  //滑动窗口 class Solution { public int minSubArrayLen(int target, int[] nums) { int begin = 0, end = 0, sum = 0, min = Integer.MAX_VALUE; for(; end \u0026lt; nums.length; end++){ sum += nums[end]; while(sum \u0026gt;= target){ min = Math.min(min,end-begin+1); sum -= nums[begin++]; } } return min == Integer.MAX_VALUE ? 0 : min; } }    59. 螺旋矩阵 II 思路：\n 先模拟整个一圈的流程，再去写外层循环，循环次数可以由 n/2 来确定，但此时有个问题，n 为奇数则中间 array[n/2][n/2] 需要单独赋值，而 n 为偶数不需要。 还有在判断的时候很容易搞混什么适合走的是 x ，什么时候走的是 y。 在往内圈走的时候很容易碰到一个问题就是：n 需不需要 n\u0026ndash; ？其实设置一个偏移量 offset 就行了，因为如果 n— 那么在第三、四个循环解决不了少走一个格子的问题。 设置 startX、startY 是为了走下一圈的时候能顺利切换。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int[][] generateMatrix(int n) { int[][] array = new int[n][n]; int x, y, startX = 0, startY = 0, num = 1, circle = n / 2, offset = 0; while(circle-- \u0026gt; 0){ x = startX; y = startY; for(; y + offset \u0026lt; n-1; y++){ array[x][y] = num++; } for(; x + offset \u0026lt; n-1; x++){ array[x][y] = num++; } for(; y - offset \u0026gt; 0; y--){ array[x][y] = num++; } for(; x - offset \u0026gt; 0; x--){ array[x][y] = num++; } startX++; startY++; offset++; } if(n % 2 == 1)array[n/2][n/2] = num; return array; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E6%95%B0%E7%BB%84%E4%BA%8C/","summary":"704. 二分查找 思路：首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-","title":"LeetCode 数组(二)"},{"content":"01背包 509. 斐波那契数 1 2 3 4 5 6 7 8 9 10 11  class Solution { public int fib(int n) { if(n\u0026lt;2) return n; int[] dp = new int [n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } }    70.爬楼梯 思路：走第i层时，从i-1到i只有一种方法，从i-2到i也只有一种方法，所以从0到i-1到i有dp[i-1]种方法，从0到i-2到i有dp[i-2]种方法。所以从0到dp[i]有dp[i-2]+dp[i-1]种方法，所以dp[i]=dp[i-1]+dp[i-2]。其实也能转换为完全背包来做，物品分别是1，2。都可以无限次用。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int climbStairs(int n) { if(n\u0026lt;=2) return n; int [] dp = new int[n+1]; dp[1]=1;dp[2]=2; for(int i=3;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } }    746. 使用最小花费爬楼梯 思路：主要是dp数组如何构建。dp数组的含义是，从 i 跳走必须花 dp[i] 的钱，所以最后是只有三个数的话，要跳出这三个数：dp[2]=( dp[2-1] , dp[2-2] )+ cost[i] ；dp 数组初始化好直接返回就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public int minCostClimbingStairs(int[] cost) { if(cost == null || cost.length == 0) return 0; if(cost.length == 1) return cost[0]; int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for(int i = 2; i \u0026lt; cost.length; i++){ dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i]; } return Math.min(dp[cost.length - 1], dp[cost.length - 2]); } }    62.不同路径 思路：每个格子 i,j 都是从 i-1,j 或 i,j-1 走过来，所以 dp[ i ] [ j ] = dp[ i-1 ] [ j ] + dp[ i ] [ j - 1 ] ;上面、左边两行都要初始化为1，只能唯一，因为只有右移或者下移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int uniquePaths(int m, int n) { if(m \u0026lt;= 0 || n \u0026lt;= 0) return 0; if(m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for(int i=0;i\u0026lt;n;i++) dp[0][i]=1; for(int i=0;i\u0026lt;m;i++) dp[i][0]=1; for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++) dp[i][j] = dp[i-1][j]+dp[i][j-1]; } return dp[m-1][n-1]; } }    63. 不同路径 II 这次只出了一个越界，其它全对，思路也是自己的，直接AC，兴奋。\n思路：初始化要注意，只能向右👉，下👇走，所以在初始化第一行、第一列的时候如果遇见障碍物，该位置与后面所有直线位置dp[i][j] 都为0，注意初始化完成第一行、第一列，所以从 (1,1) 坐标开始初始化dp，否则就越界了。在其他位置遇见障碍物就直接 dp[i][j] = 0 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length,n = obstacleGrid[0].length; int[][] dp = new int[m][n]; int flag = 1; for(int i=0;i\u0026lt;m;i++){ if(obstacleGrid[i][0] == 1) flag = 0; dp[i][0] = flag; } flag = 1; for(int i=0;i\u0026lt;n;i++){ if(obstacleGrid[0][i] == 1) flag = 0; dp[0][i] = flag; } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } }    343. 整数拆分 思路：拆分成两个、两个或两个以上个、并更新以便取得最大值。初始化 dp[2]=1 .为什么？dp 数组是记录 i 值对应的最大《拆分积》。为什么内循环的条件是 j≤i-j ? 相当于剪枝操作， [ i-j , i ] 的数在 [0，i-j ] 已经乘过了，比如数字4， 1~4 是在1~2和2~4相乘，而不是两者相加=4。1~4和1~4会越界。\n主要代码：\n1  dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));   为什么需要dp[i]、j*(i-j)、jdp[i-j]取最大值，dp[i] 是为了取得最大值，因为dp[i]是多个比较的结果。而j(i-j)是两个数的乘积，经过循环就是求得其分为两数的最大值，jdp[i-j] 是拆分为两个以上，dp是i-j拆分为2+个数最大的积，那么是可能拆分为n个数的，会涵盖所有拆分可能，并剩余值。\n 96. 不同的二叉搜索树 思路：很抽象，先把0、1个节点只有一种可能确定好，再是从dp[2]、dp[3]来找递推公式。\ndp[2]在1为头结点时，只能2挂在右边这种可能，2为头结点时，只能1挂在左边，dp[2]=1+1=2 。\ndp[3]在1为头结点时，可以2、3依次深度排序，也可以1、3、2，所以两种可能。\ndp[3]在2为头结点时，只能左右分别挂一个，所以只有一种可能。\ndp[3]在3为头结点时，.类似1为头结点，两种可能。sum=2+1+2=5种可能。\ndp[3] 递推公式：\n1为头 sum+=dp[0]*dp[2]=2左孩子0个节点，右孩子2个节点。\n2为头 sum+=dp[1]*dp[1]=1，左右孩子分别1个。\n3为头 sum+=dp[2]*dp[0]=2，左孩子2个，右孩子一个。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public int numTrees(int n) { int[] dp = new int[n+1]; dp[0]=dp[1]=1; for(int i=2;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;=i-1;j++) dp[i]+=dp[i-j-1]*dp[j]; } return dp[n]; } }    416. 分割等和子集 思路：以01背包背包的思路，dp[ i ][ j ] 的 i 代表从0到i选择，j代表背包容量为j，dp[i][j] 代表这样的前置条件下最大能装下的值。\n主要还是数学逻辑：当背包容量为 sum/2 时，能在nums找到和为sum/2，也就是dp[ i ][ j ] =sum/2。就找到了，为什么？因为只要有和能为 sum 的一半，那么一定剩下的数字和一定也为 sum/2 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public boolean canPartition(int[] nums) { int sum = 0,target; for(int i=0;i\u0026lt;nums.length;i++) sum += nums[i]; if(sum % 2 == 1) return false; target = sum/2; int[][] dp = new int[nums.length][target+1]; for(int j = nums[0]; j \u0026lt;= target;j++) dp[0][j] = nums[0]; for(int i = 1;i \u0026lt; nums.length;i++){ for(int j = 1;j \u0026lt;= target;j++){ if(j \u0026gt;= nums[i]) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else dp[i][j] = dp[i-1][j]; } } return dp[nums.length-1][target] == target; } }    1049. 最后一块石头的重量 II 思路：还是跟上题一样，就是数学逻辑。用sum/2的容量来看最大能拿到多大，然后sum-max，也就是另一半的值，这两个值相减就出来了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int lastStoneWeightII(int[] stones) { int sum=0,target; for(int i:stones) sum += i; target=sum/2; int[][] dp = new int[stones.length][target+1]; for(int i=stones[0];i\u0026lt;target+1;i++) dp[0][i] = stones[0]; for(int i=1;i\u0026lt;stones.length;i++) for(int j=1;j\u0026lt;target+1;j++) if(stones[i] \u0026gt; j) dp[i][j] = dp[i-1][j]; else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]); return sum-dp[stones.length-1][target]-dp[stones.length-1][target]; } }   一维数组（滑动数组）：相当于二维 dp[ i ] [ j ] = dp[ i-1 ] [ j ] 直接省去这一步骤，而是直接把上一层拷贝下来。\n1 2 3 4 5 6  dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]); //变化 dp~~[i]~~[j] = Math.max(dp~~[i]~~[j],dp~~[i]~~[j-stones[i]]+stones[i]);把多行放在一行里面滑动操作了。 //简化 dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);   代码变为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i : stones) { sum += i; } int target = sum \u0026gt;\u0026gt; 1; //初始化dp数组  int[] dp = new int[target + 1]; for (int i = 0; i \u0026lt; stones.length; i++) { //采用倒序  for (int j = target; j \u0026gt;= stones[i]; j--) { //两种情况，要么放，要么不放  dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - 2 * dp[target]; } }   在内循环直接条件限制为 j ≥ stones 其实是像第一层初始化这样理解：装不下就不装，就不变，保持等于原来的dp[ j ]，也就是现在的dp[ j-1 ]。直接把二维数组时候的 if-else 省略了。\n 494. 目标和 思路：将这个数组分为两个子集：left、right，left+right=sum，left-right=target。两个方程相加2 * left=（sum+target）—\u0026gt; left=（sum+target）/ 2 。确定了左边就确定了右边，所以找到left 为总和的组合数为 n，整体组合数就是n。\n区别：与以前不同在于，求可能可能性的总数，前几道题是最大价值。都是01背包问题。主要区别在于循环体、初始化。\n  特殊情况1：容量为nums[0]：不放、放入nums[0]一共两种情况对吧? 错了，只能直接nums[0]\u0026ndash;\u0026gt;nums[0],在0-0这个区间只有 nums[i] 能放进去，那么只有恰好nums[0]=size时候这种放法。\n  特殊情况2：size为0时（初始化），此时就有“一种方法”就是“不放入”。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0, leftBagSize; for(int i:nums) sum += i; if( (sum + target) % 2 == 1) return 0; leftBagSize = Math.abs( (sum + target) / 2 ); //考虑负数  int[] dp = new int[leftBagSize+1];//这里不是最大价值，是组合个数。  //初始化  dp[0] = 1; for(int i = 0; i \u0026lt; nums.length; i++){ for(int j = leftBagSize; j \u0026gt;= nums[i]; j--){ //求的是总和（所有可能性）要把不+nums[i]的也算上  dp[j] += dp[j-nums[i]]; } } return dp[leftBagSize]; } }    474.一和零 思路：理解题意！找出并返回 strs 的最大子集的长度，最大子集指的是最长的子集长度，即最多可以包含几个字符串作为子集。那么dp[i][j] 也就是个三维的01背包，进一个字符串先判断几个 0 几个 1 。然后逆序遍历来更新值，从m，n开始，i≥one，是为了至少有这个容量来装，防止 max 里面 index = -1 越界，Math.max里面更新很巧妙，如果是去掉当前串的 01 个数，就是看此时（去当前串01）容量是否已经初始化过，即是否装过了，装过了还能装就是1+1=2次。如果没装过就是0+1，相当于初始化了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int [m+1][n+1]; for(String str:strs){ int zero = 0, one = 0; for(char ch:str.toCharArray()){ if(ch == \u0026#39;0\u0026#39;) zero++; else one++; } for(int i = m; i \u0026gt;= zero;i--) for(int j = n; j \u0026gt;= one; j--) dp[i][j] = Math.max(dp[i][j], dp[i-zero][j-one]+1); } return dp[m][n]; } }    完全背包 指的是物品可以无限次被使用，此时就是正序遍历，先遍历“物品”还是“背包”要看是 排列 还是 组合 ，组合 先 遍历 物品，因为这种遍历方式物品有先后顺序，而排列没有，则会打乱顺序还有结果。\n518. 零钱兑换 II 思路：完全背包问题（组合：无序）每个物品可以用无限次，正向遍历。容量为0的时候不放入也是一种方法。这样在以后j=coins[i]时可以dp[j]+=dp[j-coins[i]] 即dp[0] 即1；\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int change(int amount, int[] coins) { int[] dp = new int[amount+1]; dp[0] = 1; for(int i = 0; i \u0026lt; coins.length; i++){ for(int j = coins[i]; j \u0026lt;= amount; j++){ dp[j] += dp[j-coins[i]]; } } return dp[amount]; } }    377. 组合总和 Ⅳ 思路：求的是排列（强调顺序，不同顺序为不同排列），排列先遍历背包，再遍历物品。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target+1]; dp[0] = 1; for(int i = 0; i \u0026lt;= target; i++) for(int j = 0; j \u0026lt; nums.length; j++) if(i \u0026gt;= nums[j]) dp[i] += dp[i-nums[j]]; return dp[target]; } }    322. 零钱兑换 思路：满足条件的，最小硬币个数。无限使用 == 完全背包，求的是组合（不强调顺序）所以是先遍历物品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; int max = Integer.MAX_VALUE; int[] dp = new int[amount+1]; dp[0] = 0; for(int i=1; i\u0026lt;=amount; i++)//初始化  dp[i] = max; for(int i = 0; i \u0026lt; coins.length; i++) for(int j = coins[i]; j \u0026lt;= amount; j++) if(dp[j-coins[i]] != max) dp[j] = Math.min(dp[j-coins[i]]+1,dp[j]); return dp[amount] == max ? -1 : dp[amount]; } }    279.完全平方数 思路：完全背包，自己构建一个长度为 (int) Math.sqrt(n) 的物品数组，为什么？因为target最多被 sqrt(target) 平方出 target，而自己也要构建物品数组，i对应i*i ;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public int numSquares(int n) { int max = Integer.MAX_VALUE; int len = (int)Math.sqrt(n); int[] dp = new int[n+1]; dp[0] = 0; for(int i = 1; i \u0026lt;= n; i++) dp[i] = max; for(int i = 1; i \u0026lt;= len; i++) for(int j = i*i; j \u0026lt;= n; j++) if(dp[j-i*i] != max) dp[j] = Math.min(dp[j],dp[j-i*i]+1); return dp[n]; } } // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 2 3 1 2 3 4 2 3 4 5 3 // 0 1 2 3 1 2 3 4 2 1 2 3 3    139.单词拆分 思路：用字符串截取、List的contains方法来判断是否存在该截取的子串，存在且 d[j] 为 true 就 dp[i] = true .这样做的好处是每个位置每个子串都处理到了，而如果只移动i，等存在 并且 dp[i] = true 时，才移动j，那么在[\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;aaaa\u0026rdquo;] , s=\u0026ldquo;aaaaaaa\u0026rdquo; 这个测试用例就过不去，因为走的是两个aaa，剩下aa就走不动了。\n1 2 3 4 5 6 7 8 9 10  class Solution { public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { boolean[] dp = new boolean[s.length()+1]; dp[0] = true; for(int i = 1; i \u0026lt;= s.length(); i++) for(int j = 0; j \u0026lt; i; j++) if(wordDict.contains(s.substring(j,i)) \u0026amp;\u0026amp; dp[j]) dp[i] = true; return dp[s.length()]; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","summary":"01背包 509. 斐波那契数 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int fib(int n) { if(n\u0026lt;2) return n; int[] dp = new int [n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i\u0026lt;=n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n]; } } 70.爬楼梯 思路：走第i层时，从i-1","title":"LeetCode 动态规划"},{"content":"455.分发饼干 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count=0; for(int i=0,j=0;i\u0026lt;s.length \u0026amp;\u0026amp; j\u0026lt;g.length;i++){ if(s[i] \u0026gt;= g[j]){ count++; j++; } } return count; } }    376. 摆动序列 我的思路：直接改变数组比如4，3，4，5.只保留，4，3，5而把第三个4去掉，因为保留最高或者最低的那个更容易出现转折，最后保留下来的数组的长度就是返回值。不过这样坑多，可复用性差，下一次拿到题目抠细节抠到哭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public int wiggleMaxLength(int[] nums) { int len=nums.length; boolean flag1=true,flag2=true; for(int j=0;j\u0026lt;len-1 \u0026amp;\u0026amp; len\u0026gt;1;j++){ int t = nums[j+1]-nums[j]; if(t == 0){ cutArray(nums,j); len--; j--; continue; }else if(j%2 == 1){ if(t\u0026gt;0) flag1 = true; if(t\u0026lt;0) flag1 = false; }else{ if(t\u0026gt;0) flag2 = true; if(t\u0026lt;0) flag2 = false; } if(j == 0) continue; else if(flag1 == flag2){ cutArray(nums,j); len--; j--; } } return len; } public void cutArray(int[] nums,int index){ for(int i=index;i\u0026lt;nums.length-1;i++) nums[i] = nums[i+1]; } }   题解思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int wiggleMaxLength(int[] nums) { if(nums.length \u0026lt;= 1) return nums.length; int cur=0,pre=0,count=1; for(int i=0;i\u0026lt;nums.length-1;i++){ cur = nums[i+1]-nums[i]; if(cur\u0026gt;0\u0026amp;\u0026amp;pre\u0026lt;=0 || cur\u0026lt;0\u0026amp;\u0026amp;pre\u0026gt;=0){//总之cur必须!=0，pre可能是初始化的0，因为所有的cur都!=0，所以后面赋值到的pre也!=0  //这样比较就算持续3,7,4,5,6在最后比较的也是最后面那个偏差幅度最大的值6，最后有效是3，7，4，6.相比我之前的思想化繁为简。  pre = cur; count++; } } return count; } }    53.最大子序和 如果多个数相加\u0026lt;0，那就是累赘，和后面任何数相加只会让sum更小。所以从这个数后面的第一个数就要从0重新计算sum 。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int maxSubArray(int[] nums) { if(nums.length==1) return nums[0]; int sum = 0,max=nums[0]; for(int i=0;i\u0026lt;nums.length;i++){ sum+=nums[i]; if(sum\u0026gt;max) max=sum; if(sum\u0026lt;=0) sum=0; } return max; } }    122.买卖股票的最佳时机II nums[j+1]\u0026gt;nums[j]时就可以买卖了，局部最优，否则就移到下一位置。\n可能会有疑惑，5，3，7这样不就5，7也是盈利啊，但是3，7盈利更大呀，就算是3，5，7，在3买5卖，5买7卖其实结果也是一样。\n1 2 3 4 5 6 7 8 9 10  class Solution { public int maxProfit(int[] prices) { int sum=0,t; for(int i=0;i\u0026lt;prices.length-1;i++){ t=prices[i+1]-prices[i]; if(t\u0026gt;0) sum+=t; } return sum; } }    55.跳跃游戏 局部最优这句话怎么利用？\n覆盖范围，在第一个位置的覆盖范围内可到达的最远地方。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public boolean canJump(int[] nums) { if(nums.length==1) return true; int range = nums[0]; for(int i=0;i\u0026lt;=range;i++){ if(nums[i]+i \u0026gt; range) range=nums[i]+i; if(range \u0026gt;= nums.length-1) return true; } return false; } }    45.跳跃游戏II 这道题我有个疑问就是，当前最远、下一步最远 如何保证下一步到最远不是到一个为0的数，到了为0是不是就动不了，其实不是的，这是《当前范围》《可能的下一步的所有最远范围》然后 curRange = nextRange ，这样nextRange又在更新，局部最优转换为了全局最优。\n主要链路是不断比较计算总结出curRange可以到达的最远距离。coding时注意在curRange最后一位：curRange=nextRange；还有循环终止条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int jump(int[] nums) { if(nums.length==1) return 0; int curRange=nums[0],nextRange=nums[0],count=1; for(int i=0;i\u0026lt;=curRange\u0026amp;\u0026amp;curRange\u0026lt;nums.length-1;i++){ if(nums[i]+i\u0026gt;nextRange) nextRange=nums[i]+i; if(i==curRange) { curRange=nextRange; count++; } } return count; } }    1005.K次取反后最大化的数组和  绝对值排序 0-len将负数取反，如果全是正书，不管一开始就是还是处理完才是，在绝对值最小位置反复取反。 求和  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int largestSumAfterKNegations(int[] nums, int k) { int sum=0,temp; for(int i=0;i\u0026lt;nums.length;i++)//给绝对值排序  for(int j=i+1;j\u0026lt;nums.length;j++) if(Math.abs(nums[j])\u0026gt;Math.abs(nums[i])){ temp=nums[j]; nums[j]=nums[i]; nums[i]=temp; } for(int i=0;k\u0026gt;0;i++){//处理k次  //先判断是否到最末位置，再判断当前位置是否为负数。不然可能最末尾为负数，那就越界。 因为i没有-1.  if(i==nums.length-1){ nums[i]=-nums[i]; i--; k--; } if(nums[i]\u0026lt;0){ nums[i]=-nums[i]; k--; } } for(int i=0;i\u0026lt;nums.length;i++)//求和  sum+=nums[i]; return sum; } }    134.加油站 暴力解法（我的）：双重for，外层控制开始的位置，内层判断是否能成功走一圈。\n注意：要在外循环内进行剪枝，不然会超时，但是效率尽管如此，双重循环效率依旧很低。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { for(int i=0;i\u0026lt;cost.length;i++){//起始位置全轮一遍  int sum=gas[i],count=1; if(gas[i]==0) continue; for(int j=i;cost[j]\u0026lt;=sum;j++){ if(j==cost.length-1){ sum=sum+gas[0]-cost[j];//s=8+1-2=7,  count++; j=-1; }else{ sum=sum+gas[j+1]-cost[j]; count++; } if(count\u0026gt;cost.length) return i; } } return -1; } }    135.分发糖果 注意：评分更高的糖果多（\u0026gt;），如果相等就算\u0026lt;\n两次循环，第一次从左到右，第二次从右到左。\n第一次处理逻辑：从1开始，如果a[i]\u0026gt;a[i-1]，那么a[i]=a[i-1]+1，否则就a[i]=1\n第二次处理逻辑：从length-2开始，如果a[i]\u0026gt;a[i+1]那就比较sweet[i]、sweet[i+1]+1，取大的赋值给a[i]，以此保证规则。\n左—\u0026gt;右 ：\n 如果评分是1,2,3 糖果分别是1，2，3 如果评分是2,1,3 糖果分别是1，1，2 （有问题） 如果评分是3,2,1 糖果分别是1，1，1 （有问题） 如果评分是3,1,2 糖果分别是1，1，3 （有问题）  右—\u0026gt;左：\n 如果评分是1,2,3 糖果分别调整为1，2，3 如果评分是2,1,3 糖果分别调整为2，1，2 如果评分是3,2,1 糖果分别调整为3，2，1 如果评分是3,1,2 糖果分别调整为2，1，2  整体过程分别从左到右、从右到左保证评分的规则性，第一遍可能使得做边不规则（a[len-1]肯定规则），第二遍可能使得右边不规则（a[0]肯定规则）。一个是从1开始，和i-1比较，一个是len-1开始，和i+1，分别向左和向右比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int candy(int[] ratings) { if(ratings.length\u0026lt;=1) return ratings.length; int count=0; int[] sweet = new int[ratings.length]; sweet[0]=1; for(int i=1;i\u0026lt;ratings.length;i++){ if(ratings[i]\u0026gt;ratings[i-1]) sweet[i]=sweet[i-1]+1; else sweet[i]=1; } for(int i=ratings.length-2;i\u0026gt;=0;i--){ if(ratings[i]\u0026gt;ratings[i+1]) sweet[i]=Math.max(sweet[i],sweet[i+1]+1); } for(int i:sweet) count+=i; return count; } }    406.根据身高重建队列 先按照身高来排（高—\u0026gt;低），再按照前面比他高的人数（少—\u0026gt;多），遵循这两个规律来排序，再依次按照“前面有几个人”来当索引插入到LinkedList。\nlamada表达式排序的写法：Arrays.sort(数组名,(a,b)→{return \u0026gt;0的值就交换，反之则不})；\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public int[][] reconstructQueue(int[][] people) { Arrays.sort(people,(a,b)-\u0026gt;{ if(a[0]==b[0]) return a[1]-b[1]; return b[0]-a[0]; }); LinkedList\u0026lt;int[]\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); for(int[] p:people) linkedList.add(p[1],p); return linkedList.toArray(new int[people.length][]); } }    452.用最少数量的箭引爆气球 主题思路：先按左/右排序好，然后在循环里判断：\n 如果第二个数组的左边界 ≤ 第一个数组的右边界，则这两个有重合，就不需要++一支箭，而且这里一个关键就是：把此时的第二个数组的右边界换成两数组交集的右边界，不然下一次判断如果是和上一个数组重合，那么还需判断是否和上上个数组重合。否则就是count++；  注意：排序过程不能用Arrays.sort( points,(a,b)→{return a-b;} ); 因为最近先加的测试用例差值太大。所以用Arrays.sort( points,(a,b) → Integer.compare(a,b) );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public int findMinArrowShots(int[][] points) { if(points.length==0) return 0; Arrays.sort(points, (o1,o2) -\u0026gt; Integer.compare(o1[0],o2[0])); int count=1; for(int i=1;i\u0026lt;points.length;i++){ if(points[i][0]\u0026lt;=points[i-1][1]){ points[i][1]=Math.min(points[i][1],points[i-1][1]); }else count++; } return count; } }    435.无重叠区间 跟上一题类似，都是更新边界值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals,(a,b)-\u0026gt;{ if(a[0]==b[0]) return a[1]-b[1]; return a[0]-b[0]; }); int count=0; for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026lt;intervals[i-1][1]){ count++; intervals[i][1]=Math.min(intervals[i][1],intervals[i-1][1]);//更新右边界，避免反复比较死去的区间（右补集）  } } return count; } }    763.划分字母区间 思路：把每个字符最后出现的索引位置放在一个数组，如果在某个字符区间出现一个字符的右区间超过该字符的右区间，则刷新右区间，如果当前索引达到了右区间，就add，再把计数器归0；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public List\u0026lt;Integer\u0026gt; partitionLabels(String s) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); char[]ch=s.toCharArray(); int[] count= new int[26]; for(int i=0;i\u0026lt;s.length();i++){ count[ch[i]-\u0026#39;a\u0026#39;]=i; } int first=0,sum=1; //为什么额外定一个sum？因为first可能碰到这个情况：  //一个字符区间内的一个字符超出这个区间，那么 first 就变了，随之 last-first+1 的数值也变了。sum来计数是一个补救措施  for(int i=0;i\u0026lt;s.length();i++){ if(count[ch[first]-\u0026#39;a\u0026#39;]==i){ list.add(sum); first=i+1; sum=0;//初始化是1，这里是0因为后面也会++；  }else if(count[ch[i]-\u0026#39;a\u0026#39;]\u0026gt;count[ch[first]-\u0026#39;a\u0026#39;]){ first=i; } sum++; } return list; } }    56.合并区间 思路：先按边界排序，把其add到linkedlist中，然后每次都判断最后一个元素和当前循环到的节点是否有交集，如果有就把他们的并集顶替掉list中的最后那个元素，否则就add。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public int[][] merge(int[][] intervals) { if(intervals.length\u0026lt;=1) return intervals; LinkedList\u0026lt;int[]\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); Arrays.sort(intervals,(a,b)-\u0026gt;{ // if(a[0]==b[0]) return a[1]-b[1];  return a[0]-b[0]; }); list.add(intervals[0]); int[] temp=new int[2]; for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026lt;=list.getLast()[1]){ temp=list.removeLast(); list.add(new int[]{Math.min(intervals[i][0],temp[0]),Math.max(temp[1],intervals[i][1])}); }else{ list.add(intervals[i]); } } return list.toArray(new int[list.size()][2]); } }    738.单调递增的数字 思路：先将其转换为字符数组，不要按数字来遍历，而是利用字符，如果4512，那么4499就是最大，规律就是，当前位置如果\u0026lt;上一位，即这两个位置非递增，那左边的应该-1，其右边全要变成9，因为全部要变9，所以先记录并更新最前变9的位置，最后一次性改变。但是必须将非递增的左边位置一直-1，不然比如332，会变成329，因为332中33两位置相等，右边的3并未更新为2，更新完了就可以了。\n注意：另外避免标识的last未使用误用导致错误（定义在【0，len-1】），或者太小(-1)导致越界，所以应将last定义为 ≥len 。\nString str = String.valueOf(任何类型); ：将任何类型转换为字符串类型；\nInteger.parseInt(字符串) ：字符串类型—\u0026gt;基本数据类型int\n类似的：Double.parseDouble(字符串)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public int monotoneIncreasingDigits(int n) { String str = String.valueOf(n); char[]ch=str.toCharArray(); int last=ch.length; for(int i=ch.length-2;i\u0026gt;=0;i--){ if(ch[i+1]\u0026lt;ch[i]){ ch[i]--; last=i+1; } } for(int i=ch.length-1;i\u0026gt;=last;i--) ch[i]=\u0026#39;9\u0026#39;; return Integer.parseInt(String.valueOf(ch)); } }    714.买卖股票的最佳时机含手续费 主体思路都在注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int maxProfit(int[] prices, int fee) { int sum=0,buy=prices[0]+fee; for(int p:prices){ if(p\u0026gt;buy){ sum += p-buy;//交易状态中有fee会减掉（得到纯利润）。交易完成状态：是把上一次交易提高利润的情况下就不减掉fee；  buy = p;//交易状态：留出这次交易卖出价格以便下次可以在交易完成状态提高利润。  } if(p+fee\u0026lt;buy){//交易状态：如果买入比上一次买入便宜，就重新买入。 交易完成状态：  buy=p+fee; } } return sum; } }    968.监控二叉树 摆烂卒\u0026hellip;\u0026hellip;\n二刷见\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E8%B4%AA%E5%BF%83/","summary":"455.分发饼干 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count=0; for(int i=0,j=0;i\u0026lt;s.length \u0026amp;\u0026amp; j\u0026lt;g.length;i++){ if(s[i] \u0026gt;= g[j]){ count++; j++; } } return count; } } 376. 摆动序列 我的思路：直接改变数组比如4","title":"LeetCode 贪心"},{"content":"最近的生活 科目一一把过，科目二练完了。都忘了更新blog，学习状态很一般，一天大概4小时的集中学习时间，其他时间都在一些琐事，摆烂。\n最近的学习 代码随想录一刷结束。\n近期计划 7.26，7.27 两天迅速过完 操作系统 基础部分，再三天迅速过完 redis 基础。总之这个月结束这两门的基础部分。\n长期计划列表 redis、操作系统、JVM、并发、计网、设计模式。\n算法持续刷。\n","permalink":"https://coderrenxy.github.io/posts/life/july.no2-weekly-summary/","summary":"最近的生活 科目一一把过，科目二练完了。都忘了更新blog，学习状态很一般，一天大概4小时的集中学习时间，其他时间都在一些琐事，摆烂。 最近的学","title":"July No.2 Weekly Summary"},{"content":"最近的生活 6.28查到自己成绩，就知道稳稳的升本上岸了，随之而来的喜悦没有想象的那么多，而是更多对未来的焦虑，路比以前宽了，选择性更多导致不确定也越多了。\n报名了驾考，12号考科一，现在大概是被考试到疲倦了，总觉得自己必挂。\n最近的学习 知道升本成功，在5号正式出了预录取名单，也算是没停一直在刷题，现在终于刷到了动态规划，被动态规划狠狠的摩擦了，这段明明我在努力反复尝试他，打败它这段时间明明在努力，但感觉没有进度但是又有在努力，相当于一个缓冲期，这段时间更焦虑。\n这件事引出一个话题：关于焦虑，有一句话是这么说的：世界上最美妙最值得挑战却最让人胆怯的就是不确定性，焦虑正是对不确定的恐惧。\n关于焦虑 其实我一直在焦虑，只是一直在换焦虑的目标，容貌焦虑，对未来的焦虑，对任何主观问题或者不确定性都焦虑，而每每这个时刻来临，我选择摆烂，有时候我也选择过去面对，但是还没坚持到有所研究，就走出来了，然后是周而复始的 焦虑\u0026ndash;\u0026gt;摆烂\u0026ndash;\u0026gt;走出焦虑\n很难去真正看一些相关的书去和它“握手”，我知道适度的焦虑可以带给我进步，而过度焦虑会造成精神内耗。但任何事情不都是这个度掌握不了吗。\n近期计划 本月做完动态规划，完成代码随想录一刷，考过科一。\n暑假计划 计网、操作系统、Redis、并发、JVM 学点皮毛，为以后深入学习打基础，并二刷代码随想录。\n","permalink":"https://coderrenxy.github.io/posts/life/july.no1-weekly-summary/","summary":"最近的生活 6.28查到自己成绩，就知道稳稳的升本上岸了，随之而来的喜悦没有想象的那么多，而是更多对未来的焦虑，路比以前宽了，选择性更多导致不","title":"July No.1 Weekly Summary"},{"content":"最近 没更新的两个月一直在准备升本，复习，写题，考试。\n考完之后一直在焦虑万一没考上怎么办，其实并没必要，没考上立马出去找工作就行了，挂个成人本科，准备专升硕，没上岸就等2.5年后本科证下来再考研，不要985、211，只要上岸摆脱专科学历我就知足，年龄大也没办法，专科身份毕竟难走远， 我也不是什么技术强到炸裂的大牛。\n说回根本我焦虑的起因是想得太长远，没出分数怕自己考的差，出了分怕自己没被录取，考上了又要拼死学几年而且又得伸手问家里要钱，没考上压力大，进入社会并没有准备好。\n考上后计划 1刷代码随想录 \u0026ndash;\u0026gt; 边二刷边学计网 \u0026ndash;\u0026gt; 边二刷边学操作系统 \u0026ndash;\u0026gt; 边二刷边学redis \u0026ndash;\u0026gt; 边二刷边学JVM、多线程、设计模式 \u0026ndash;\u0026gt; 边刷题边做项目\n落榜后计划 去深圳找工作 \u0026ndash;\u0026gt; 边学上面的东西边工作（很辛苦）\n总结 其实两种都有好处，现在的心态在学校也不适合，在学校也会课太多不适合学习，出来攒两年经验升硕毕业，硕士毕业两年工作经验直接无敌。还能攒点钱自己交学费，但是很辛苦。又要学专业课又要学考研课，各种没学过的高数、政治、计组。\n直接升本再出来工资可能能翻专科出来2-3倍，而且没有后续的考研压力。直接面对生活，也不赖。\n","permalink":"https://coderrenxy.github.io/posts/life/6%E6%9C%88%E6%80%BB%E7%BB%93/","summary":"最近 没更新的两个月一直在准备升本，复习，写题，考试。 考完之后一直在焦虑万一没考上怎么办，其实并没必要，没考上立马出去找工作就行了，挂个成人本","title":"6月总结"},{"content":"77. 组合 思路：分为终止条件、单层逻辑两层。\n 终止条件：当长度为 k 就 new 这个 List 并 add 进去并 return。 单层逻辑：for 嵌套 add、递归、remove。  question：\n 为什么要 for：如果没有，找到第一个符合条件的组合就层层 remove 了。 for 的结束条件控制的是什么：控制当前层的可选个数。i \u0026lt; n - (k - path.size()) + 1 可以当作 i \u0026lt; n - k + 1看待，在第一层可选择的个数就是 n-k+1，因为考虑到后面要跟元素，所以要留 k-1 个位置，第二层要为下一层留位置，所以可选项反而多了，预留 k-2个位置就行，可选项为 n-(k-1)+1。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { if(k \u0026gt; n) return null; dfs(1,n,k); return list; } public void dfs(int start,int n,int k){// n 个里面取 k 个  //终止条件  if(k == path.size()){//层数/深度限定在此  list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(; start \u0026lt;= n-(k-path.size())+1; start++){//循环才能出多个结果，不然直接找到就remove多层。  path.add(start); dfs(start+1,n,k); path.remove(path.size()-1); } return; } }    216.组合总和III 思路：回溯做法，集合就是 1-9 九个数字里面取，递归终止条件是 size == k \u0026amp;\u0026amp; sum == n\n注意：一定要加一个 if（sum\u0026gt;n || path.size()\u0026gt;k）return; 不然会超时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { if(k\u0026gt;n) return list; dfs(1,k,n,0); return list; } public void dfs(int start,int k,int n,int sum){ if(sum == n \u0026amp;\u0026amp; k == path.size()){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } if(sum \u0026gt;= n || k \u0026lt;= path.size()) return; for(;start\u0026lt;=9-(k-path.size())+1;start++){ sum += start; path.add(start); dfs(start+1,k,n,sum); sum -= start; path.remove(path.size()-1); } return; } }    17.电话号码的字母组合 思路：递归层数（深度）就是号码字符串长度，递归层度由递归终止条件控制，for 循环控制的次数是当前号码字符串中数字对应的字母映射。把一个数组的 index 和 content 作为 号码数字 和 字母的映射。用到 Stringbuilder、charAt、deleteCharAt、toString、append.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String nums[] = {\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;,\u0026#34;pqrs\u0026#34;,\u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;}; StringBuilder sb = new StringBuilder(); public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if(digits.length() == 0 || digits == null) return list; backTracking(digits,0); return list; } public void backTracking(String digits,int index){ //深度由递归终止条件控制  if(sb.length() == digits.length()){ list.add(sb.toString()); return; } for(int i=0;i\u0026lt;nums[digits.charAt(index)-\u0026#39;0\u0026#39;].length();i++){ sb.append(nums[digits.charAt(index)-\u0026#39;0\u0026#39;].charAt(i)); backTracking(digits,index+1); sb.deleteCharAt(sb.length()-1); } return; } }    39. 组合总和 莽夫思路：直接回溯。\n优化思路：先排序，在 for 中 add 之前判断如果要 add的数 + sum \u0026gt; target，就 break，因为后面只会越来越大。\n注意：循环条件赋初值给上次用完的数，这样就是把上次用的重复用了，如果赋初值为 0，那么会出现同一个组合的不同排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int sum = 0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); if(candidates == null || candidates.length == 0) return list; getPaths(candidates,target,0); return list; } public void getPaths(int[] candidates, int target,int index){ //终止条件  if(sum == target){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(int i=index;i\u0026lt;candidates.length;i++){ if(sum + candidates[i] \u0026gt; target) break; path.add(candidates[i]); sum += candidates[i]; getPaths(candidates,target,i); path.remove(path.size()-1); sum -= candidates[i]; } return; } }    40.组合总和II 思路：和39差的就是要去重，这里的去重指的是同一递归层的去重，绝不能和其他层关联，否则会少结果集。\n注意：千万不要把去重的 if 里的 i\u0026gt;index 写作 i\u0026gt;0，这样只会保证不越界，但是每次都会把两层之间的数去重，而 i\u0026gt;index 则恰好不越界不影响其他层。还有传入递归的 index 位置的不是 index+1，而是 i+1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int sum = 0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { if(candidates == null || candidates.length == 0) return list; Arrays.sort(candidates); getPaths(candidates,target,0); return list; } public void getPaths(int[] candidates, int target,int index){ //结束条件  if(target == sum){ list.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //单层逻辑  for(int i=index;i\u0026lt;candidates.length \u0026amp;\u0026amp; sum + candidates[i] \u0026lt;= target;i++){ if(i \u0026gt; index \u0026amp;\u0026amp; candidates[i-1] == candidates[i]) continue; path.add(candidates[i]); sum += candidates[i]; getPaths(candidates,target,i+1); path.remove(path.size()-1); sum -= candidates[i]; } return; } }    131.分割回文串 思路：\n 写出判断回文串的方法（把字符串，首尾切割位置传过去最优）。 递归单层逻辑：外层 for 循环囊括所有可能第一切割位置、第n次切割位置，递归切下去，如果是回文串就 add 否则 continue以确保每个 add 的都是回文串。 终止条件：当切割起始位置 index == 长度（末尾索引+1）  代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { backTracking(s,0); return list; } public void backTracking(String s,int begin){ if(begin == s.length()){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); return; } for(int i=begin;i\u0026lt;s.length();i++){ if(isPalindrome(s,begin,i)) listSon.add(s.substring(begin,i+1)); else continue; backTracking(s,i+1); listSon.remove(listSon.size()-1); } return; } public boolean isPalindrome(String s,int begin,int end){ for(int i=begin,j=end;i\u0026lt;j;i++,j--) if(s.charAt(i)!=s.charAt(j)) return false; return true; } }    93.复原IP地址 这题主要是\u0026quot;.\u0026quot;、如何确保是四串，这两个问题可以合成一个，就是通过\u0026quot;.\u0026ldquo;的数量来知道是否已经4串。\n还有就是：怎么才是合法的串？0不能开头，除非它是一个独立的0，范围要在0-255，而且只能是数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Solution { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { if(s.length() \u0026gt; 12) return result; backTrack(s,0,0); return result; } public void backTrack(String s,int startIndex,int pointNum){ if(pointNum == 3){ //.的个数  if(isValid(s,startIndex,s.length()-1)) {result.add(s);} return; } for(int i=startIndex;i\u0026lt;s.length()-3+pointNum;i++){ if(isValid(s,startIndex,i)){ s = s.substring(0,i+1)+\u0026#34;.\u0026#34;+s.substring(i+1); pointNum++; backTrack(s,i+2,pointNum); s = s.substring(0,i+1)+s.substring(i+2); pointNum--; } else {break;} } } public Boolean isValid(String s,int begin,int end){ if(begin \u0026gt; end) return false; int num = 0; if(s.charAt(begin) == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; begin != end) return false;//0不能开头，可当一个数字单独存在；  for(int i=begin;i\u0026lt;=end;i++){ if(s.charAt(i)\u0026gt;\u0026#39;9\u0026#39; || s.charAt(i)\u0026lt;\u0026#39;0\u0026#39;) return false; num = (s.charAt(i)-\u0026#39;0\u0026#39;)+num*10; if(num \u0026gt; 255) return false; } return true; } }    78.子集 主要是每一次进回溯都new一个List，反正集合没有重复元素，正常回溯足够解题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backTrack(nums,0); return list; } public void backTrack(int nums[],int begin){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); for(int i=begin;i\u0026lt;nums.length;i++){ listSon.add(nums[i]); backTrack(nums,i+1); listSon.remove(listSon.size()-1); } return; } }    90.子集II 跟上一个子集差别就是List\u0026lt;List\u0026gt;去重以及还有一个在用nums前先sort，因为乱序可能导致[1,4] 和 [4,1] 无法去重。比如nums={4，1，4}，就会出现这种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; listSon = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); backTrack(nums,0); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(List i:set) list.add(i); return list; } public void backTrack(int[] nums,int begin){ set.add(new ArrayList\u0026lt;\u0026gt;(listSon)); for(int i=begin;i\u0026lt;nums.length;i++){ listSon.add(nums[i]); backTrack(nums,i+1); listSon.remove(listSon.size()-1); } return; } }    46.全排列 主要是每次从0开始，用LinkedList作子list方便使用contains方法，当子list包含该元素时就continue，否则就正常回溯。或者用used数组来标识是否已经存在当前元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; listSon = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { backTrack(nums); return list; } public void backTrack(int[] nums){ if(nums.length == listSon.size()){ list.add(new ArrayList\u0026lt;\u0026gt;(listSon)); return; } for(int i=0;i\u0026lt;nums.length;i++){ if(listSon.contains(nums[i])) continue; listSon.add(nums[i]); backTrack(nums); listSon.remove(listSon.size()-1); } } }    47.全排列 II 和 全排列I 一样的处理逻辑，但是用used数组做，因为有重复元素，数组只看下标是否被使用，而contains看包不包含这个元素值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); boolean[] used; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { if(nums.length == 0) return null; used = new boolean[nums.length]; backTrack(nums); return new ArrayList\u0026lt;\u0026gt;(set); } public void backTrack(int[] nums){ if(list.size() == nums.length){ set.add(new ArrayList\u0026lt;\u0026gt;(list)); return; } for(int i=0;i\u0026lt;nums.length;i++){ if(used[i]) continue; used[i] = true; list.add(nums[i]); backTrack(nums); list.remove(list.size()-1); used[i] = false; } } }    图论 hard 332.重新安排行程 \u0026amp;\u0026amp; 37. 解数独 \u0026amp;\u0026amp; 第51题. N皇后\n不太清楚图，不大理解题意。卒\u0026hellip;\u0026hellip;\n 持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E5%9B%9E%E6%BA%AF/","summary":"77. 组合 思路：分为终止条件、单层逻辑两层。 终止条件：当长度为 k 就 new 这个 List 并 add 进去并 return。 单层逻辑：for 嵌套 add、递归、remove","title":"LeetCode 回溯"},{"content":"抽象类 抽象类是特殊的类，只是不能被实例化，天生就是要被继承的；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们 抽象方法必须用abstract关键字进行修饰。\n抽象类的特点  不能被直接实现，只能先被继承再间接实现。 子类必须实现父类的抽象方法，除非子类也是抽象类。 其中的方法只能是被 public（默认）、protected 声明。 含有抽象方法一定是抽象类，但抽象类不一定含有抽象方法。  接口 接口其实也是一种抽象，比抽象更抽象，其中的方法被隐式的指定为了 abstract 就有体现，接口是对行为的抽象。在 JDK1.8 前都是不能有任何具体方法实现，所以其中是抽象方法。\n接口的特点  支持多继承，一个接口可以 extends 多个接口，间接解决了 Java 单继承的问题。 一个类可以实现多个接口。 接口中的变量被隐式的指定为了public static final，方法隐式指定为public abstract（JDK1.8之前）。 JDK1.8 之前不能有静态方法和具体实现的方法，但是 JDK1.8 开始就可以有静态方法和具体的实现方法（默认方法 default）。 JDK1.8 后 static 可以单独修饰一个方法，也就是接口静态方法，接口名.方法名() 调用。  业务场景下的选择  如果使用接口的业务下，需要不断改变基本功能，那么就需要改变所有实现了该接口的类，但如果使用抽象类，可以达到解耦目的。 如果想实现多继承，那么必须使用接口。由于Java不支持多继承，即一个类 只能有一个超（父）类。但是，可以实现多个接口，因此可以使用接口来解决它。  版本变化 Java语言的版本升级过程中，接口和抽象类都有了一些变化。以下是主要的一些变化：\n  默认方法（default method）：从Java 8开始，接口可以定义默认方法，也称为扩展方法或带有默认实现的方法。这些方法具有默认的实现代码，可以被接口的所有实现类共享。默认方法可以通过在接口中使用default关键字来定义，实现类可以选择性地重写默认方法。\n  静态方法（static method）：从Java 8开始，接口可以定义静态方法。这些方法与类的静态方法类似，不依赖于接口的实现类，可以直接通过接口名调用。\n  私有方法（private method）：从Java 9开始，接口可以定义私有方法。这些方法只能在接口内部调用，无法被实现类或其他类调用。\n  非抽象方法（non-abstract method）：从Java 9开始，抽象类可以定义非抽象方法。这些方法可以有具体的实现代码，不再需要在子类中实现。\n   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"抽象类 抽象类是特殊的类，只是不能被实例化，天生就是要被继承的；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的","title":"接口和抽象的区别"},{"content":"我的进度 已完成 Spring \u0026mdash;\u0026mdash;-\u0026gt; Mybatis \u0026mdash;\u0026mdash;-\u0026gt; Spring MVC \u0026mdash;\u0026mdash;-\u0026gt; 异常 \u0026mdash;\u0026mdash;-\u0026gt; Java基础 \u0026mdash;\u0026mdash;-\u0026gt; 集合 \u0026mdash;\u0026mdash;-\u0026gt; 进行中 MySQL\n待完成  \u0026mdash;\u0026mdash;-\u0026gt; Redis \u0026mdash;\u0026mdash;-\u0026gt; 计网、操作系统、多线程\n","permalink":"https://coderrenxy.github.io/posts/life/%E5%87%86%E5%A4%87%E8%BF%9B%E5%BA%A6/","summary":"我的进度 已完成 Spring \u0026mdash;\u0026mdash;-\u0026gt; Mybatis \u0026mdash;\u0026mdash;-\u0026gt; Spring MVC \u0026mdash;\u0026mdash;-\u0026gt; 异常 \u0026mdash;\u0026mdash;-\u0026gt; Java基础 \u0026mdash;\u0026mdash;-\u0026gt; 集合 \u0026mdash;\u0026mdash;-\u0026gt; 进行中 MySQL 待完成 \u0026mdash;\u0026mdash;-\u0026gt; Redis \u0026mdash;\u0026mdash;-\u0026gt; 计网、操作系统、多线程","title":"进度"},{"content":"前言 每个人都有适合自己的作息，不用随大流，找到自己的生活、学习节奏就好。\n第一更 我的一天 第一次找到不用依靠外界环境逼迫性学习的时间规律是：23点-次日5点学习，一觉睡到13点，躺着刷会手机就15点，然后慵懒的起床吃饭，这里有个习惯就是，一定是看剧下饭！\n白天总是不想学习，在晚上昏暗、安静、手机不可能弹出会话框的时候是最适合我的学习时间。\n再之后就是回到学校，不能再阴间作息于是逼迫自己白天学习，晚上摆烂+睡觉，出现很严重的效率问题：静不下来。\n对我来说，白天很难学下去，白天的学习只能有外界压迫。但是最近发现一件事：刚起床那会很容易进状态，只要起床不看手机不刷快餐短视频，一天的节奏还没有被加速。\n所以我现在每天起床，什么都不管不干，只学习，学到吃午饭就是分水岭了，午饭一吃，心思全无，状态低迷，什么都没有心思一样，等天暗下去慢慢就好了。\n我的期望 找到办法让自己白天能更好的进入状态。\n我的进度 准备面试中\u0026hellip;\u0026hellip;\n第二更 新的节奏 其实是走了实习休息期的老路：晚上学习，白天睡觉，实在改变不了一到下午疯狂焦虑、内耗，所以只能适配自己。\n中午醒来的仍然是学习状态好的时候，然后一过19：00（昼长夜短的夏天），又是好的状态。效率指数倍提升。\n可以尝试的方法 因为醒来比较适合学习，如果一定要规律白天学习的作息，可以中午睡午觉，一觉起来在学习，可能可以解决焦躁的问题。\n但是本人白天睡觉一醒来就emmm\u0026hellip;总之感觉很不好，而且午睡不能太长，睡眠浅导致醒来没有好的学习状态。所以一直没尝试。\n","permalink":"https://coderrenxy.github.io/posts/life/%E4%BD%9C%E6%81%AF%E6%90%AD%E9%85%8D/","summary":"前言 每个人都有适合自己的作息，不用随大流，找到自己的生活、学习节奏就好。 第一更 我的一天 第一次找到不用依靠外界环境逼迫性学习的时间规律是：23","title":"作息搭配"},{"content":"\nMybatis是什么 Mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC、加载驱动、创建连接、创建statement等一系列与数据库交互的繁杂步骤。\n Mybatis优缺点 优点\n 灵活，sql写在xml中与程序代码解耦，便于统一管理，支持动态sql，并可重用。 与JDBC相比，减少了至少50%的代码量，消除了JDBC大量冗余代码，不需要手动开关连接。 与各种数据库兼容。（因为内部封装了JDBC，所以JDBC支持的所有数据库都和Mybatis兼容） 与Spring能够很好的集成。  缺点\n SQL语句编写工作量大，尤其字段多，关联表多时对开发人员编写SQL功底有一定要求。 SQL语句依赖数据库，导致数据库可移植性差，不能随意更换数据库。   JDBC：是一个用于执行SQL的Java API，可为多种关系型数据库提供统一访问。\n Hibernate特点 是一个ORM（Object Relation Mapping：对象关系映射）框架，只需要操作对象，处理好了映射关系后不怎么需要操作数据库。但是缺点有：\n Hibernate的完全封装导致无法使用数据的一些功能。 对代码的耦合度高。 找bug难，因为封装完美。 批量操作数据需要大量内存空间而且执行过程对象太多。   Mybatis的使用 mybatis-config略过，写一个dao接口但是不用实现，在对应的xml文件写sql，创建一个实体类对应xml中的字段，在mapper.xml中namespace就是对应dao的路径，mapper文件里面写sql语句、resultType、id等参数。 在mapper.xml中sql里面 #{name}的字段是由上层（service层）对实体类对象调用setName方法传进来的，实体类做一个中转站。\n在使用Mybatis时，时常实体类属性名和表字段名不匹配，那我们就封装一个结果集，如果能一一对应，系统就相当于自动封装了一个结果集。也可以as取别名。\n 动态 sql 小问题 动态sql在本人工作过程中使用出现的问题：\u0026lt;if xx != null\u0026gt;内一直把and或or写在句尾，但是最后一个为null时，上一个 if 末尾的 and 或 or 会导致报错。\n解决方法：在整体 if 外嵌套一个 where 标签会自动去除所有 if 语句的整体的开头的 and 或 or，但是注意必须写在开头而不是像未使用 where 标签时一样写在末尾。\n sqlSession：与数据库的会话\n 一些属性 flushCache：用来表示当前sql语句的结果是否进入二级缓存;\nstatementType：用于选择执行sql语句的方式\n statement：最基本的jdbc操作，用来表示一个sql语句，不能防止sql注入。 prepared：采用预编译方式，能防止sql注入，设置参数的时候需要该对象来进行设置。 callback：调用存储过程。  resultType：用的不多，因为只能返回一个实体类的类型，多数使用reslutMap自定义结果集\n 预编译 预编译定义：SQL预编译指的是数据库驱动在发送SQL语句和参数给DBMS之前对SQL语句进行编译，这样DBMS执行SQL时，就不需要重新编译。\n为什么需要预编译：预编译阶段可以优化SQL的执行。预编译之后的SQL多数情况下可以直接执行，DBMS不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。\n #{}与${}的区别   #{}的处理方式使用了参数预编译，被解析为一个参数占位符 。\n获取数据：使用 #{} 获取必须用对象的属性名，多个参数时用arg0、arg1\u0026hellip;..原因是mybatis在传入多个参数时，会将这些参数的结果封装到map结构中，在map中key就是{arg0，arg1\u0026hellip;.}。如果想使用参数别名，可以用@param(\u0026ldquo;别名\u0026rdquo;) Integer empAge在dao的interface中。\n  ${}是直接拼接 sql语句得到对应的 sql语句，仅仅为一个纯碎的 string 替换，会有 sql注入的危险，所以推荐 #{}的方式。\n${}的使用场景：动态传入表名，order by ${列名}。注意：这是动态传值，所以必须用 @param。\n注意：sql注入：传入的参数始终为true，密码验证就无效了。\n   Mybatis缓存机制  一级缓存：表示sqlSession级别的缓存，每次查询的时候会开启一个会话，此会话相当于一次连接，该连接关闭之后对应的一级缓存自动失效。 二级缓存：全局范围内的缓存，sqlSession关闭之后才会生效。 第三方缓存：继承第三方的组件，来充当缓存的作用。    一级缓存：表示将数据存储在sqlSession中，关闭之后自动失效，默认情况下是开启的。在同一个会话之内，如果执行了多个相同的sql语句，那么除了第一个之外，所有的数据都是从缓存中进行查询的。在某些情况下一级缓存可能失效？\n 在同一个方法中，可能开启多个会话，此时注意，会话和方法没有关系，不是一个方法就只有一个会话，所以严格记住，缓存的数据是保存在sqlSession中的 。 当传递同一个对象但是对象属性值不同也不会走缓存。 在同一个连接中，如果修改了数据，那么缓存会失效，不同连接不受影响。 在一个会话过程，手动清除缓存，也会失效。    二级缓存：全局缓存，必须等到sqlSession关闭之后才会生效。默认不开启，如果开启需要如下设置。\n 修改全局配置文件，在setting中添加 \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; 指定在哪个映射文件中使用缓存的配置：加上 \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt;。 对应的Java实体类必须实现序列化接口。    二级缓存属性：\n eviction：缓存淘汰机制：  LRU（默认）：最近最少使用。 FIFO：先进先出，按照添加缓存的顺序执行。 SOFT：软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK：弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。   flushInterval：设置多长时间进行缓存刷新 size：引用的条数，是一个正整数，缓存中可以存储多少个对象，一般不设置，如果设置的话不要太大，会导致内存溢出。 readonly：只读属性  true：只读缓存，会给所有的调用方法返回该对象的实例，不安全。 false：读写缓存，只是返回缓存对象的拷贝，比较安全。    一二级缓存会不会同时存在数据?\n不会，一级缓存存在sqlSession，二级缓存是全局缓存，必须等到sqlSession关闭之后才会生效。 查询数据时，先查询一级缓存，还是二级缓存？\n二级缓存 \u0026ndash;\u0026gt; 一级缓存 \u0026ndash;\u0026gt; 数据库\n   Mybatis工作原理 工作原理如下： 大致分为：读取配置文件、解析Mapper配置文件、创建SqlSession、执行SQL语句、处理结果集和关闭SqlSession\nMybatis分页方式 逻辑分页：使用Mybatis自带的RowBounds进行分页，他会一次性的查出多条数据，然后检索分页中的数据，具体一次查出多少条数据，由封装的JDBC的fetch-size决定。\n物理分页：大家都在用的分页方式，一般用的是pagerHelper实现的就是物理分页。\n Mybatis的Executor执行器 Mybatis有三种基本的Executor执行器，都作用在SqlSession生命周期范围内。\n SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map\u0026lt;String, Statement\u0026gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。    持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/mybatis/","summary":"Mybatis是什么 Mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC、加载驱动、创建连接、创建statement等一系列","title":"Mybatis"},{"content":"关于我 英文名： 暂无 职业： 程序员 运动： 跑步、乒乓球、羽毛球、游泳、足球、篮球、桌球、排球、跳绳\n","permalink":"https://coderrenxy.github.io/about/","summary":"关于我 英文名： 暂无 职业： 程序员 运动： 跑步、乒乓球、羽毛球、游泳、足球、篮球、桌球、排球、跳绳","title":"🙋🏻‍♂️关于"},{"content":"Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后序的最后一个元素一定是 root，左右中，最后才吃到 root。\nkey2：后序遍历最后一个节点是根节点，中序遍历根节点左边是左子树的节点，右边是右子树的结点。一个边界是某数组只有一个元素，另一个是数组为空，why？因为在递归传递参数时有+1、-1的操作，所以当有一个节点、无结点单独拎出来。然后分别找到了左右子树的根节点，加到当前的根节点的左右孩子位置，然后递归左右子树。\nkey3：\n ****后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 中序中结点分布应该是：[左子树结点，根结点，右子树结点]； 左右子树的节点分别去左右子树匹配；  key4：前序的左右数组 与 中序的左右数组一定是分别一样长度。在切割时利用。\n注意：\n 开闭区间，[] 的话传入的参数应该是0、leng-1、0、leng-1，如果是 [) 的话传入的参数应该是0、leng、0、leng。切割处理也不同。 后序要抠掉最后一个结点，因为这个结点 new 出来了。  105.从前序与中序遍历序列构造二叉树 同 106 所述，就是抠的是左边界。\n Tuesday 654.最大二叉树 错误思路：先要知道，它不像前中后序那样一直分左右数组，而是第一次就分好，后面无需再分左右数组，只要不断的操作这个数组，detail 就是一直移除一个元素，什么最好，显然可以 remove 的 ArrayList better，so，还要明确第一次是放在左孩子位置，后面是递归放在左子树的右孩子，另一子树与之相反，亦复如是。如何控制这个次数，显然加一个参数 deep 最好，if \u0026hellip; else 把出现次数多的放在 if 中。错在题意理解上。\n正确思路：就是递归不断将左右两边去找最大那个返回，并将其左右数组递归。判空条件和105、106一样。left \u0026gt; right 时没有元素了，left == right 时只有一个元素直接 return new TreeNode();\n注意：在初始化 index 时，不要随意初始化，初始化为 left，只要在 [left，right] 都行。\nWednesday 617.合并二叉树 思路：两个结点都为 null 或其中一个为 null 为终止条件，都不为 null 就合并再 return 。\n注意：当有一个节点为 null 但是另一个节点存在时，应该 return 该节点而不是把该结点的值赋给 new 出来的新节点，这样就不会丢失它的左右孩子了，如果某深度为 null 了。那更深处必然都为 null，要合并时将该节点直接移过去左右孩子就不用考虑了。\n700.二叉搜索树中的搜索 略\u0026hellip;\u0026hellip;\n98.验证二叉搜索树 中序遍历然后把 root 值作为目标值，在目标值左边都要小于 root.val ，在目标值右边都要大于 root.val 。然后在 return 中递归左右子树。\n530.二叉搜索树的最小绝对差 暴力解法：直接遍历出 list，再递归左右子树去遍历差值。\n优雅解法：用这个解法首先把二叉搜索树的特点：左小右大 结合进来了，左子树的最右后代（左孩子的右孩子的右孩子的右孩子\u0026hellip;\u0026hellip;.）、右子树的最左后代是值最接近根节点的结点。\n Thursday 501.二叉搜索树中的众数 暴力解法：遍历整棵树并在过程中 put 进去结点的 值（key）、出现频率（value）。再拿到 map 中出现频率（value）最大的值（key）。\n注意：要不断更新存储最大频率 key 的 List。如果有新的最大频率就清空（clear） List 再 add，出现同样频率就 add 。\n迭代法：利用二叉搜索树的特点，类中序遍历，记录当前、上一结点。\n236. 二叉树的最近公共祖先 暴力解法：分别记录找到 p 、q 的路径（递归+回溯）再双层 for 找最末位置的匹配项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; TreeNode node = root; List\u0026lt;TreeNode\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;TreeNode\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); getPath(list1, root, p); getPath(list2, root, q); for(int i=0; i\u0026lt;list1.size(); i++){ for(int j=0; j\u0026lt;list2.size(); j++){ if(list1.get(i).val == list2.get(j).val) node = list1.get(i); } } return node; } public boolean getPath(List\u0026lt;TreeNode\u0026gt; list, TreeNode root, TreeNode target){ if(root.val == target.val){ list.add(target); return true; } if(root.left != null){ list.add(root); if(getPath(list, root.left, target)) return true; list.remove(root); } if(root.right != null){ list.add(root); if(getPath(list, root.right, target)) return true; list.remove(root); } return false; } }   最优解法思路：后序遍历，从下往上找，找到目标 p、q 就存下来，这个 p、q 必然是某棵子数的左右孩子，找到了左右孩子分别不断往上传递，到了最小祖宗深度之后直接不断返回 root。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {//就算p、q有一个是根节点，也会在这里将其当作最小祖宗结点返回。  if(root == null || root == p || root == q) return root;//不管这个结点是叶子结点、p、q都会返回来，是叶子节点就返回一个null（到递归层）。否则返回一个p、q（到递归层）  TreeNode left = lowestCommonAncestor(root.left, p, q);//左子树去遍历寻找p、q，递归层（遍历过程）找到了p、q就会返回回来并保存下来，如果到了叶子节点返回的为null就存不到结点  TreeNode right = lowestCommonAncestor(root.right, p, q);//右子树去遍历寻找p、q  //具体的判断找没找到那个p、q，找到就不断往上次递归层传递。上层递归再判断是否p、q齐全，以上两行递归完便找到了left、right，都找到才会回到deep=最小祖宗这一行返回root，更深处都是不会返回root，然后以上的deep层层跳出递归都是走return root这行。  if(left != null \u0026amp;\u0026amp; right != null) return root; if(left != null \u0026amp;\u0026amp; right == null) return left; if(left == null \u0026amp;\u0026amp; right != null) return right; return null; } }     Friday 235. 二叉搜索树的最近公共祖先 key：第一个出现在 (p.val,q.val) 的结点就是搜索二叉树的最近公共祖先。\n1 2 3 4 5 6 7 8  class Solution { TreeNode node = null; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val \u0026gt; p.val \u0026amp;\u0026amp; root.val \u0026gt; q.val) return lowestCommonAncestor(root.left , p, q); if(root.val \u0026lt; p.val \u0026amp;\u0026amp; root.val \u0026lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; } }   701.二叉搜索树中的插入操作 key：如果 root.val \u0026gt; target 递归左子树找最接近的点，如果遇到 null 就 return new target，比到直到 new 了一个结点，也就是搞定了，会一路 return 回去，至于为什么一路都是 return 呢？因为 \u0026gt; \\ \u0026lt; 只会走进一个 if ，进了出来只会去 return，return 是当前这个点，而我们 insert 结点是在最深一层遍历，插入的位置也是一个结点的 左/右 孩子，然后一路返回的都是之前存在的结点。\n1 2 3 4 5 6 7 8  class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); if(val \u0026gt; root.val) root.right = insertIntoBST(root.right, val); if(val \u0026lt; root.val) root.left = insertIntoBST(root.left , val); return root; } }   450.删除二叉搜索树中的节点 当找到了删除节点时：\nkey1：当删除节点的左右节点都为 null，return null；\nkey2：当删除结点都不为空，找被删 root 的右节点的最左祖孙 并将被删 root 的 left 作为 root右节点最左祖孙的 left 孩子。\nkey3：当 root.left or root.right 为 null，return 不为空的结点。\n否则就递归并将返回为左右孩子。\ncode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null || (root.val == key \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right ==null)) return null; return deleteNode1(root, key); } public TreeNode deleteNode1(TreeNode root, int key) { if(root == null) return null; if(root.val \u0026gt; key) root.left = deleteNode1(root.left , key); if(root.val \u0026lt; key) root.right = deleteNode1(root.right, key); if(root.val == key){ if(root.right != null \u0026amp;\u0026amp; root.left != null){ //无论该处是否为null，都将root.right传进来取root.right最左祖孙。  TreeNode temp = root.right;//6  while(temp.left != null)//找到最左祖孙。  temp = temp.left; temp.left = root.left; return root.right; }else if(root.right != null \u0026amp;\u0026amp; root.left == null){ return root.right; }else if(root.right == null \u0026amp;\u0026amp; root.left != null){ return root.left; }else{ return null; } } return root; } }    持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.5/","summary":"Monday 106.从中序与后序遍历序列构造二叉树 key1：中后序的第一个元素一定是左下角那个，因为中序是：左中右，后序是：左右中。都是先递归左。、后","title":"LeetCode 一周小记 No.5"},{"content":"Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +1，因为递归进递归会先走到 left 的底，再依次出递归 deep 只会回到原来的值。总之每次进递归的方法的初始参数都是当前参数中的结点、参数节点的上一深度，然后 deep++，就变成了当前节点、当前节点深度操作。\n这题二刷肯定思路从0开始，大家都这样，不要放弃！！！\n迭代思路(推荐)：利用队列的先进先出，起初队列只有一个 root ，然后构建一个循环（在每次循环都新建一个 ArrayList ，代表存每一个深度的所有元素值，该循环内嵌套一个循环拜访每个该深度的结点的值进 ArrayList 以及该节点的左右孩子并 offer 进队列。问题来了：如何判断每个深度有几个树节点？即如何确定内存循环的循环次数 ?在每次进外层循环时，都把当前的队列长度都定义到 len 变量上，该队列每次把一层的树节点长度记录下来，全都 poll 掉了剩下的就是下一深度的所有树节点。外循环应该好判断的吧 ? 当队列为空时，即整个深度 offer 不进去树节点时，就意味着全部遍历完了。\n107.二叉树的层次遍历II 就是用上题的迭代再反转，反转就把装有ArrayList的 list 从尾到头的 add 到另一个 result 就行。\n199.二叉树的右视图 利用层序迭代遍历留住每层的最后一个元素值。\n637.二叉树的层平均值 还是层序遍历。\n Tuesday 429.N叉树的层序遍历 主要注意定义的 Node ，有属性名为 children 的 List ，里面全是当前节点的孩子，再正常层序遍历就好了。\n515.在每个树行中找最大值 类似层序遍历留住最后一个元素。\n116.填充每个节点的下一个右侧节点指针 思路：很简单，自己用层序遍历套娃。\n注意：老是忘记 offer root 结点进入队列，进入了就容易在 len 上判断失误：\n需要判断 len 是否等于 1 ，如果队列为空了，peek 出来就是 null 。但是队列在下一层有元素时，并不会为 null ，所以需要 len 来判断当前值。\n117.填充每个节点的下一个右侧节点指针II 和116的差距就是这里不是完全二叉树，逻辑代码都一样。\n104.二叉树的最大深度 做了前面的还不会请自行gg\u0026hellip;..\n111.二叉树的最小深度 有坑，不是说 root.left 节点为空最小深度就是1，是从根节点到最近叶子节点。只有一个结点的 left、right 都为 null ，才是叶子节点。\n注意：一定要在第一步判空: if(root == null) \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..\n Wednesday 226.翻转二叉树 递归：确定参数类型、返回值 —\u0026gt; 确定终止条件 —\u0026gt; 确定单层逻辑。先 coding 出交换代码的单层逻辑，再左右子树递归。\n层序遍历在内层循环也能处理。\n101. 对称二叉树 不管是递归还是迭代，都要判断比较的两个节点都为 null、一个为 null、两个都不为 null是否相等。\n递归很好做，但是不能很好地理解题意。单层逻辑就是判断以上条件并 return 两两结点再进该方法。\n迭代：利用队列，推入二层的两个节点，所有判空都在循环中进行。然后推四个孩子。\n其实还是迭代更具普适性。\n100.相同的树 递归：同101，不过在递归的参数 node1 和 node2 都为 null 容易不理解（101就迷糊了的问题），为什么返回 null，返回 null 并不会结束整个程序，只会把那一层递归的程序结束，最后 return 的是两个判断的 \u0026amp;\u0026amp;。\n迭代：同101。\n572.另一个树的子树 据题意，该 t 树要么是等于 s 树，要么是其左子树 or 右子树。定义一个判断是否相等树的方法，再 || 到两个 isSubtree 方法。\n注意：在 isSubtree 方法一定要判空 s 结点，不然就算在 isSametree 方法中能判空，再进到 isSubtree 也还是空，再 isSubtree.left 就空指针了。就算刚开始传入的 s 不为 null，但是 s 一直在变化，总会有出现 null 的情况出现。任何一个递归一定是有一个结束条件来收敛！\n222.完全二叉树的节点个数 迭代：一个循环粗糙层序遍历。\n递归：return 1+左递归+右递归。\n注意：用 offer 要判空“值”，poll 不需要判空“队列”。\n Thursday 110.平衡二叉树 思路：没什么东西，bfs、dfs都行，两个相减再用两个孩子递归。\n注意：在处理deep时要抠清楚，正常相减 deep 起始值无所谓，但是，如果节点为 null 那返回的一定是 0，deep 初始值只与这里有关。\n拓展：bfs 万精油， dfs 前序求深度，后序求高度。\n257. 二叉树的所有路径 思路：跟深度相关，首选 dfs的前序遍历，然后肯定是要递归的，在此之上还要回溯：进到多少层，结束了再出来，出一层删最后一个元素，出n层删n个元素。两个list都放做递归方法的参数，因为两个都要保持不变得用，所有操作都要手动做！递归的结束条件是当前节点的左右孩子为空。\n404.左叶子之和 思路：不同条件进不同的处理，当前结点（左节点）为不为叶子结点要判断，当前节点的右节点为不为空也要判断。\n注意：一定要判断是否为叶子结点，是求左叶子结点和，不是左节点和。\n513.找树左下角的值 思路：层序遍历只保存最左边的值，很简单，有足够的时间优雅一点！\n112. 路径总和 思路：主要就是递归+回溯，和257差不多。\n注意：return 是结束当前递归层，如果要影响到其他层，则需要具有传递性的语句。\n Friday 113. 路径总和 ll 思路：和 day 19 的 112 差不多思路（递归+回溯），不同之处在于判空处理。因为是要存入路径，所以参数多了两个 List：一个用于存多条路径，一个用于增删单条路径。\n注意：这条增删单条路径的，在判空捕捉到 add 该条路径时，必须 new 一个新的 List ，不然还是操作的那条是始终在变的。\n 持续更新\u0026hellip;\u0026hellip;.\n如有错误，敬请斧正！！！\n","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.4/","summary":"Monday 102.二叉树的层序遍历 递归思路：仍然是先深度到顶确定好 deep 把每一深度的 ArrayList new 出来，再往里依次添值。 是否创建 ArrayList 用 if 判断，进了递归的方法 deep 就要 +","title":"LeetCode 一周小记 No.4"},{"content":"Monday 18.四数之和 思路 ：就是昨天三数之和多了一个 for 循环。 注意 ：if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;}\n 这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 。 还有就是 \u0026gt; target \u0026lt; target == target 绝对 if\u0026hellip;else 而不是单独的多个 if 。  344. 反转字符串 双指针做法\n541. 反转字符串 II 字符串切割从第 i 位置到 k + i - 1 才是切下 k 个字符 。\n判断条件没有很复杂,就是拿到的个数 \u0026gt; k 就操作反转前 k 个, \u0026lt; k 直接全反转。\n就是 ≥2k 和 2k ≥ len ≥ k ,两个区间都是用一操作,融合了。\n剑指Offer 05.替换空格 注意 : 只有 String 转换为了 StringBuffer or StringBuilder 才能用 append \u0026amp;\u0026amp; toString 方法。\n151. 翻转字符串里的单词 大体思路：先全部反转、再依次反转各个 word。\n记住几个 API ： charAt、setChatAt，操作 String 先转换成 StringBuilder or StringBuffer 再操作。\n注意要移除开头结尾的 space、word 间连续的 space。\n其中去除连续的 space 注意判断条件 当前 char != space || sb最后一个 char 不为 space（上一个 char 不为 space），两个判断条件反了会短路。\nTuesday 剑指Offer58-II.左旋转字符串 思路：把 n 后面的先 append 到 new 的 sb 上，再把 n 之前的 append 到 sb 。\n28. 实现 strStr() KMP原理：通过前缀表记录每个对应字符串下的每个相同前后缀的长度（即：免匹配的子串的下一位置 index ），当模式串和原文匹配中断时直接跳到上一字符的前缀表位置对应前缀表内容对应的模式串位置。so，实现分为两块：匹配、更新前缀表。\nKMP实现：目前还只能通过印象 + 实践调 bug得出，并不能很好的理解代码，等刷完动态规划回来二刷再看。\n459. 重复的子字符串 KMP卒，二刷见\u0026hellip;\u0026hellip;\u0026hellip;.\nWednesday day 13 232.用栈实现队列 思路：一个出栈的栈，一个入栈的栈实现一个队列，运用栈的四个 API ，在 pop 、peek 是要判断出栈的栈是否为空，为空就把入栈的栈内元素全 pop 到出栈的栈中。\n225. 用队列实现栈 思路：一个队列用于暂存、一个用于操作，和两个栈实现一个队列不大相同。\n注意：API ：poll 相当于 pop、offer 相当于 push、其他不变。\n20. 有效的括号 思路：遇见左括号就 push 右括号，否则就看栈是否提前空了、栈顶元素匹配当前括号，否则就 pop。\n栈提前空了会导致后面就算有没匹配上的括号，最后 return 的依然是 true 。\n注意：在匹配栈顶元素时，切记不要用 pop，而是用 peek，否则比较一次 少一个栈顶元素就导致空栈异常。\n1047. 删除字符串中的所有相邻重复项 思路：栈为空 or 匹配栈顶元素为 flase 就 stack.push( )，sb.append( )，否则就是匹配成功 就直接 stack.pop( )，sb.deleteCharAt( sb.length( )-1 )\n150. 逆波兰表达式求值 150. 逆波兰表达式求值 Tips：与本题无关 ：数字（int）转字符（char）要强转( char ) ( 0 + ’ 0 ’ )，字符转数字隐式就可以了不用声明出来 ‘ 2 ’ - ’ 0 ’ ，但是为了书写统一，还是都强转一下。\nAPI：Integer.valueOf( str );\n思路：拿到每一个数组索引下的字符串去比较，是运算就 pop 出两个元素运算并 push 结果，否则直接 push。\nThursday 239. 滑动窗口最大值 思路：自己用双端队列实现一个队列，add 方法来保证单调（队头始终为最大值），poll 方法保证窗口的滑动。每次取队头给记录窗口最大值的数组赋值就行了。如何设计 add 、poll ？\nadd：一直比较队尾，如果小于要 add 的 val，就杀掉这个队尾，直到上一个元素大于 val，此时 add 这个 val。\npoll：拿到窗口最后一个值与队头（最大值）去比较，如果相等，就杀死队头，因为这个本该从滑动窗口走出的元素影响最大值的判断了。否则就不操作。\n注意： Deque 双端队列才可以取队尾（getLast（ ）、removeLast（ ）），Queue 单端队列不可以。\nDeque 双端队列中，add（）才是在队尾添加元素。\npeek、poll 必须保证队列不为空。\n347.前 K 个高频元素 大小顶堆：卒\u0026hellip;\u0026hellip;\nFriday 二叉树的深度优先遍历 (知识填充) 前置知识填充：\n满二叉树：深度为 k 的满二叉树在深度为 k 层也都有左右子树。\n完全二叉树：深度为 k 的完全二叉树除了第 k 层节点可能没填满外，其余每层节点数都达到最大值，并且第 k 层的节点都集中在该层最左边的若干位置。\n二叉搜索树：有序树，左孩子不为空的情况下，结点的左孩子比结点数值小，右孩子不为空的情况下，右节点比节点数值大。\n平衡二叉搜索树（AVL）：是一棵空树 或者 它的左右子树高度值绝对值不超过1 且左右子树都是平衡树。\n二叉树的存储：\n二叉树可以链式存储，也可以顺序存储。\n链式存储就是用指针串起来，内存不连续，顺序存储用数组，内存连续。\n如果父节点的数组下标是 i，那么它的左孩子就是 i × 2 + 1，右孩子就是 i × 2 + 2。\n二叉树的遍历：\n 深度优先遍历：先往深处走，遇到叶子节点在往回走。分为《前中后序遍历》，这个前中后其实是中间结点的顺序，前序：中左右，中序：左中右，后序：左右中。 广度优先遍历：一层一层的遍历。《层次遍历》（迭代法）  144.二叉树的前序遍历 \u0026amp; 145.二叉树的后序遍历 \u0026amp; 94.二叉树的中序遍历 递归做法：三个遍历一个方法代码挪一下位置。\n迭代做法：先把图画出来标号顺序，再模拟过程。前后序差不多，中序 while 条件不一样。后序在得不到结果的时候想一下逆序再反转（Collection.reverse(result)）。\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.3/","summary":"Monday 18.四数之和 思路 ：就是昨天三数之和多了一个 for 循环。 注意 ：if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){continue;} 这个条件是 j \u0026gt; i+1 ,而不是 j \u0026gt; 0 。 还有就是 \u0026gt; target \u0026lt; target == target 绝对","title":"LeetCode 一周小记 No.3"},{"content":"​ 集合的概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。\n和数组的区别：\n 数组长度固定，集合长度不固定。 数组可以存储基本数据类型、引用数据类型，集合只能存储引用数据类型。所以看到的 Map都是 Map\u0026lt;Integer,Integer\u0026gt;，而不是 Map\u0026lt;int,int\u0026gt; 。 相比于集合，数组没有删除方法，开辟连续空间。   Collection体系下两个接口 List接口 List 特点：有序、有下标、元素可重复。\nList 实现类： ArrayList、LinkedList、Vector。\n ArrayList：是一个古老的实现类，底层是 Object[] ，vector 底层也是一样，线程不安全，容量是动态的、但是牺牲效率，DEFAULT_CAPACITY = 10; 默认容量为10；若未添加元素，容量 0；扩容每次是原来的1.5倍，下文详解。ArrayList.add() 不带索引则默认从 0 开始。 Vector、ArrayList：都是数组结构实现，但是 Vector 是线程安全的，ArrayList 线程不安全，而 LinkedList 是链表结构实现。笼统来说，ArrayList 查询快、插入慢， LinkedList 查询慢、插入快，因为 ArrayList 要把插入位后面的值全都后移一位，但是有特殊情况，下文详解。 LinkedList ：存储结构为双向链表。 无需开辟连续空间，查询慢，增删快。具体下文再比较效率 。   注意：ArrayList 是并发不安全的，vector 是线程安全的。\n解决 ArrayList 线程安全问题的方法有：Collections.synchronizedList、CopyOnWriteArrayList。  ArrayList、LinkedList 比较  ArrayList 底层基于数组实现，LinkedList 底层基于链表实现，确切的说是循环双向链表（JDK 1.7 之前是双向循环链表、JDK 1.7 开始取消了循环），LinkedList 链表由一系列表项连接而成， 一个表项包含 3 个部分：元素内容、前驱表、后驱表。LinkedList 链表内部还有一个 header 表项，既是链表的开始也是链表的结尾。header 的后继表项是链表中的第一个元素，header 的前驱表项是链表中的最后一个元素。\nArrayList 的增删未必比 LinkedList 慢：\n1. 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。 数据量达到百万级的时，速度是会比 LinkedList 要快的。\n2. 删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上， ArrayList 的消耗主要是在移动和复制上（底层调用的是 arrayCopy() 方法，是本地方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度， 数据量达到百万级的时，还是 ArrayList 要快。\nArrayList 扩容 起初 empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当使用 add 方法的时候首先调用 ensureCapacityInternal 方法， 源码中的 Capacity 是容量，size 是当前the number of elements it contains（当前包含的元素数）， 传入 size+1 进去，检查是否需要扩充 elementData 数组的大小，再传入值；具体扩容过程如下（不拿 add（） 的重载举例）：\n1 2 3 4 5  public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; }   若 add() 第一个元素，则传入 DEFAULT_CAPACITY = 10，默认容量为10，注意很多博主讲到扩容，minCapacity 、newCapacity、oldCapacity、size 名词组合拳就把人整晕了，其实传入的 size+1 就是 ensureCapacityInternal 方法中的 minCapacity。\n1 2 3  private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); }   可以看到判断扩容的方法里调用了ensureExplicitCapacity和 calculateCapacity ，方法体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }   calculateCapacity 方法传入 elementData （即当前存 “元素数据引用” 的地址）, minCapacity（即size+1），意思当第一次调用add(E e)方法的时候， 判断是不是无参构造函数创建的对象，如果是， 将 DEFAULT_CAPACITY 即 10 作为 ArrayList 的容量，此时 minCapacity = 1。返回的容量作为ensureExplicitCapacity的参数传入， 此时 modCount++；是fail-fast iterators 相关，先不用管，而 DataElement 是现在用于存储的数组，当 size+1 大于这个值，意味着要扩容了，然后调用grow（）方法扩容 ：\n1 2 3 4 5 6 7 8 9 10 11  private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); }   其中 oldCapacity 是原来的容量大小，oldCapacity \u0026raquo; 1 为位运算的右移操作，右移一位相当于除以 2，所以这句代码就等于 int newCapacity = oldCapacity + oldCapacity / 2；\nnewCapacity = 扩充数组为原来的 1.5 倍(不能自定义)，然后判断 minCapacity 是否大于MAX_ARRAY_SIZE(Integer.MAX_VALUE – 8) ，如果大于数组最大容量，就取 Integer.MAX_VALUE；后回到 grow（）方法，调用 Arrays.copyof 方法， 即复制原数组内容到一个新容量的大数组里。这里Arrays.copyof 方法实际是调用 System.arraycopy方法。\n与 Vector 不同的是，Vector 每次扩容容量是翻倍，即为原来的 2倍，而 ArrayList 是 1.5倍。看似 1.5倍增长的很慢，那经常增加大量元素会不会导致经常扩容，数组重新分配导致效率低下呢？ 其实不然，每次增长为原来的 1.5倍实际增长的量会越来越大的。当然，如果一开始知道数据量很大的话，可以在初始化时预先指定容量。\n为什么扩容因子是 1.5\n因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。\n为什么不取固定长度\n扩容固定容量，很难决定到底取多少值合适，取任何具体值都不太合适，因为所需数据量往往由数组的客户端在具体应用场景决定。\n Set接口 Set 特点：无序、无下标、元素不能重复\nSet 实现类：HashSet、SortedSet 接口（TreeSet 实现类）\n TreeSet：基于排列顺序实现元素不重复。实现了 SortedSet 接口，对集合元素自动排序。元素对象的类型必须实现 Comparable 接口，指定排序规则方法的返回值为 0，则认为是重复元素。 HashSet：储存结构为哈希表（数组+链表+红黑树）。   注意：HashSet 是线程不安全的，解决方法是使用 CopyOnWriteHashSet。  HashSet 存储过程：\n 根据 hashcode 计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。 再执行 equals 方法，如果 equals 方法为 true ，则认为是重复，否则，形成链表。  HashSet、TreeSet的实现原理: HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。\nTreeSet 的实现基于 TreeMap。\n Map 集合体系 Map 父接口特点：存储一对一数据，无序、无下标，键不可重复，值可以重复。\n HashMap ：存储结构（哈希表：数组+链表+红黑树）允许 null key、value。\nHashTable：不允许 null key、value。线程安全。\nTreeMap：实现了 SortedMap 接口（Map 的子接口），可以对 key 自动排序。\n 注意：HashMap 是线程不安全的，解决方法是使用 ConcurrentHashMap 。  HashMap底层原理 jdk 1.7 的数据结构是 “ Entry数组+链表 ”，jdk 1.8 的数据结构是 ” Node 数组+链表/红黑树 “。当链表的深度达到 8 并且 HashMap 容量 \u0026gt;= 64 时自动转化成红黑树，节点变成树节点，\t以提高搜索效率和插入效率到 O(logN)。Entry 和 Node 都包含 key、value、hash、next 属性。\nHashMap 默认容量为 16（数组长度），通过 hashcode 查询的时候是要先 ” hashcode % 数组长度 “ 进行运算才能找到数组对应位置下的链表。该数组只存引用的地址，其对象存在堆里。\n在 jdk 1.7 时插入元素是头插法，jdk 1.8 时是尾插法，头插法的插入很快（插完要移动一下，让该结点在原来头节点在数组中的槽位），尾插法要遍历再插入（jdk1.8）。\nput 时先会判断是否空数组，是空就会先初始化，put 一对 key-value 时，系统会根据 key 的hashcode\t来确认其在 “数组” 的存储位置，若没有元素则直接插入，否则会遍历该处的链表并依次比较其 key 的 hashcode，如果两个 key 的 hashcode 相同且 key 值相同，新的 value 会覆盖旧的 value 并返回旧的 value（不覆盖返回的是 NULLl）。如果 hashcode 相同但 key 值不同，则会进行插入操作，并且该链表的 size++。\n那么 key 值如何比较呢？ equals 方法。这里涉及 哈希碰撞：\n输入数据长度不固定，而输出的哈希值却是固定长度的，这意味着哈希值是一个有限集合，而输入数据则可以是无穷多个，那么建立一对一关系明显是不现实的。所以“碰撞”是必然会发生的。 HashMap 解决 hash冲突用的是拉链法，就是在对应的数组元素存链表头节点。还有开放寻址法、再哈希法，开放寻址是往数组索引++找空位置，再hash法就是再次用其他hash方法得到hashcode。 那既然 equals 方法这么有效，为什么还要用 hashcode ？\n因为 hashcode 快！\n如果现在有大量的对象需要比较，每个都用 equals() 效率是很低的，但 hashCode() 效率很高。\n所以有这种设计：先用 hashCode() 判断，如果 hashCode() 不同，则对象不等，如果 hashCode() 相同，再比较 equals() ，大大提高了效率。\nkey 可以等于 null，源码对 Entry 的两个约束：\n 数组每个槽位下都不为空。 所有结点平均分布在每一个槽位下的链表。  也正因如此，HashMap 的长度必须为 2 的次幂。讲到长度，就跑不掉 HashMap扩容了：\nHashMap 扩容条件 HashMap 扩容的加载因子默认为 0.75 ，阈值为 ” 0.75 * 数组长度 “，意思是每当 ”HashMap当前元素数“ 到达 ”当前容量 * 0.75“ 时 且 “插入位置不为 NULL” 就判断是否符合 “ 数组长度是否最大 ”。最大就不扩容，否则就是扩容到原容量的 2倍。\n0.75的负载因子的意义\n通常，默认负载因子（0.75）在时间和空间成本之间提供了一个很好的折中方案，负载因子控制存放数据的疏密程度。\n较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put），而且容易引发哈希冲突。\n16 * 0.75 = 12 除0.5与1以外唯一一个能得到整数的负载因子就是0.75。\n负载因子的大小决定了HashMap的数据密度，因子越大，越容易发生发生哈希碰撞，数组中的链表越容易长，造成查询或插入时比较次数增多，性能会下降。\n越小就越容易触发扩容，既影响性能又浪费空间。\nHashMap 扩容原理 new 一个两倍长度的 Entry/Node 数组，然后内容转移新的数组，扩容后链表会倒序。因此，多线程同时 put（）时，如果同时触发了 rehash（） 操作会导致 HashMap 中的链表中出现循环节点，进而使得后面 get（） 的时候，会死循环。\n另外，扩容之后链表可能减短，提高 get（） 时的效率。\n为什么HashMap扩容每次是2倍\n 找到 hash索引的方式是hashcode%length 取模操作，但设计得到 hash索引的 hash函数是：hashcode无符号右移16位再异或hashcode再按位与（length-1），为什么这么做?\n因为2进制操作远远快于取模，length 为 2次幂时，又恰好 (length - 1) \u0026amp; hash ≈ hash % length。而且我们可以看到它求hash的过程，将32位的hashCode值向右移动16位，高位补0，也就是只要了高16位，这是为什么呢？\n因为hashcode的计算方法导致哈希值的差异主要在高位，而 (n - 1) \u0026amp; hash是忽略了容量以上的高位的，所以 使用h \u0026raquo;\u0026gt;16就是为了避免类似情况的哈希冲突 在扩容迁移的时候不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原脚标位+扩容长度这么一个位置.是否移位，由扩容后表示的最高位是否1为所决定，由于移动的方向只有一个，即向高位移动。 因此，可以根据对最高位进行检测的结果来决定是否移位，从而可以优化性能，不用每一个元素都进行移位，因为为0说明刚好在移位完之后的位置，为1说明需要移动 oldCap.  哈希表底层怎样计算hash值  Object的hashcode方法算出h1。 h1无符号右移16位得到h2。 h1与h2异或运算得到最终的hash值h3。 h3与（length-1）按位与（\u0026amp;）运算得到hash表索引。 hashmap理论上是用取模得出在哪个hash桶，但是位运算会更快，在hashmap容量为2次幂时，取模结果会近似于以上四个步骤的结果。  HashMap死循环、ConcurrentHashMap HashMap\n在 JDK1.7 是采用的头插法，所以扩容过程转移到新的 HashMap 会逆置链表顺序，而当在并发环境下两个线程同时插入会导致死循环，原因就是顺序 A-B-C 变成了 C-B-A ，一个线程扩容完了之后另一个线程并不知道，因为此时两个线程都指向该槽位第一个节点， next 都是指向 B，而非扩容的线程的 B.next 还是 C，没有察觉到变化。在 JDK1.8 HashMap 采用的尾插法很好的规避了这个问题。\nConcurrentHashMap\n在 JDK1.7 下，ConcurrentHashMap 采用的是 segment 锁分段解决的并发问题，相比较 HashTable 降低了锁粒度。\n在 JDK1.8 下，ConcurrentHashMap 采用的是 CAS + synchronized + LockSupport 等阻塞手段实现的高效并发，和 JDK1.7 最大的区别在于 JDK1.8 的锁粒度更细，理想情况下 table 数组元素的大小就是其支持并发的最大个数，在 JDK7 里面最大并发 个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的， 简化了并发设计，不足之处在于并发的粒度稍粗，所以在 JDK1.8 里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的 table 元素的读写，好处在于并发的粒度更细， 影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像 JDK1.7 中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点，好在Doug lea大神对扩容 做了优化，本来在一个线程扩容的时候，如果影响了其他线程的数据，那么其他的线程的读写操作都应该阻塞，但Doug lea说你们闲着也是闲着，不如来一起参与扩容任务，这样人多力量大，办完事你们该干啥干啥，别浪费时间，于是在 JDK1.8 的源码 里面就引入了一个 ForwardingNode 类，在一个线程发起扩容的时候，就会改变 sizeCtl 这个值。\n  对于get读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。\n如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。\n  对于put/remove写操作，如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。\n  HashTable 和 HashMap 的区别  HashTable 不允许 key 和 value 为 null；HashMap 遇到 key 为 null 的时候，调用 putForNullKey（）进行处理，而对 value 没有处理；Hashtable 遇到 null，直接返回 NullPointerException。 HashTable 线程安全，但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只 能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。  ConcurrentHashMap 实现原理 JDK 1.7 中的实现：\n就是对HashMap加上个分段式锁，put和HashMap类似，先通过hashCode找到位置如果该处为null就new一个segment对象，segment 对象中有个 hashEntry 构成的链表，而每个 HashEntry 元素都是一个链表结构的节点，HashEntry 和 HashMap 非常类似，唯一的区别就是其中的核心数据 value 以及 next 都被 volatile 修饰，以此保证了多线程读写过程中对应变量的可见性。\nHashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的。ConcurrentHashMap 采用锁分段技术，将整个Hash桶进行了分段segment ，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁，这样做明显减小了锁的粒度.比HashTable效率高。 put过程：先根据 key 找到 segment 中对应的 HashEntry，遍历该 HashEntry ，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等就覆盖旧的 value，为空则需要新建一个 HashEntry 并加入到 segment 中，在加入之前会先判断是否需要扩容，最后解除 segment 锁。\nJDK 1.8 中的实现：\n将 JDK 1.7 中存放数据的 HashEntry 改为了 Node JDK 1.8 的 ConcurrentHashMap 取消了 Segment 分段锁，采取 CAS 和 synchronized 来保证并发的安全性。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发问题。\nHashtable 扩容时将容量翻倍，而 ConcurrentHashMap 扩容时将只扩大一个 Segment，这样可以减少扩容时的并发冲突，提高性能。\nLinkedHashMap实现原理：\nLinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry，并添加两个属性 Entry\u0026lt;K,V\u0026gt; before，Entry\u0026lt;K,V\u0026gt; after 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。\n 迭代 Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 可以双向遍历。ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。\n与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出\tConcurrentModificationException 异常。这其实就是 fail-fast 机制。具体区别有三点：\n Iterator 的方法名比 Enumeration 更科学； Iterator 有 fail-fast 机制，比 Enumeration 更安全； Iterator 能够删除元素，Enumeration 并不能删除元素。  持续更新中\u0026hellip;\u0026hellip; 如有错误，敬请斧正\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/blog/%E9%9B%86%E5%90%88%E6%B5%85%E5%8E%9F%E7%90%86%E7%AF%87/","summary":"​ 集合的概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。 和数组的区别： 数组长度固定，集合长度不固定。 数组可以存储基本","title":"集合浅原理篇"},{"content":"有点感觉了，一直持续刷下去！各位看官跟我一起成长啊！\nMonday 面试题 02.07. 链表相交 注意：暴力循环一定要注意边界条件：A or B 链子为空，只有这一个边界！！！边界只有《0 - 1》，没有《1 - 2》。\nTuesday 142.环形链表II 两个重要切入点 :\n 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 快指针永远走的是慢指针的两倍长度。  解释 ：\n 先判断有没有环，while 下 快指针走 2 步，慢指针走 1 步，如果两个结点 位置一致，即为有环，否则无环则一定会 fast.next || fast.next.next == null。 从头节点到环入口结点距离为 A，环入口节点到相遇结点正向距离为 B，相遇节点正向到入口节点距离为 C。一定是在环内相遇，且 A == C。  Wednesday 242.有效的字母异位词 大体思路：定义一个 26 长度的数组，遍历第一个字符串，每次 -’a’ ，得到了在数组中的索引，把该处自增就好了，再遍历另一个字符串自减操作。再 foreach 一下数组 if( 1≠0 ) 就 return flase;\n注意：foreach 用法：for( int arr[i] ： 数组名)。\nThursday 349. 两个数组的交集 注意：不能重复、无序：HashSet，记住几个常见 API 例如 set.contains(??)、set.size() 。\n202. 快乐数 解题思路：\n 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。 所以进主函数的循环条件为 ≠1 \u0026amp;\u0026amp; !set.contains(?); 只要能进这个循环就进去拿到 nextNumber ，进到该方法里再进行拿到 各数上的平方和。  注意：res += n % 10 * n % 10; 一定要写成 res += (n % 10) * (n % 10); 因为四则运算的优先级会先 n%10 再 *n 。\n1. 两数之和 暴力冒泡只要注意初始化： j=i+1即可。\n进阶版本：主要熟悉几个常用 API：map.containsKey(key)、map.get(key)。 思路：这个思路就是先挨个 map.put() ，然后 target-nums[i] 这个数字在 map 中查找是否有符合项，有就 break;\n注意：第二次循环（寻找符合项时）循环 n-1 次，因为第 n 次循环就是反转的第 n-1 次循环。再次操作同一循环会导致顺序倒转，一定要注意顺序，然后就是 当 target-nums[i] == temp 时，两者相等导致输出的数组两个内容相同。所以在进第二次循环后要把这种情况单独 if 判断并 continue;\nFriday 454. 四数相加 思路：先把前两个数组之和（key），该和出现的次数value 存入map，再遍历后两个数组拿到 0-（c+d）去查map是否存在，存在 count+=value。 注意：可能有数组传入为 null，计算值的时候默认为 0 就行，如果两个普通的 for循环嵌套，有空数组会被判断条件拦截下来，但如果用的是 foreach 就没问题。\n383.赎金信 类似242.有效的字母异位词的傻瓜式操作，但是要注意这里是可不可构成，字母可以多，不能少，而242是必须不多不少刚刚好。\n15.三数之和 先记住两个 API：Arrays.sort(nums)、Arrays.asList(nums[i], nums[left], nums[right])。\n思路：先排个序，方便很多，测试用例里也是排序号的！再用双指针 left、right 来定位。SUM\u0026gt;0 就right—，反之 left++。 注意：如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”：如果多个相同数值，直接跳过该段！在哪个判断条件的循环就要注意哪个的“雷同跳转”。\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.2/","summary":"有点感觉了，一直持续刷下去！各位看官跟我一起成长啊！ Monday 面试题 02.07. 链表相交 注意：暴力循环一定要注意边界条件：A or B 链子为空，只有这一个边界！！！","title":"LeetCode 一周小记 No.2"},{"content":"刷的脑壳疼，在螺旋矩阵卡了很久，其他的 easy 题都也被卡，目前进度为 2-3 medium / day。\nMonday （科普知识） 反码、补码 二进制的第一位是符号位，0是+，1是-，如果是1，怎么得到具体数字？ 二进制数全都取反，再+1就是对应结果的的绝对值 。 例如-1的二进制数全为1，则将后31个1全取反并+1，得到 000\u0026hellip;1 的十进制数就是1 。\n如何把随机出现从 x 概率变为 x^3 概率？ Math.Max(Math.Random(),Math.Max(Math.Random(),Math.Random()));\n注意：Random生成一个[0,1)\n如何在 1-5（int）随机函数上生成1-7的随机函数？ 直接把1-5改成随机生成0、1的函数，1、2返回0，3就return重来，4、5就返回1 。\n再根据读书器返回0、1的函数处理:\n1  return （f（）\u0026lt;\u0026lt; 2）+ （f（）\u0026lt;\u0026lt; 1）+（f（）\u0026lt;\u0026lt; 0）; //0或4 + 0或2 + 0或1   注意：\n 如果直接 相乘 是不行的，因为只返回 0、1 乘了 7 就变成 0、7 。会缺失中间的数。 0-7 有了，我们要 1-7 ，那只能 0-6 随机再+1 。1-7 只要遇 7 重来就行了。或者直接 0 重来。就不用再 +1。  为什么不能直接 (f() \u0026laquo; 2) + (f() \u0026laquo; 1) 呢？直接得到 0-6\n 因为左移两位得到要么是0要么是4，左移一位是0或2，不移动0、1 。得到的具体数字不是范围，再将其相加，产生的和才是一个范围。  如何改变一个任一固定概率的随机0、1函数变为产生0、1都为50%的函数？ 运行两次该函数，两次得到0的概率为 p^2 ,两次得到 1 的概率为 (1-p)^2 ;而一次 0 一次 1 的概率是 p*(1-p); 所以只要两次返回一次为 0 一次为 1 就行。不然就重新执行。\nTuesday 206. 反转链表 这题一定要按清楚头指针 pre、next 指针只是指针，不是一个结点指向另一个结点的指针。定义出这两个指针、画好图就很容易操作。这是单链表的反转，至于双链表就是多加了一个 last 指针指向上一个，只需要在存 next 时多存一个 last ，其他无需改动。\n704. 二分查找 首先把 left 、mid 、 right 都定义出来。mid 的赋值，左右指针的跳转都在循环内完成，注意要 left=mid+1，right = mid-1，不然藏在边界的 target 就查不到了。\n27. 移除元素 暴力解法：需要注意，i\u0026ndash;；是因为既然当前值为 ？的点的右边所有点一切都左移了一位，所以现在的 i 指向的是已删除（被覆盖）的位置，该位置补了后面那位没被扫描的数字，而该次循环结束就要 i++了，所以会指向这个没扫描的下一个进行扫描，就漏掉一个了。再一个注意溢出边界问题，还有一个就是无限循环容易发生是因为 for 循环条件不能是 \u0026lt; length。而应该是 \u0026lt;size 这个自定义的，会随着更新而更新。\nWednesday 977. 有序数组的平方 这一题犯了一个总是犯的错误，总是忘记写返回值，以后第一步确定返回值，不明则？？表示。\n该题暴力解法就是平方再排序美滋滋~，但是时间复杂度为O(n^2)，有O(n)的解法：双指针。\n双指针解法一定要注意边界。\n209. 长度最小的子数组 暴力解法要注意必须双层循环。为了避免要判断第一次 \u0026gt;target，把 len 初始值设为Interger.MAX_VALUE。滑动窗口：注意循环条件的边界。\nThursday 59. 螺旋矩阵 II 该题一定要注意别自己瞎套，while 的条件按照（循环次数）来。偏移量每次+2，从左到右，从上到下的循环条件要-offset。\n203. 移除链表元素 先把头的 val 确定 ≠ val、≠null 再去定义 cur 等等其他结点，记得依次讨论头不为空（头的 val 为 val）、头为空（return head把整个链表有可能为空的情况删除整个链表了直接提前退出）。\n不为空 \u0026amp;\u0026amp; 头的 val == val 一定要把 ≠null 写在 \u0026amp;\u0026amp; 前面，不然先判断 head.val 如果说 head == null ，那就直接报错了。\n删除一定要 XXX.next = XXX.next 这样操作，自己定义的 cur 、 next 都只存一个地址，cur = nextNode 就是 cur 指针走到了 nextNode 这个位置。\nFriday 707. 设计链表 只要把get、addIndex、delete写出来就行了，另外两个addHead、addTail直接调用这个addIndex就行了，至于get、delete都是用addIndex里面for查找的逻辑找到，主线就是写出addIndex，注意在addIndex里面 size++ 就够了，不要反复 ++ ；\n另外自己定义一个 ListNode 的 class ，构造方法只要空参。成员变量 int val、 ListNode next；\n24. 两两交换链表中的结点 非必要情况下，不要定义那么多 next、cur 结点，不然判空很头大，如果是在 while 内，cur、next、pre 都在变换，判空繁琐，在初始化时也要判空，还是尽量只定义一个 pre 结点，反正操作链表的元素有个 pre 就够了。\n19.删除链表的倒数第N个节点 暴力解法：注意考虑传入的值的合法性。\n进阶版本：首先一边扫描肯定无从下手，想想，倒数第 n 个结点，是正着数的第几个 ?\n 显而易见：size-n 个，那如何拼凑出 size ？那是肯定要扫描一遍完整的链表结点的。  如果扫描 size++ 出长度那必然要再操作一遍，落入了扫描多次的圈套，so what？\n 定义一个 fast 指针、一个 slow 指针，fast 扫描全文，而 slow 指向要被删除的结点的上一结点。如何凑出 size -n？先让 fast 走 n 次，再让 fast 和 slow 一起走剩下的 size-n次，此时fast 指向了最后一个元素，slow 指向了删除的结点的上一结点。   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/leetcode-%E4%B8%80%E5%91%A8%E5%B0%8F%E8%AE%B0-no.1/","summary":"刷的脑壳疼，在螺旋矩阵卡了很久，其他的 easy 题都也被卡，目前进度为 2-3 medium / day。 Monday （科普知识） 反码、补码 二进制的第一位是符号位，0是+，1是-，","title":"LeetCode 一周小记 No.1"},{"content":"Spring MVC的优点有哪些？   可以支持各种视图技术,而不仅仅局限于JSP；\n  与Spring框架集成（如IOC容器、AOP等）；\n  清晰的角色分配：\n 前端控制器(dispatcherServlet) ； 请求到处理器映射（handlerMapping)； 处理器适配器（HandlerAdapter)； 视图解析器（ViewResolver）；    支持各种请求资源的映射策略；\n  DispatcherServlet处理流程 Spring MVC框架的控制器（Controller）解析用户输入并将其转换为一个由视图呈现给用户的模型。\n控制器的核心DispatcherServlet处理请求和响应，处理流程如下：\n DispatcherServlet向处理器映射器（HandlerMapping）请求获取Handler。 返回Handler给DispatcherServlet。 DispatcherServlet向处理器适配器（HandlerAdapter）请求执行Handler并返回视图ModelAndView给DispatcherServlet。 向视图解析器（ViewResolver）通过视图名称查找视图并返回给DispatcherServlet真正的视图对象。 进行视图的渲染并返回给DispatcherServlet渲染后的视图。相当于给了controller控制器。以上png为转载，如有侵权，请联系本人。  常见注解 @PathVariable 和 @RequestMapping 和 @RequestParam：\n@PathVariable和@RequestParam不要混淆，\n区别是用法上不同：\n@PathVariable在 @RequestMapping请求路径后接”/{参数名}“，多个参数就再接多个“/{路径中的参数名}”，在对应的参数列表的参数前加上 @PathVariable 注解。该请求路径中参数名和参数列表 @PathVariable 注解的 value，再在网页路径上传入参数。\n而@RequestParam取参读取 /路径？后的name=”参数“，@RequestParam注解有三个参数，\n1、value：参数名。\n2、required：表示当前属性值是否必须存在（默认是true）。\n3、defaultValue：如果value传递参数了，使用参数，如果没有，使用默认值。\n@RequestHeader、@CookieValue也是一样的这三个参数。\n@RequestBody： 注解实现接收http请求的json数据，将json转换为java对象。\n注：@ResponseBody ＋ @Controller == @RestController\n例如：前台Ajax传递到controller的json格式数据绑定到后台方法的参数列表的某个参数上。\n1 2 3 4 5 6 7 8 9  $.ajax({ url:\u0026#34;/login\u0026#34;, type:\u0026#34;POST\u0026#34;, data:\u0026#39;{\u0026#34;userName\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;pwd\u0026#34;,\u0026#34;admin123\u0026#34;}\u0026#39;, content-type:\u0026#34;application/json charset=utf-8\u0026#34;, success:function(data){ alert(\u0026#34;request success ! \u0026#34;); } });   1 2 3 4 5 6  @requestMapping(\u0026#34;/login\u0026#34;) public void login(@requestBody String userName,@requestBody String pwd){ //也可换做是user对象来绑定，会根据属性名赋值， //但是必须属性名和json的key对应上，否则请求不过去。 　System.out.println(userName+\u0026#34; ：\u0026#34;+pwd); }   @ResponseBody： 该注解实现将controller方法返回的java对象转化为json对象响应给客户。 换句话说：表示当前请求的内容直接作为响应体，用于接收。\n注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如前台异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public User login(User user){ return user; } User字段：userName pwd; 那么在前台接收到的数据为：\u0026#39;{\u0026#34;userName\u0026#34;:\u0026#34;xxx\u0026#34;,\u0026#34;pwd\u0026#34;:\u0026#34;xxx\u0026#34;}\u0026#39; 效果等同于如下代码： @RequestMapping(\u0026#34;/login\u0026#34;) public void login(User user, HttpServletResponse response){ //通过response对象输出指定格式的数据 　response.getWriter.write(JSONObject.fromObject(user).toString()); }   @ModelAttribute：\n@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。说白了就是数据回显。 但远远不仅于此\u0026hellip;..\n在方法参数上使用 @ModelAttribute 注解:\n可以描述为数据绑定，注解在方法参数上说明了该方法的该参数将由 model 中取得，如果model找不到，那么该参数会被优先实例化，然后被添加进model，再把请求中所有名称与之匹配的参数填充到该参数中。\n对方法使用 @ModelAttribute ：\n添加该注解的方法会率先其他方法执行。\n如果方法无返回值，就在添加该注解的方法中 model.addAttribute ，在该控制器的其他方法返回的页面可以拿到这个 model。\n有无返回值的 @ModelAttribute 方法区别是，无返回值的是 model.addAttribute(String key,Object value)来向model增加参数，而有返回值的直接将需要增加的参数返回。过程说出来就是赘述，联想一下。\n以上都是在 @ModelAttribute 中不加 value ，这样如果是有返回值的 @ModelAttribute 方法，就会默认返回名称为“返回值类型的小驼峰化的对象名称”，如果指定 value，那就是返回指定的，比如返回值类型是User，那默认名称则为user，指定名称为 pp，那返回参数名称就是pp。\nrest中的get、post、delete、put请求 get是获取资源、post新建资源、put更新资源、delete删除资源。\n在选择method只能发送post和get请求，因此可以用过滤器filter将post请求转化为put、delete请求以达到put、delete的效果。\n编码问题详解 编码问题无外乎两种情况：\n post： 在 web.xml 配置一个 CharacterEncodingFilter 过滤器，设置为 utf-8。 get：在tomcat的 server.xml 文件中，添加 URLEncoding=utf-8。或者对 request、response 参数重新编码。 注意：过滤器顺序：一个应用程序中可能会包含N个过滤器，这N个过滤器一般是没有顺序要求的，但是如果设置了编码过滤器，那么一定要把它放到最上面，保证过滤器的运行。不论是Spring MVC自带的编码器还是自定义的，都要这样。  后端向前端传值的方式 前面都是前端往后端传数据，现在看后端往前端传数据\n前面都是前端往后端传数据，现在看后端往前端传数据\n1、map.put(”msg”,”hello data”)，在参数列表加Map。return 的是页面路径。\n2、model.addAttribute(”mac”,”hello mac”)，在参数列表中加Model 对象名。return 的是页面路径。\n1 2 3 4 5 6 7  @RequestMapping(\u0026#34;/testModel\u0026#34;) public String testModel(Model model){ model.addAttribute(\u0026#34;name\u0026#34;,\u0026#34;赵六\u0026#34;); model.addAttribute(\u0026#34;age\u0026#34;,12); model.addAttribute(\u0026#34;address\u0026#34;,\u0026#34;上海\u0026#34;); return \u0026#34;user\u0026#34;; }   3、modelMap.addAttribute(”mac”,”hello mac”)，在参数列表中加ModelMap 对象名。return 的是页面路径。\n4、也可以用ModelAndView传递数据，方法内new一个modelAndView对象并且“该对象”.setViewName(”页面路径”)，再addObject(”mac”,”hello mac”);return的是“该对象”，上述三种返回的是页面路径。\n1 2 3 4 5 6 7 8 9 10 11  @RequestMapping(\u0026#34;testModelAndView\u0026#34;) public ModelAndView testModelAndView(){ ModelAndView modelAndView = new ModelAndView(); //设置跳转页面名称 \tmodelAndView.setViewName(\u0026#34;user\u0026#34;); //设置携带的参数 \tmodelAndView.addObject(\u0026#34;name\u0026#34;,\u0026#34;赵六\u0026#34;); modelAndView.addObject(\u0026#34;age\u0026#34;,12); modelAndView.addObject(\u0026#34;address\u0026#34;,\u0026#34;上海\u0026#34;); return modelAndView; }   以上都可以用于数据回显，前3种方式的回显数据保存在哪个作用域？\n1、page：当前页面\n2、request ：当前请求 （保存在这）\n3、session：当前会话\n4、application：当前应用\n当使用上述（map、model、modelMap）参数传递数据时会把数据都放置到Request作用域。\n如果要存在session中：在类名上+@SessionAttributes(”msg”);该注解表示每次向request中设置属性值时顺带向session中保存一份。\n转发、重定向 转发：在返回值前面加\u0026quot;forward:\u0026quot;，譬如\u0026quot;forward:user.do?name=method4”\n重定向：在返回值前面加\u0026quot;redirect:\u0026quot;，譬如\u0026quot;redirect:http://www.baidu.com\u0026quot;\n处理静态资源 在处理静态资源时（例如图片），不做处理的话所有请求都会交由dispatcherServlet来处理，但是dispatcherServlet中没有处理静态资源的逻辑，所以访问不到，添加mvc默认配置后就可以了，由\n1  \u0026lt;mvc:default-servlet-hanlder/\u0026gt;\u0026lt;mvc:annotation-driven\u0026gt;   SpringMVC和struct2的区别  SpringMVC的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter） SpringMVC是基于方法开发（一个url对应一个方法），请求参数传递到方法的形参，可以设计为单例、多例。struct2是基于类开发，传递参数通过类的属性，只能设计为多例。  SpringMVC异常处理  可以抛给Spring框架来处理。 可以配置简单的异常处理器，在异常处理器中添加视图页面即可。  SpringMVC的控制器是不是单例模式？如果是，有什么问题？怎么解决？ 是单例模式。 在多线程访问的时候有线程安全问题。 解决方案是在控制器里面不能写可变状态量，如果需要使用这些可变状态，可以使用ThreadLocal机制解决，为每个线程单独生成一份变量副本，独立操作，互不影响。\nSpringMVC 里面拦截器是怎么写  实现 HandlerInterceptor 接口； 继承适配器类，接着在接口方法当中，实现处理逻辑，然后在 SpringMVC 的配置文件中配置拦截器即可。  注意 自定义类型转化器的时候一定要注意对应的属性值 跟 方法中的参数的值要对应起来。\n","permalink":"https://coderrenxy.github.io/posts/blog/spring-mvc%E5%B0%8F%E7%BB%93/","summary":"Spring MVC的优点有哪些？ 可以支持各种视图技术,而不仅仅局限于JSP； 与Spring框架集成（如IOC容器、AOP等）； 清晰的角色分配： 前端控制","title":"Spring MVC小结"},{"content":"讲到Spring就一定绕不开IOC、AOP两个概念了，在我看来Spring的一切都基于IOC，所以先聊IOC吧。\nIOC 什么是 IOC 首先看看 IOC 的作用，我们可以试着写一个从 service 层到 dao 层的用例，会发现如果是一层一层实现了这个用例，将来要修改就要一层层改， 这样耦合度极高，而把控制权交给第三方（ Test 中 new 一个 serviceImpl 来 set 一个 userDao），能达到解耦目的。此时，主动去 new 一个 dao 对象叫正向获取，而等着 serviceImpl 来 set 是等着别人给我这个对象，是反向获取。就像自己找对象（正向）和婚介公司分配对象（反向）。\nIOC 的两种容器及异同 对于 IOC 最重要的是容器，容器管理着 Bean 的生命周期，控制着 Bean 的 DI（依赖注入），那 Spring 是怎么设计的容器？\nSpring 提供两个接口用以表示容器，一个是 BeanFactory，一个是 ApplicationContext，咱们就聊聊异同吧。\n BeanFactory 粗暴简单，可以理解为一个 HashMap，key是BeanName，value 是 Bean 实例，通常只提供注册（put），获取（get）功能，我们称为低级容器。BeanFactory 是 Spring 底层 IoC 容器，ApplicationContext 是 BeanFactory 的子接口。在该接口中利用反射创建对象。 ApplicationContext称为高级容器，因为他比BeanFactory多了更多功能，他继承了多个接口。因此具备更多功能，例如资源的获取、支持多种消息（例如jsp tag的支持）、对比BeanFactory多了工具级别的支持等等。所以名字也不是BeanFactory之类的工厂了，而是“应用上下文”，代表整个大容器的所有功能，该接口定义了一个refresh方法（刷新整个容器，即重新加载所有的bean）。 隶属 ApplicationContext 的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer模式），而低级容器只负责加载Bean、获取Bean。值得一提的还有两个容器之间的区别。了解区别之前必须明白IOC在启动过程做了些什么操作，IOC启动过程分为两个阶段：\n1. 容器的启动：加载配置信息，分析配置信息。\n2. Bean的实例：实例化对象，装配依赖，生命周期回调。 两者的区别：BeanFactory 延时加载，只有在使用某个 bean 时（即调用 getBean()方法时），才会对 bean 进行实例化，而 ApplicationContext 在容器启动的时候，一次性完成两个阶段，因此BeanFactory在启动过程不能在容器启动阶段发现配置问题，而 ApplicationContext 可以，但是由于一次性实例化所有的 Bean，启动花费的时间也长。  Bean的生命周期 其实吧，上面的 IOC 启动过程都与 Bean 的生命周期有关，聊到这里就避不开这个话题了。Bean 的生命周期：\n Bean 的定义：beanDefinitionReader（抽象接口约束）加载配置文件（xml、properties、注解、yaml）读取bean的定义信息并包装成BeanDefinition。 执行BeanFactoryPostProcessor 准备 BeanPostProcessor、广播器、监听器。（注：beanfactorypostprocessor 完成对 beanfactory 相关信息的修改和拓展(容器运行需要的对象)。beanpostprocessor 完成对bean的修改或拓展（用户自定义对象））。 Bean 的实例化：在 ioc 中利用反射实例化所有的非懒加载的单例 bean。 Bean 的初始化：\n1. Bean 的属性赋值：实例化后的对象还是一个空对象，根据 Bean 的元信息对该对象的所有属性进行赋值。即 PopulateBean 方法。\n2. 执行 Aware 接口的方法。Bean 分为两种，一种是用户 bean 对象，一种容器对象 bean（environment、applicationContext、beanFactory），aware 接口是为了使某些用户 bean 对象能够方便的获取容器bean对象。\n3. 执行 BeanPostProcessor（增强器）的 before 方法。“增强 Bean（AOP）”。\n4. 执行 init-method 方法。\n5. 执行 BeanPostProcessor（增强器）的 after 方法。 对应过程 before，这样就获得了完整对象。如果一个对象需要生成代理对象来增强 bean，会进行反射的普通创建一个实例化的对象，所以叫拓展。不是所有的 bean 都会增强，所以一定是会创建新的（代理）对象。 Bean 的调用：有三种方式可以得到 Bean 并进行调用：  使用 BeanWrapper。 使用 BeanFactory 。 使用 ApplicationContext。   Bean的销毁：  使用配置文件中的 destory-method 属性。 实现 org.springframwork.bean.factory.DisposebleBean接口。    Spring 中可以出现两个 ID 相同的 bean 吗，如果不行会在什么时候报错 分情况，同一个 spring 配置文件里不能存在 id 相同的 bean，会在解析 xml 文件转换为 BeanDefinition 阶段报错。\n不同的 spring 配置文件里可以存在 id 相同的两个 bean，默认会把多个 id 相同的 bean 进行覆盖。\nspring 3.x 版本后使用 @Configuration 进行配置的时候：\n 同一个配置类中使用 @Bean 声明多个相同名字的 bean 默认只会注册第一个。 使用 @Autowired 可能会提示找不到未注册的类。 使用 @Resource 注解会在 bean 初始化之后依赖注入的时候可能会提示类型不匹配错误  IOC常见的实现方式 IOC是个原理（基于工厂模式+反射机制），是把以前在工厂方法中写死的对象生成代码，改由配置文件来定义，真正的实现方式常见的有两种： 1、依赖注入。 2、依赖查找。\n两者都是调用相关接口获取bean对象，区别在于DI（依赖注入）是IoC容器启动时由容器帮你实现，DL（依赖查找）要手动。目前用到DL（依赖查找）的非常少了，所以来聊聊DI（依赖注入），依赖注入从XML配置上来说就是ref标签，对应的是Spring中的RuntimeBeanReference对象，实现方法如下。\nDI（依赖注入）的实现方式  构造器注入：构造器依赖注入通过容器触发一个类的构造器来实现的，通过构造器的参数注入相关依赖对象。用xml文件配置就是property中通过construct-arg来指定构造器的参数，用注解配置就是在构造方法上加上@Autowire注解。这种方式好比学渣从一开始就赖上了一个学霸，并且和这个学霸建立了长期合作关系。 setter注入：通过 setter 方法注入依赖对象，也可以理解为字段注入。通过Xml配置就是property中指定name=”age”或Age；ref=”\u0026hellip;..”。因为Spring会自动的将首字母大写再在前面加上set，这里也可以看到，有关的是set方法后的名称，而与属性（成员变量无关）。用注解来写就是在setter方法上加上@Autowire注解。这种方式学霸和学渣只是暂时的合作关系，如果学渣赖上了另一个学霸（调用set()方法传入了另一个对象），那么学渣和上一学霸的合作关系就结束了。 属性注入（方法参数注入）：定义成员变量来添加@Autowire注入。这种方式不建议使用，但是工作中用的最多，因为真的方便。这么方便为什么不推荐？如果是IOC以外的环境，除了使用反射来提供他需要的依赖，无法复用该实现类。  那setter注入和构造器注入用哪个？看上面我的描述，构造器不是有点强买强卖的意思？所以构造器参数实现强制依赖，setter方法实现可选依赖。构造器注入可以保证有序的被注入，而setter方法注入是通过反射机制注入，无法保证注入顺序。构造器注入不允许出现循环依赖，因此被注入的对象需要保证能实例化，构造器依赖初始化时对象才注入依赖对象，保证了bean初始化后就是不变的对象。setter方法的循环依赖Spring已经解决了，先聊聊循环依赖吧。\n这里多嘴提一句Autowired：@Autowired默认是byType，类型一样时会根据id查找，默认的id为类名（自动改为首字母小写）。找到了直接注入，找不到报错。如果指定id（别名）就是用@Qualifier。如果@Autowired添加在方法上时，此方法在创建对象的时候会默认调用，同时方法中的参数会自动进行装配。@Autowired也能用在方法的参数上指定当前属性的别名。Jdk提供了@Resource和@Autowired一样的功能。Resource可以在其他框架中用，是按照id进行装配的，id找不到就用type。Autowired通过反射来注入。\n循环依赖 （只有单例Bean才会出现循环依赖）\n如果一段依赖关系为beanA\u0026ndash;\u0026gt;beanB\u0026ndash;\u0026gt;beanC\u0026ndash;\u0026gt;beanA，这就是循环依赖。如果没有最后一个beanA而是beanA\u0026ndash;\u0026gt;beanB\u0026ndash;\u0026gt;beanC，此时Spring将创建beanC，然后创建beanB（并将beanC注入beanB）然后创建beanA（并将beanB注入beanA），但是在有两次beanA时，Spring无法决定应该首先创建哪个bean（注意：这里是创建，不是初始化，初始化在上文Bean的生命周期有记载，是根据用户xml中对bean定义的顺序来加载，若有依赖，先用占位符_代替，那为什么不在加载Bean的时候直接注入呢？因为我们并不能要求用户按照顺序定义Bean，这样是不人道的！可能A依赖于B，但是B还没有加载好），因为他们彼此依赖，这个情况下Spring将在加载上下文时引发BeanCurrentlyInCreationException。使用构造方法注入时，他可能在Spring中发生，其他类型应该无此问题（setter注入的循环依赖已经被Spring解决）。\n 那在构造器注入中如何解决循环依赖呢?其实方法很多，当然我们只讲流行的，况且最好的方法就是重新设计或者用setter注入，简单了解一下吧。   使用@Lazy放在构造方法参数列表的参数前，意思就是懒洋洋的初始化其中一个bean。它不是完全初始化bean，而是创建一个代理将它注入到另一个bean。注入的bean只有第一次需要时才会完全创建。用人话来讲就是第一次被需要才创建，之后在需要这个bean就是创建它的代理对象。\n  在其中一个bean上加@AutoWired，其他依赖项上使用@PostConstruct。\n那我们肯定还是要了解一下setter注入中Spring是怎么解决循环依赖的吧！\n   先透个实底：Spring通过提前暴露对象的方式解决循环依赖问题，即 对“半成品对象”（实例化后、初始化前的对象叫做“半成品对象”）设置缓存来预存对象，等后续再根据A对象的引用来完成赋值操作，实例化后、初始化前的对象叫做“半成品对象”。这里缓存有三级。了解三级缓存前，先了解spring常用的6个方法：\t1  getBean--\u0026gt;doGetBean--\u0026gt;createBean--\u0026gt;doCreateBean--\u0026gt;createInstance--\u0026gt;populateBean   \t那三层分别什么作用? 一级缓存singletonObjects：存放成品对象。 二级缓存earlySingletonObjects：存放半成品对象。 三级缓存singletonFactories：存放lamdb表达式。  为何要有三级？只用第一级行不行？只用一、二级行不行? 别着急，小任细细道来。\n如果只有一级缓存：那么意味着半成品对象和成品对象都要放到一级缓存，那就有可能获取到对象的非完整状态，此时不可以使用。\n如果只有一二级缓存：没有AOP的时候就可以，三级缓存是解决代理过程中的循环依赖。\n 总结一下以上：每次我们在获取对象的时候，是通过对象的name来获取bean的，如果原始对象和代理对象同时存在的话，那么我通过名字再进行获取的时候应该选择哪个？无法选择的，其实还有最核心的点，你怎么能够确认对象什么时候需要被引用呢？使用lambda表达式其实代表了一种回调机制，当需要使用当前对象的时候，通过lamdba表达式来最终返回一个确定的最终版本对象，而不需要判断几个对象，因为是替换的过程，所以只能有一个。接下来给IOC留个结尾干巴的面试题吧，干就完了！  Spring核心类  BeanFactory：产生一个新的实例，可以实现单例模式。 BeanWrapper：提供统一的get及set方法。 ApplicationContext:提供框架的实现，包括BeanFactory的所有功能。  Spring中的设计模式  工厂模式：Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象。 单例模式：Bean默认为单例模式。 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。 模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate, JmsTemplate, JpaTemplate。 适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式，Spring MVC中也是用到了适配器模式适配Controller。 策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略。 观察者模式：Spring事件驱动模型就是观察者模式的一个经典应用。 桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库。  Bean的作用域  singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。 prototype：原型范围与单例范围相反，为每一个bean请求提供一个实例。 request：在请求Bean范围内会对每一个来自客户端的网络请求创建一个实例，在请求完成以后，Bean会失效并被垃圾回收器回收。 session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。（不知所云）  ApplicationContext 通常的实现  FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。 WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。  AOP 温馨提示：上面IOC没捋顺就别往下看AOP了\n通知 大家都是怎么描述AOP和其中各种名词呢? 听听小任的见解。\n想象一下：方法是纵向的，而各种打印的日志信息就都是横向的，横纵向的交汇点就是连接点，通俗来讲一个方法中可以填入额外的代码的地方都叫做连接点，而实际填充了代码的叫做切入点，切入点是连接点的子集。切面类就是存放打印日志方法的logUtil类，每一个切面类对应的方法都是横切面，使用AOP的话就在切面类上加@Aspect。 通知注解的几种类型：\n @Before前置通知：方法执行前执行。 @After后置通知：方法执行后执行。 @AfterReturing返回通知：结果返回后运行。 @AfterThrowing异常通知：出现异常时使用。 @Around环绕通知：其他四个注解都是方法被调用就会根据情景来执行的，比如异常了就执行@AfterThrowing，其他四个注解都是被方法绑死，而环绕通知比较特殊，他能决定一个类是否需要返回对象，能决定该方法是否被调用。它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。  执行顺序：环绕前置通知\u0026ndash;\u0026gt;before\u0026ndash;\u0026gt;环绕后置通知\u0026ndash;\u0026gt;after\u0026ndash;\u0026gt;afterReturing或者：环绕前置通知\u0026ndash;\u0026gt;before\u0026ndash;\u0026gt;环绕后置通知\u0026ndash;\u0026gt;after\u0026ndash;\u0026gt;afterThrowing。\n这些通知都需要指定方法的权限修饰符、方法的返回值类型、方法的全限定名。在方法的参数的列表中不要随便添加参数值，会异常，如果需要参数就在参数列表加上joinpoint来getArgs（获取参数列表），返回值在注解中指定（returning=”result”）之后才能从在方法的参数列表指定。execution精确匹配的方式其实并不友好，一般用的是通配符（*和.）的方式也可以多个execution来进行逻辑运算（与或非）。\n需要注意的是，一个通知只能针对一个特定的连接点（即切点）。因此，如果需要在不同的切点上应用不同的通知，就需要定义多个切面类。 在一个切面中放置多类通知是正常的，并且常用。\n代理 讲到AOP一定逃不掉的一个东西：动态代理的实现\n有动态，那静态呢？ 动态代理的代理类是动态生成的 ，静态代理的代理类是我们提前写好的。 那为什么要有动态代理呢？且先看看静态代理的优劣：\n静态代理的好处是：我们的真实角色更加纯粹 . 不再去关注一些公共的事情 ，公共的业务由代理来完成， 实现了业务的分工，公共业务发生扩展时变得更加集中和方便。说白了就是（动态、静态）代理类的好处。\n静态代理的缺点是：类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 。 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n动态代理的核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理。 两种实现方式：\n JDK代理：基于接口的动态代理。 CGlib代理：基于类的动态代理。 二者区别是：JDK代理只能对实现接口的类生成代理，利用反射机制生成一个匿名类，CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，但是这种通过继承类的实现方式不能代理final修饰的类。  如何实现JDK动态代理？\t（JDK 动态代理最核心的一个接口和方法如下）\n InvocationHandler 接口：使用方法首先是需要实现该接口，并且我们可以在 invoke方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法的前后去做一些额外的事情，从而实现动态代理。传入的参数如下：\n1. proxy：被代理的类的实例；\n2. method：调用被代理的类的方法；\n3. args：该方法需要的参数； Proxy 类中的 newProxyInstance 方法：该方法会返回一个被修改过的类的实例，从而可以自由的调用该实例的方法。传入参数如下：\n1. loader：被代理的类的类加载器；\n2. interfaces：被代理类的接口数组；\n3. invocationHandler：调用处理器类的对象实例；  Spring的事务 事务分为两种：声明式事务、编程式事务。一一介绍一下，先来精简的。\n 编程式事务：在代码中直接加入处理逻辑，可能需要在代码中显式调用beginTransaction、commit、rollback方法。 声明式事务：方法外部添加@Transational注解或在配置文件中直接定义，将事务代码和业务方法分离，以声明的方式实现事务管理。AOP恰好能完成，通过AOP方法模块化，进而实现声明式事务。其中，声明式事务用法值得一提其中的属性：\n1. isolation：隔离级别。（大写不方便本人认读，所以还是小写）事务应该不会陌生吧?跟着MySQL/Oracle走，如果是MySQL，那隔离级别默认为RR（可重复读Read Repeated）Oracle则是默认RC（读已提交Read Commited)。\n2. timeout：超过时间。\n3. readonly：设置为只读事务。\n4. noRollBackfor：设置为发生该异常也不回滚（指定异常类的类名.class）只对特定异常类起作用。\n5. rollBackfor发生指定异常回滚（指定异常类的类名.class）只对特定异常类起作用。   持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/spring%E6%9D%82%E8%AE%B0/","summary":"讲到Spring就一定绕不开IOC、AOP两个概念了，在我看来Spring的一切都基于IOC，所以先聊IOC吧。 IOC 什么是 IOC 首先看看 IOC 的作用，","title":"Spring杂记（顺着链条自上往下看）"},{"content":"​\n首先了解关于数据库一个误区，我们用的 MySQL、Oracle 都是 DBMS（数据库管理系统），用来操作数据的，而数据库是用来存数据的，而 sql 是结构化查询语言。程序员来写 sql 语句，DBMS 来执行 sql 语句。再一个，数据库是存储数据，数据库实例才是操作数据。\n三大范式 数据库表设计的三大范式：\n避免数据冗余、空间浪费。但有时候需要空间换时间的反范式优化，具体情况根据业务具体分析。比如父表冗余一些数据到子表中是为了排序。\n第一范式：要求任何一张表必须有主键，每一个字段具有原子性（不可再分）。\n第二范式：建立在第一范式之上，要求所有的非主键字段完全依赖主键，不要部分依赖主键。\n第三范式：建立在第二范式之上，要求所有的非主键字段直接依赖主键，不要传递依赖主键。\n理解1NF：考虑这样一个表：【联系人】（姓名，性别，电话） 如果在实际场景中，一个联系人的电话有家庭电话和公司电话。\n那么这种表结构设计就没有达到1NF。 要符合 1NF 我们只需把列（电话）拆分。 即：【联系人】（姓名，性别，家庭电话，公司电话）。 1NF 很好辨别，但是 2NF 和3NF 就容易搞混淆。 理解2NF：当主键为联合主键时，其它字段只依赖于联合字段的一部分就是部分依赖。 理解3NF：也就是非主键字段不能产生依赖。\n事务 事务是一个完整业务逻辑的最小工作单元，只有 DML （增删改）语句和事务有关，操作涉及数据的增删改就要考虑安全。 本质是多条 DML 语句同时成功 or 同时失败。 事务执行过程中，每一条 DML 的操作都会记录到“事务性活动的日志文件”中。 事务的执行过程中我们可以提交事务 or 回滚事务。默认是每执行一条 sql 提交一次，如果要关闭就要使用开启事务命令，这个命令可以理解为关闭每条都自动提交，也可理解为开启事务。\n开启事务的方式有两种：\n begin/start transaction 命令：只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机； start transaction with consistent snapshot 命令：执行了该命令，就会马上启动事务。\n提交事务：清空事务性活动日志，将数据全部彻底持久化到数据库表中。\n回滚事务：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件，回滚事务标志着事务的结束，并且是 失败的结束。 a向b转 1w。 将a的-1w。 将b的+1w。\t这就是一个完整的业务逻辑。 事务四个特性：   A ：原子性：说明事务是最小的工作单元，不可再分。 C ：一致性：所有事务要求，在同一个事务当中，所有的操作必须同时从成功或者同时失败。 I ：隔离性：A 事务和 B 事务必须具有一定的隔离性。 D ：持久性：事务最终结束的一个保障，事务一旦提交就是永久性的。   事务的隔离级别   读未提交（ Read Uncommitted ）：\nA 可以读取到 B 未提交的数据，存在脏读、不可重复读、幻读问题！\n  读已提交（ Read Committed ）:\n事务 A 只能读到事务 B 已提交的数据，解决了脏读！但是存在不可重复读、幻读问题！事务 A 执行到一半，突然事务 B 从头到尾执行完了，在事务 B 执行完到事务 A 结束完这段时间查询数据可能发生了变化。 Orcle 默认是这个级别。 每次读取都是新的快照。\n  可重复读（Repeatable Read）：\n事务A开始之后，不管多久，同一事务内读取到的数据都是一致的，相当于读取的是事务开始执行时拍下的快照。即使A事务执行过程中事务B已insert并提交了，事务A读取到的数据条数仍然没变。解决了不可重复读问题，但是存在幻读问题！ 可能A事务执行到一半，B事务执行完了，在事务中查询到的数据是读到了假象，其实数据条数已经变了，只是在事务中是没有改变，事务后再读取就改变了，改变的如果是事务B插入的就是幻读，如果是事务A插入的就不是幻读。可重复读不允许其他事务 进行update操作，但允许其他事务进行insert操作。这是MySQL默认隔离级别。每次读取都是第一次的快照。\n  序列化读（serializable）：\n表示事务排队，不能并发！\n如何解决幻读   首先我们知道快照读是普通的 select。\n快照读不会加锁，当前读会加锁。\n除了普通 select 操作，其余操作都是当前读。也正因为普通的查询是都快照读，所以当前事务是不会看到别的事务插入的数据的。\n因此，幻读问题在 “当前读”下才会出现。当前读就是读取最新版本数据。\nMySQL 通过加 Next-Lock Key（行锁+间隙锁） 的方式来解决幻读，Next-Lock Key 锁的规则比较复杂，在某些情况会退化为行锁、间隙锁来提高效率。\n通过锁住对应的范围来防止其他事务对该范围内数据进行增删进而防止改变数据条数。但是注意 Next-Lock Key 锁住的是索引，不是数据本身，如果 where 后无索引列，那么相当于整个表都被锁死，直到事务结束。\n对应的 RC\u0026ndash;\u0026gt;RR 当前读的不可重复读是靠行锁解决。\n加锁语法\nselect \u0026hellip; lock in share mode：加共享(S)锁\nselect \u0026hellip; for update：加排他(X)锁\ninsert / update / delete：加排他(X)锁\nNext-Key Lock 的算法 假设索引 a 有1，3，5，8，11，其记录的GAP的区间如下：是一个左开右闭的区间（原因是默认主键的有序自增的特性） （-∞,1]，(1,3]，(3,5]，(5,8]，(8,11]，(11,+∞） select * from t where a = 3 for update; 那么锁住的范围有 (1,3）3，(3,5] 即 当前行+两边的间隙 (1,3]，(3,5]， 这些范围的行数据和索引都被锁住，所以可以防止 insert 或者 delete 带来的幻读。\n但是注意，对于RR默认使用的就是 next key lock，但是对于“唯一索引” ，比如主键的索引，next key lock 会降级成行锁 Record Lock ，即仅锁住索引本身，而不会锁住一个区间。唯一索引的等值条件就是从 next lock key降级成行锁。\n而范围条件如\nselect * from t where a \u0026gt; 3 for update;\n就降级到间隙锁锁住(3,5]。如果条件是\u0026gt;=3那就是行锁+间隙锁都用上了。  锁机制 锁分了乐观、悲观两大类别\n悲观锁和乐观锁区别如下： 悲观锁是在是否能操作数据上就做了处理。假设会发生冲突。\n悲观锁的实现 悲观锁是数据库已实现的，如共享锁、排它锁。\n共享锁 又称为读锁，如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁读取数据——直到该数据对象上的所有共享锁都被释放。修改是唯一的，必须等待前一个事务commit， 才可进行操作，因此，如果同时并发太大可能很容易造成死锁。\n排它锁 又称为写锁或独占锁，如果事务 T1 对数据对象 O1 加上了排他锁，那么在整个加锁期间，只允许事务 T1 对 O1 进行读取和更新操作，其他任何事务都不能再对这个数据对象进行任何类型的操作（读、写）——直到 T1 释放了排他锁， 结果是超时或者等待第一个事务提交后再执行，相当于行锁。\n排它锁和共享锁区别：\n加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。\n误区：对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个认知错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。 排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。MySQL 的 InnoDB 引擎自动的给修改数据语句（update,delete,insert）涉及到的数据加上排他锁，select 语句默认不会加任何锁类型。因此可以说明数据只要不加锁， 普通的 select\u0026hellip;form\u0026hellip; 是没有问题的，而加锁的 select 就读不到，值得一提的是加共享锁、排它锁都是显式的加锁，但是隐式的加锁（insert、delete、update）也读不到数据，原因就是不能加锁。\n手动给查询语句加排它锁：select \u0026hellip; for update。\n手动给查询语句加共享锁：select \u0026hellip; lock in share mode 。\n所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过加排他锁或共享锁的方式查询数据，但可以直接通过select \u0026hellip; from \u0026hellip; 查询数据，因为普通查询没有任何锁机制。\n乐观锁下大家都可以同时写数据只是在提交的时候做了处理。乐观的假设不会发生冲突。\n乐观锁可以避免数据库幻读、业务处理时间过长等问题，适合读多写少，可以提高程序的吞吐量解决了写-写冲突。 而乐观锁要自己实现，如何实现呢？\n乐观锁的实现 CAS Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。\n版本号控制 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时， 若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\nMVCC MVCC其实就是乐观锁的一种实现方式，MVCC只能在读已提交（RC）和可重复读（RR）两种隔离级别下工作，读未提交总是会读到最新的数据行，而不是符合当前事务版本的事务行的快照读，串行化是通过加锁互斥数据，因此不存在隔离问题。\n不好理解？\n那换句话说：\n对于使用Read Uncommitted隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；\n对于使用Serializable隔离级别的事务来说，InnoDB使用加锁的方式来访问记录。 MVCC如何工作：\nMVCC是一种基于版本链的无锁并发控制，即使有读写冲突时，也能做到不加锁，非阻塞并发读。\nMVCC仅在RC、RR下运作，原理就是 Read View（快照读） 四个参数、数据库表的两个隐藏列。 Read View 四个参数：活跃事务列表（m_ids）、最小活跃事务id（min_trx_id）、最大活跃事务id+1（max_trx_id）、创建当前 Read view 的事务 id（**creator_trx_id **）。\n数据库表两个隐藏列：\ntrx_id：当一个事务对某条聚簇索引记录进行改动的事务 id。\nroll_pointer：指向上一版本的 undo 日志。\nMVCC 在 RC、RR 下的工作\n一个事务访问记录时除了自己的更新记录可见（trx_id = creator_trx_id），就是隔离级别分辨哪些版本的记录对当前事务可见。\n分辨 已提交的事务、活跃事务、未开启的事务\n通过 trx_id 比较是否 \u0026lt; min_trx_id 或是 \u0026gt;= max_trx_id，是的话该事务就不在活跃事务列表也就不是活跃事务，小于是已提交事务，大于等于是未开启的事务版本记录。 又或是 min_trx_id \u0026lt;= trx_id \u0026lt; max_trx_id，那么当前记录可能在活跃事务列表，需要判断 trx_id 是否在 m_ids 列表中：存在就是活跃事务版本，否则就是已提交事务。\nRC\n因为每次查询数据都会生成一个 read view 所以其中的四个参数一直在变，因此每一次都可以拿要查询的记录的 trx_id 去查询该事务是否已提交，只要是已提交的事务版本就可见，如果未提交就沿着 undo log 链条往下找旧版本的记录 ，直到找到已提交。\nRR\n因为每次查询都是该事务开启时生成的 read view ，所以每次拿到要找的记录的 trx_id 去和 对应 read view 对比找到已提交的最终版本（和RC一样步骤）。\ntrx_id 如何联系 read view\ntrx_id 隐藏列 与 creator_trx_id 参数。\n事务版本号如何计算 事务版本号随着事务的开启顺序依次递增。 存储引擎 MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。 MySQL默认的存储引擎是InnoDB，默认字符集是UTF-8，建表时指定存储引擎和字符编码方式。 MySQL支持九大引擎，版本不同支持情况不同。 存储引擎表示不同的数据在磁盘中的不同组织形式。\n MyISAM存储引擎？ 它管理的表具有以下特征：只支持表锁、不支持外键、不支持回滚。 格式文件 - 存储表结构的定义（mytable.frm） 数据文件 - 存储表行的内容（mytable.MYD） 索引文件 - 存储表上的索引（mytable.MYI） MyISAM优势：可被转化为压缩、只读表来节省时间。 InnoDB存储引擎 这是MySQL默认的存储引擎，是个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。支持表锁行锁。 InnoDB存储的特点：非常安全。 MEMORY存储引擎 数据存储在内存中，且表的长度固定，这两个特点使得MEMORY存储引擎非常快。不安全，关机数据消失。  InnoDB中存储数据 InnoDB中存储数据是按行存储的，但数据库的读取是以页为单位读取，也就是说当需要读取一条数据时，并不是将这个记录本身从磁盘中读取出来，而是以页为单位，将其整体读入内存。也因此数据库的 I/O 操作的最小单位也是页， InnoDB的数据页默认大小为16KB。也就是说一次至少把 16KB 的内容读取到内存。\n数据页由7个部位\n主从复制 主从复制的作用  读写分离，降低服务器压力实现了负载均衡。 主服务器出现故障时可切换到从服务器，提高性能。 从服务器备份避免备份过程影响主服务器服务，确保数据安全。  主从复制的原理 数据库下bin-log二进制文件，记录了所有的sql语句，把主数据库下的bin-log文件的sql语句拷贝过来让其在从数据库的redo-log（重做日志文件）再执行一遍这些sql语句。需要三个线程操作。\n1. binlog线程：每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建下列的两个线程进行处理；\n2. dump线程：主节点为每一个从节点创建一个 dump 线程，当 binlog 有变化，dump 线程就会通知从节点，并将 binlog 传递给从节点的 IO 线程。\n3. Io线程：当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，接收到了内容后写入到 relay log（中继日志），再返回给主库“复制成功”的响应。 4. Sql线程：从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。\n主从复制和主主复制区别 最大区别是： 主从复制是对主数据库操作数据，从数据库会实时同步数据。对从数据库操作，主数据库不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主复制则是无论对哪一台操作，另一个都会同步数据。一般用作高容灾方案 。\nlimit使用  当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量,例如 select * from user limit 1,3; 取到 2，3，4 当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。例如select * from user limit 3 offset 1; 取到 2，3，4  索引 索引是在存储引擎用于提高数据库表的访问速度的数据结构，如果不添加索引查询会加载所有的数据进内存依次检索。\n索引在数据库表的字段上添加，为了提高查询效率。一张表的一个字段可以添加一个索引，也可以多个字段联合。\n索引的使用场景  数据量庞大。 该字段常出现在where后面，以条件形式存在，也就是说这个字段总是被扫描。 经常用于 GROUP BY 和 ORDER BY 的字段。 该字段很少的DML（增删改）操作。因为DML之后，索引需要重新排序。  索引的设计原则  区分度越高越好。 尽量使用短索引，较长字符串进行索引的时候应该指定个较短前缀，因为较小索引 I/O量小查询速度快。 索引不是越多越好，每个索引要花额外的物理空间，维护要需要时间。 利用最左前缀原则。  根据索引查询的原理 例如 select * from t_user where id =101；发现id字段上有索引先通过索引对象idIndex进行树的查找，通过 id=101 得出物理编号0x666 ，此时会转换SQL语句为： select * from t_user where 物理编号 = 0x666；\n索引分类 单一索引、联合索引、主键索引、唯一性索引。（唯一性弱的字段添加索引用处不大）。 MySQL 中如果有 unique 约束也会自动创建索引对象，其实殊途同归，任何数据库的主键都会自动添加索引对象，其实都是为唯一键建立的索引，而主键是唯一且非空。\n在MySQL 中，索引是一个单独的对象，索引在不同的存储引擎以不同形式存在。\nMyISAM 存储引擎中，索引存储在.MYI 文件中。\nInnoDB 存储引擎中索引存储在一个逻辑名 tablespace 的空间当中。\nMEMORY 存储引擎中，索引存储在内存当中。\n不管索引存储在哪里，索引在 MySQL 当中始终都是树的形式存在。\n索引要排序，排序了才有区间查找，并且这个索引的排序和 TreeSet 数据结构相同，一个自平衡的二叉树。\nMySQL的数据存储在磁盘中，查询慢一般卡都是在 I/O 过程，尽可能减少 I/O 的次数和 I/O 的量，可以有效优化查询速度，而这二者之间更重要的又是 I/O 次数。因此“矮胖”型的树结构是性能最高的。\n索引的存储 索引存储的时候需存文件地址、偏移量offset、key，可以用 哈希表，树（二叉树、红黑树、AVL树、B树、B+树）为什么最后用B+树存。\n为什么不用哈希表来存(k-v)\n首先哈希表来存确实有个优点就是：等值查询时，速度很快！但同样它有以下缺点如：\n 哈希冲突导致数据散列不均匀，会产生大量的线性查询，比较浪费时间。 必须等值判断来查询，不支持范围查询，当进行范围查询时必须挨个遍历。 对于内存空间的要求比较高，要把所有数据加载到内存才能操作找到对应的数据。   MySQL 中常见的存储引擎有没有hash索引\n memory 存储引擎使用的是hash索引。 Innodb 支持自适应 hash 索引，key 是索引列的 hashcode，指向行记录的指针是 value 。查找一条数据的时间复杂度O（1），多用于精确查找。   为什么不用普通树的结构 如果用的是普通二叉树，那数据插入是递增的时候就会从二叉树 O（logn）退回成链表 O（n）。但是可以通过左旋或者右旋让树平衡起来弥补这一缺陷，此时形成的是 AVL （平衡二叉树）： 最短子树跟最长子树高度只差1，为了保证平衡，在插入数据的时候必须要旋转，通过插入、删除性能的损失来弥补查询性能（插入、删除会调整节点）。\n但是此时又出现了新的问题：如何 读 \u0026raquo; 写，AVL 是划算的，但是读写差不多甚至 写 \u0026raquo; 读 呢？\n所以就要左旋右旋的次数减少来提高增删的效率。怎样使得它更少的旋转呢？\n为什么不用红黑树 通过变色减少旋转的次数，最长子树只要不超过最短子树的两倍即可，既有旋转又有变色，使得插入和查询性能近似取得平衡。但是随着数据的插入，发现树的深度会变深，树的深度越深，意味着 IO 次数越多， 影响数据的读取效率，而且由于局部性原理（经常被查询的数据有聚集成群的倾向，同时刚被查询的数据有可能很快被再次查询）、磁盘预读，使得它不得不做出改变，做出了在树的横向做文章 的改变，一个头节点对应多个子节点就解决了这个问题，这是采用的数据结构就是 B树 了，树的深度会小很多，一般\u0026lt;=3，深度是算出来的，不是指定的。这种情况下实际存储的数据为：key，完整的数据行。但 是它叶子节点和非叶子节点都存有数据行使得树在每一深度的索引都存的十分有限，不理解？\n举个例子：假设一个磁盘块的大小为 16k ，假设一条行数据 1k ，树深度为三层。\n第一层 16k 最多存 16 个行记录。\n第二层能存 16×16 个行记录。\n第三层 161616条记录 = 4096条。\n这效率太低了吧？\n只让叶子节点存数据，非叶子节点只存 索引 和 key 值，一二层就能存更多的磁盘块索引，这就是 B+ 树。我们来算算，如果没有创建主键约束、唯一键约束、系统会自生成 6字节的 rowId 给它作为聚簇索引 的 key 是 6+6（指针大小在 InnoDB 源码中设置为6字节），这能存多少？大概两千多万。而且 B+树 的叶子节点用指针连接，提高区间访问性能也方便扫库。那索引是用 int 还是 varchar 呢？Varchar超过四 个字节用 int ，小于四个字节用 varchar，因为空间固定是16kb，每个索引*索引个数\u0026lt;= 16kb，占的单个字节越少，存储的字节就可以越多。索引的创建和存储引擎是挂钩的。是否是聚簇索引取决于数据是否和 索引放在一起。Innodb 只能有一个聚簇索引（为了防止数据冗余，如果有多个聚簇索引，就会导致一份数据存多份，多个索引，只能有一个作为 key，如果多个作为 key 就冗余了），但是可以有很多非聚簇索引 ：向 innodb 插入数据时必须要包含一个索引的 key 值，这个索引的 key 值可以是主键，如果没有主键就是唯一值，如果没有唯一值那就是自生成的6字节的 rowId 当聚簇索引 key 。如果一个表中的普通列创 建了索引，那么叶子结点存放的值是聚簇索引的 key 值。 Myisam 全是非聚簇索引，但是与 innodb 中不同的是，innodb 直接放数据行，myisam 放的是数据行地址，根据地址再去找数据。聚簇索引是和数据文件和索引文件放在一起的索引。 *B+树三层怎么算的（n叉查找树） 三层可以存储大约2千万行数据\n InnoDB存储引擎默认最小存储单元是页，默认一个页的存储大小是16K（可以修改，通过设置参数innodb_page_size） InnoDB的所有数据文件（后缀为ibd的文件）它的大小始终是16K的整数倍 页可以存储数据也可以存储键值+指针，在B+树叶子节点存放数据，非叶子节点存放键值+指针 如果这一页存储的是非叶子节点，假设主键id为bigint类型，长度为8个字节，页号在InnoDB中是4个字节。这样一共12个字节，则一页能能存储多少个这样的单元，就代表一页能存储多少指针，即大约16384/12=1280 个指针 如果这一页存储的是叶子节点，假设一行记录大小为1K(实际上很多互联网业务数据记录大小通常就是1K左右），则一页可以存储16条记录。 若一颗高度为2的B+树，则能存放大约1280 X 16 = ？条记录 ，为什么X16：1层的16k数据页可以放1280 个（索引+指针），分布到第二层是1280 个数据页，每个数据页不仅仅包含这一条1k的行记录，而是还有其他15k行记录。 同样，若一棵高度为3的B+树，能存放1280 X 1280 X 16 = 2.45k万数据。 所以InnoDB中B+树的高度一般为1~3层，就能满足千万级的数据存储。 在查询数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1~3次 I/O 操作即可查找到数据。  索引的失效  对一个索引字段模糊查询时%写在索引左边失效（特殊情况：表里 只有该字段+聚簇索引）优化器判定可以索引覆盖也就无需再全表扫描，除非有其它非聚簇索引字段，那么需要走两张表而且左模糊查询并不能体现b+树的有序性查找性能，还不如只走聚簇索引树全表扫描一张表。 使用or的时候可能失效，要求or两端的字段都有索引才会走索引，union不会让索引失效。 （最左原则）使用复合索引的时候没有使用索引左侧的列查找，索引失效。 where当中索引列参与了运算，索引失效。 在where中索引列使用了聚合函数。Explain select * from zs_case where lower(case_name)=’rxy’;   、\u0026lt;、!=、not in、in、IS NULL或者IS NOT NULL都会导致。\u0026gt;=、\u0026lt;= 不会。\n  对全表扫描速度比索引速度快的时候不会使用索引。 对索引隐式类型转换。  回表、索引覆盖 回表：以非聚簇索引查找包含非聚簇索引的内容。\n索引覆盖：以非聚簇索引查找聚簇索引。\n一张表四个字段 （id，sex，name，age，name）是索引列，主键是id，select * from table where name=‘rxy’ 该语句先会根据非聚簇索引 name 字段查询到 id，再根据聚簇索引 id 字段查询整行记录，走了两棵 b+树，此时这种现象叫做回表。\nb+树分为非聚簇索引树和聚簇索引树，聚簇索引树叶子节点存放行记录，非聚簇索引树叶子节点保存了2列（聚簇索引，该非聚簇索引）数据。\n就是根据普通索引查询到聚簇索引的 key 值后，再根据 key 值在聚簇索引中获取行记录。如果是 select id,name from table where name=‘rxy’； 该语句根据 name 可以直接查询到 id ，name 两个字段，直接返回即可，不需要从聚簇索引查询任何数据，此时就不需要回表，叫做索引覆盖，走一棵 B+ 树\n回表会增加IO量，会影响效率。 索引下推 索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。\neg：联合索引(A,B,C) 如果 where A=？ and C=？ 无索引下推会走索引 A 从引擎层返回数据到 server 层再在 server 层过滤 C。 而有索引下推直接在引擎层走了 A、C ，因此减少了回表数据。\n设计数据库时id要不要自增 尽量自增，自增不会影响前面的磁盘块，如果不自增，可能插入一个数据在一个容量不够的磁盘块中，则会磁盘块分裂（页分裂），类似的操作删除会导致页合并。\n分裂调整效率比较低，而自增直接append效率比较高。或者说，id由UUID随机生成，比较分裂，随机插入，会造成频繁页分裂，内存碎片化，大量随机IO。 最左匹配原则 联合查询下：\nMySQL内部有优化器： select * from table where 最左索引 = ‘ss’ and 其他索引 = ‘hh’；\n把两个索引位置对换也会走索引。因为优化器会重新把最左索引放在左边。但是如果where中没有用到最左索引，此时其他索引是无序的，就不会走索引。\n如果用范围查询，就会停止该索引字段之后的字段的匹配。\n比如 a = 1 and b = 2 and c \u0026gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，因为 c 字段是一个范围查询，从 c 开始都是无序的，它之后的字段会停止匹配。\n注：联合索引条件下，优化器调整的是写的sql的查询条件的顺序，调整成可以被走最多索引的顺序。\nMySQL常见的日志： redo log（重做日志）：用于掉电等故障恢复。\nundo log（回滚日志）\nbinlog（二进制日志）：全量日志，用于备份恢复、主从复制；\nredo logo redo log 是 InnoDB 引擎特有的，只记录该引擎中表的修改记录。\nbinlog 是 MySQL 的 Server 层实现的，会记录所有引擎对数据库的修改，所有引擎可见。\nredo log 是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。\nredo log 是基于两个文件环形文件组的循环写的，空间固定会用完，用完了就循环写；binlog 是可以追加写入的，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n而 redo log 实际本不需要那么多，因为 redo log只是保证 buffer pool 里的脏数据落盘，脏数据会依次落盘，并不会堆积着。如果满了，那么MySQL更新操作会被阻塞，\nredo log（重做日志）让 Innodb 有了崩溃恢复的能力，MySQL 实例挂了或宕机后重启时 Innodb 会使用 redo log 恢复数据，保证数据的完整和持久。\n后续的查询直接在查询缓存中查询，没命中再去硬盘加载，减少了 IO 开销。更新表时也是这样，发现缓存里存在要更新的数据，就直接在缓存里更新，然后会记录“哪个数据页做了什么修改”记录在 redo log 的缓存，接着刷盘到 redo log。\n理想状态是事务一提交就刷盘，实际上刷盘时机是根据策略来进行，有0，1，2三个策略。\n0：每次提交不刷。\n1（默认值）：每次提交都刷。\n2：每次事务提交都只把 redo log缓存写入 page cache（系统缓存）。\n另外Innodb存储引擎有一个后台线程，每隔一秒，就会把 redo log 缓存写到 page cache（系统缓存），然后刷盘。\n也就是说一个没提交的 redo log 记录可能也会被刷盘，因为在事务执行过程 redo log 记录是会写入 redo log 缓存，这些 redo log 会被后台线程刷盘，除了后台每秒一次刷盘还有一种情况会导致刷盘， 当redo log 缓存占用的空间即将达到 innodb_log_buffer_size 的一半时，后台线程会主动刷盘。 所以，为0时，MySQL 挂了或宕机了可能有一秒的数据丢失。\n为1时，redo log一定在硬盘里不会丢失，就算挂了，这部分日志也会丢失，但是事务并没提交，也不会损失。\n为2时，只要事务提交成功了，redo log缓存内容只写入page cache，如果是MySQL挂了不会丢失数据，宕机可能会有1秒数据丢失。\nbinlog用于复制，从库利用主库上的bin log进行传播，实现主从同步。\n事务提交的时候，一次性将事务中的 sql 语句（一个事物可能对应多个sql语句）按照一定的格式记录到 binlog 中。\nbinlog 与 redo log 很明显的差异就是 redo log 并不一定是在事务提交的时候刷新到磁盘，redo log 是在事务开始之后就开始逐步写入磁盘。\n事务提交后断电，redo log 恢复数据，提交前 redo log 恢复数据之后 undo log 回滚事务。\nbinlog\nMySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。\nbinlog 日志有三种格式，可以通过binlog_format参数指定。\n statement row mixed 指定 statement，记录的内容是SQL语句原文，比如执行一条 update T set update_time=now() where id=1\n同步数据时，会执行记录的 SQL 语句，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。  为了解决这种问题，我们需要指定为 row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据。\nrow格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。\nupdate_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（假设这张表只有 3 个字段）。\n这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。\n但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。\n所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。\nMySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。\nbinlog 写入机制：\nbinlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。\n因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。\n在写到内存是很快的，但再进一步刷盘持久化到磁盘也有对应的刷盘策略。\n0：表示每次提交事务都只write，由系统自行判断什么时候执行fsync。\n1：表示每次提交事务都会执行fsync，就如同 redo log 日志刷盘流程 一样。\nN：累积到了 N 个事务后才刷盘。\n两阶段提交\nredo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。保证主库数据。\nbinlog（归档日志）保证了MySQL集群架构的数据一致性。保证从库数据。\n二者都属于持久化的保证，但侧重点不同，只要有一个落盘不成功，就会导致主从数据不一致。\n在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n话说回来，假设执行过程中写完 redo log 日志后，binlog 日志写期间发生了异常，会出现什么情况呢？\n由于 binlog 没写完就异常，所以用 binlog 恢复数据时就会少了这次更新，而用 redo log恢复，则数据与用 binlog 恢复不一致。\n为了解决两份日志之间的逻辑一致问题，InnoDB 引擎使用两阶段提交方案。\n原理：将 redo log 的写入拆分为 prepare、commit 两个步骤。\n使用两阶段提交后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于prepare阶段，并且没有对应 binlog 日志，就会回滚该事务。\n但如果在 redo log “设置 commit 阶段”发生异常，是不会回滚事务的，因为虽然 redo log 是 prepare 阶段，但是能通过事务 id 找到对应的 binlog ，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n其它问题合集 数据库的读的延时问题 主库宕机后，数据可能丢失，从库只有一个 sql Thread，主库写压力大，复制很可能延时。\n如何解决？ 半同步复制解决数据丢失，并行复制解决从表复制延迟。\nExist和in的区别 exists是一个存在判断。\n如果后面的查询中有结果,则exists为真，否则为假，检测行的存在。\ndelete、drop、truncate 的区别 delete、truncate都只是删除表数据，而drop连表结构一块删除了，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。 delete是DML语句，可以回滚，但truncate、drop是DLL语句，不支持回滚。 执行速度：drop\u0026gt;truncate\u0026gt;delete\n视图 分为普通视图、物化视图。\n首先明白基本概念:\n 普通视图\n普通视图是不存储任何数据的，它只有定义，在查询中是转换为对应的定义SQL去查询。 物化视图\n物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，否则如果表很大的话，会在临时表空间内做大量的操作。\n物化视图也分为两种。  两种物化视图的区别 on demand 物化视图和 on commit 视图两者刷新方式不同，二者的区别在于刷新方法的不同。\nON DEMAND顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性；\n而 ON COMMIT 是说，一旦基表有了 COMMIT，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。\n为什么不推荐用外键？ 答：外键保障了数据质量，但是影响性能，每次 delete 或 update 都必须考虑外键约束，会导致开发痛苦，测试数据不方便。\n数据类型的优化？ 更小的通常更好：尽量使用不会超出范围的最小的占用空间的类型。\n简单就好：什么类型就用什么类型去存，如果是 ip 就调用方法转换成 int 类型去存。因为 int 比 字符串 节省很多空间。\n尽量避免使用 null：对于包含可为 null 列时很难优化。\n实际类型细则：\n整数类型：可以使用的几种整数类型：tiny int、small int、medium int、int、big int 分别是8、16、24、32、64 位存储位置。尽量使用满足需求的最小的数据类型。\n字符串类型：char、varchar、blob、text。（一个误区：文件大小和文件占用空间完全不同，因为 4kb 是一个读取数据的基本单元，那 4.01kb 的还是要占用两个 4kb 即两个基础单元（页）来存储，所以文件大小是 4.01kb， 占用空间是 8kb 。读一个数据会把该基础单元（页）里的数据都读进来这就是磁盘预读。）\nvarchar：使用最小符合需求的长度，varchar(n)，当 n\u0026lt;=255 时会用额外一个字节保存长度， n\u0026gt; 255 时会使用额外两个字节来保存长度， varchar(5) 和 varchar(255) 保存同样内容硬盘存储空间相同，但内存占用空间不同。varchar 在 MySQL 5.6 前变更长度从 255 变更到 255 以上会导致锁表。Char 最大长度 255 ，会删除末尾空格。\n时间戳类型：datetime 占 8 字节，与时区无关，数据库底层对时区对配置对其无效，不用要字符串类型来存，空间占用大。Timestamp 占 4 个字节，时间范围 1970-1-1 到 2038-1-19，精切到秒。Date类型占3个字节， 日期范围 1000-1-1 到 9999-12-31 。\n查询语句的执行顺序 from子句 \u0026ndash;\u0026gt; where子句 \u0026ndash;\u0026gt; group by子句 \u0026ndash;\u0026gt; 聚集函数\u0026ndash;\u0026gt; having子句 \u0026ndash;\u0026gt; select的字段 \u0026ndash;\u0026gt; Distinct（去重） \u0026ndash;\u0026gt; order by的字段 \u0026ndash;\u0026gt; limit\n表的关联项是从右到左解析，所以尽量把大的表项放在右边进行关联 group by（分组函数）不能直接在 where 子句中就是因为先执行 where 才执行分组 group by，where是无分组的过滤，having才是过滤分组。\nselect max (score) from zs_case\n该语句可以执行就是因为 select 在聚集函数后执行。\n查询如果分组 （group by） 了，那查询的字段只能和参与分组的字段相关，使用 having 可以对分完组后的数据继续过滤,但他必须和 group by 联合使用，而且 where 比 having 效率高。\n如果数据不分组，那整张表就默认为一组，分组函数自动忽略null，判断 null 用 isnull 而不是 = 。\n查询优化怎么做  减少请求的数据量：只返回有必要的列尽量避免 select * 、只返回有必要的行。 用 limit 限制、缓存重复查询的数据。 减少服务端扫描的行数：最有效就是避免回表（走两棵 b+ 树），而是尽量索引覆盖查询（走一棵 b+ 树）。 在表中建立索引，优先考虑 where、group by 使用到的字段。 where 子句模糊查询用在在字段后面，不要放在前面，否则会索引失效导致全表扫描。 尽量不要使用in 和 not in 和 or，会造成全表扫描。对于连续的数值，用 between 代替 in，对于子查询，用 exists 代替 in。union 代替 or，或者用 or 时两个字段都要是索引字段。 尽量不要在 where 子句中对字段进行表达式操作，会导致索引失效扫描整张表。 给字段添加默认值，不要对 null 进行判断，null 的判断会扫描整张表。  执行计划怎么看\n id：表项的查询顺序，注意是最大的先执行，也就是子查询先执行，查询的顺序如上。 table：查询涉及的表或衍生表。 select_type：  simple：不包含子查询或 union。 primary：包含子查询的 SQL 的最外层 select。 subquery：子查询中的第一个 select。 derived：派生/衍生表的 select, from 子句的子查询。 union：包含 union 的查询中的第二个或后面的 select 语句。 union result： union 的结果。   type：  ALL：全表扫描。 index：只扫描索引树，此时 select 的字段需要的字段不需要回表，则在 extra 会显示 using index。 range：索引范围扫描。 ref：非唯一性索引扫描，结果可能是多行，此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。 const、system：只有按照全部主键查询，执行计划type为const，也就是说此时查询出来的数据唯一，system就是其中特别的，表中只有一条数据，但在innodb中仍然显示为 const，而在 myisam 中显示 system。 eq_ref: 除了system和const类型之外,效率最高的连接类型；唯一索引扫描，对于每个索引键，表中只有一条记录与之对应；常用于主键或唯一索引扫描。   possible_keys：where子句包含的字段上若存在的索引，但该索引不一定被查询所使用。 key：MySQL查询实际使用到的索引。 key_len：表示索引占用的字节数。 ref：显示该表的索引字段关联了哪张表的哪个字段。 filtered：返回结果的行数占读取行数的百分比，值越大越好。 rows：根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。 extra：包含不适合在其他列中显示但十分重要的额外信息。常见的值如下  use filesort：MySQL会对数据使用非索引列进行排序，而不是按照索引顺序进行读取；若出现改值，应优化索引。 use temporary：使用临时表保存中间结果，比如，MySQL在对查询结果排序时使用临时表，常见于order by和group by；若出现改值，应优化索引。 use index：表示select操作使用了索引覆盖，避免回表访问数据行，效率不错。 use where：包含 where 子句。    排查MySQL问题的手段  show processlist命令查询当前所有连接信息。 Explain命令查询sql语句执行计划。 开启慢查询日志，查看慢查询的日志。  update语句执行流程  应用程序把 sql 发送到 server 端执行。 连接器：与客户端进行 TCP 三次握手建立连接；校验客户端的用户名和密码；读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限； 查询缓存：查询并清空查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 分析器 ：词法语法分析，提取表名查询条件。检查语法是否错误。 预处理器：检查表名字段名是否存在分析器 。 优化器 ：优化器根据自己的算法选择效率高的执行计划。 执行器 ：校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。 eg：更新会写日志文件。  ","permalink":"https://coderrenxy.github.io/posts/blog/%E6%88%91%E5%AF%B9mysql%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%E5%BF%B5%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...%E6%80%92%E8%82%9D16k%E5%AD%97-%E5%89%AF%E6%9C%AC/","summary":"​ 首先了解关于数据库一个误区，我们用的 MySQL、Oracle 都是 DBMS（数据库管理系统），用来操作数据的，而数据库是用来存数据的，而 sql 是","title":"我对MySQL的碎碎念念（持续更新...）怒肝12k字"},{"content":"首先二叉树的遍历分为，深度优先遍历（dfs）、广度优先遍历（bfs）。\n注意：但凡遍历都要注意根节点为 null；\n深度优先遍历又分为前中后序遍历，前面文章都讲过了，递归三个语句换个位置就解决了。\n注意：这里是深度优先遍历结果放在一个集合里 List 。广度优先遍历（层序遍历）才能分到不同的 List 中， {{1，3}，{4，1}}的形式。\n但凡是遍历，不论是深度（栈）、广度（队列），都是弹出一个再判断是否要塞（是否存在左右孩子）。\n深度优先的迭代做法后序遍历就是把前序的 left 、 right 压入顺序反转一下，再把得到的 List 反转一下，为什么？因为中前后（前序）、前后中（后序），后序逆转就是中后前，后前再逆转，就是中前后（前序）。关系明了吧！中序就不同，需要借助一个辅助的 cur 树节点，让其初始指向 root 根节点，利用 cur 和 stack 作为条件判空控制循环，然后 cur 不断变换位置。细节自己抠！前后序是 双if，中序 if\u0026hellip;else\u0026hellip;\n广度优先遍历（层序遍历）：\n递归（不推荐）方法利用 deep 控制深度。一个 if 判 root 空，一个 if（size \u0026lt; deep） 控制是否创建一个 List 存该深度的结点，resList.get(deep - 1).add(node.val); 最后两个递归完美收官。这里可以选择放入一个 List，也可以放入 List 中的 List，按需求来。\n迭代法（墙裂推荐！）：迭代法可以解决很多的遍历问题，而且很方便！主要就是利用队列，深度用循环来控制，条件为非空，那肯定是要不断有新的结点 offer 进来和 poll，这又要限制遍历一个深度再里面元素的次数了，这是又一个循环，这个循环不断进出，长度一直在变，所以要有个在内循环不变、外循环变化的 len 来控制内循环次数，每一次外循环都记录下该层深度的节点个数。\n根据遍历返回树后有感 到这里才发现。自己对遍历的认识是多么浅，别人写遍历的时候是根据遍历写代码，我是根据递归的代码来想遍历。这样也未尝是件坏事，至少把递归的前中后序遍历死死记住了.\n为什么前序求高度后序求深度?\n因为前序先走到叶子节点再 add，而后序是从头结点一路吃过去。add 我称为吃。\n其实理解递归/遍历 这样：\n前序：中左右：中是吃的操作，左右都是遍历，这样就能很好的理解遍历为何先进这个而不是那个。\nPS：堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树 。 持续更新中\u0026hellip;\u0026hellip; 如有错误，敬请斧正\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E7%BB%93/","summary":"首先二叉树的遍历分为，深度优先遍历（dfs）、广度优先遍历（bfs）。 注意：但凡遍历都要注意根节点为 null； 深度优先遍历又分为前中后序遍历","title":"二叉树遍历小结"},{"content":"正文\u0026hellip;. test\u0026hellip;..\n","permalink":"https://coderrenxy.github.io/posts/read/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E7%BB%93/","summary":"正文\u0026hellip;. test\u0026hellip;..","title":"以下暂为转载，作者《大白》"},{"content":" description：面试可能问到的异常相关八股文。\n （一）finally 块中的代码什么时候会执行？ 在 Java 语言的异常处理中，finally 块的作用就是为了保证无论出现什么情况，finally 块里的代码一定会被执行。\n由于程序执行 return 就意味着结束对当前函数的调用并跳出这个函数体，因此任何语句要执行都只能在 return 前执行（除非碰到 exit 函数），\t因此 finally 块里的代码也是在 return 之前执行的。\n此外，如果 try-finally 或者 catch-finally 中都有 return，那么 finally 块中\t的 return 将会覆盖别处的 return 语句，最终返回到调用者那里的是 finally 中 return 的值。\n（二）finally是不是一定会被执行到？ 不一定。\n下面列举两种执行不到的情况：\n 当程序进入 try 块之前就出现异常时，会直接结束，不会执行 finally 块中的代码； 当程序在 try 块中强制退出时也不会去执行 finally 块中的代码，比如在 try 块中执行 exit 方法。  （三）try-catch-finally中，如果catch中了return还会不会执行finally？ 会。\n程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally 块，最后再返回。\n因此，对基本数据类\t型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；而对引用类型是有影响的，返回的是在 finally 对 前面 return 语句返回对象的修改值。\n（四）try-catch-finally中哪个部分可以省略？ catch 和 finally可以省略其中一个，但必须保留其中一个。\ntry 只适合处理运行时异常，try+catch 适合处理运行时异常+普通异常。\n也就是说，如果你只用 try 去处理普通异常却不加以 catch 处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch 显示声明以便进一步处理。\n而运行时异常在编译时没有如此规定，所以 catch 可以省略，你加上 catch 编译器也觉得无可厚非。\n（五）Error和Exception的区别？ Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：\n Error 类： 一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防； Exception 类：分为运行时异常和受检查的异常。  （六）运行时异常与受检异常有何异同？  运行时异常：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。\n可以编译通过，但是一运行就停止了，程序不会自己处理； 受检查异常：要么用 try … catch… 捕获，要么用 throws 声明抛出，交给父类处理。  （七）throw和throws的区别?  throw：在方法体内部，表示抛出异常，由方法体内部的语句处理；throw 是具体向外抛出异常的动作，所以它抛出的是一\t个异常实例； throws：在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理；表示出现异常的可能性，并不一定\t会发生这种异常。  （八）常见的异常类有哪些  NullPointerException：当应用程序试图访问空对象时，则抛出该异常。 SQLException：提供关于数据库访问错误或其他错误信息的异常。 IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。 IOException：当发生某种 I/O 异常时，抛出此异常。此类是失败或中断的 I/O 操作生成的异常的通用类。 ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数  （九）主线程可以捕获到子线程的异常吗？ 线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部”。\n正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。\n如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 Thread 的静态方法\nThread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());\n 持续更新中\u0026hellip;\u0026hellip;.. 敬请期待\n ","permalink":"https://coderrenxy.github.io/posts/blog/%E5%BC%82%E5%B8%B8/","summary":"description：面试可能问到的异常相关八股文。 （一）finally 块中的代码什么时候会执行？ 在 Java 语言的异常处理中，finally 块的","title":"异常"},{"content":"JAVA补充面试题 五种IO模型与理解 IO最常接触的场景是读取文件和等待网络信息，一般而言，用户态是不能够直接操纵IO的，这就说明一定要向操作系统调用IO，主要分为两步：（1）操作系统的内核态会先等待数据准备好，（2）再从内核空间将数据拷贝到用户空间。\n同步阻塞IO \r\r以计算机网络编程为例，会调用read方法读取数据，而本质上是调用了内核的recvfrom方法。\n  此方法会被阻塞住，直到数据报准备好，也就是1阶段。\n  然后在数据报被从内核复制到用户空间这一过程中，该线程会再次阻塞，直到复制完成，这一过程对应上图的序号2的过程；\n  无论数据有没有被准备好，此IO过程都会被阻塞，数据准备好时只会阻塞2阶段，数据为准备好会阻塞1，2两个阶段。\n同步非阻塞IO \r\r这个过程分为了两种情况：\n  数据未准备好时，会一直调用recvfrom函数，如果数据没准备好会返回EWOULDBLOCK错误。即不会将用户进程（线程）至于阻塞状态。\n  数据准备好后，此时recvfrom系统调用，用户进程（线程）还是会阻塞，直到内核中的数据报已经拷贝到了用户空间，此时用户进程（线程）才会被唤醒来处理接收的数据报。\n  但是，进程（线程）不断轮训，因此这是非常耗费CPU的。\nIO多路复用模型 阻塞和非阻塞模型的缺点是一个线程只能监控一个IO(也可以称为文件描述符fd)。如果系统并发度很高，线程就会大量创建，并不断轮训。系统资源会被大量浪费。\n\r\rIO多路复用的思想是用一个线程监听多个文件描述符。当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。\n\r\rIO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。\n\r\r信号驱动IO IO多路复用解决了一个线程监控多个fd的问题。但是还有一个大问题，等待数据准备中一直要轮询，这不是很傻逼吗？于是就有了信号驱动IO，当数据准备好后通知线程，而不需要轮询。\n\r\r首先需要在线程和fd之间建立一个SIGIO信号联系，这是通过sigaction建立的，当内核数据准备好后通过SIGIO通知线程。线程再调用recvfrom从内核拷贝数据到用户空间。\n\r\r信号驱动IO模型在等待数据报期间是不会阻塞的，即用户进程（线程）发送一个sigaction系统调用后，此时立刻返回，并不会阻塞，然后用户进程（线程）继续执行；当数据报准备好时，此时内核就为该进程（线程）产生一个SIGIO信号，此时该进程（线程）就发生一次recvfrom系统调用将数据报从内核复制到用户空间，注意，这个阶段是阻塞的。\n异步IO模型 \r\r异步IO最大的优点是在准备数据和拷贝数据两个过程都不会被阻塞。\n 用户进程发生系统调用时，会立刻返回，不被阻塞。执行其他任务。 当内核把数据拷贝完毕后，通知线程数据已经准备好，这个过程也不会阻塞。  异步IO模型跟信号驱动IO模型的区别在于当内核准备好数据报后，对于信号驱动IO模型，此时内核会通知用户进程说数据报准备好啦，你需要发起系统调用来将数据报从内核拷贝到用户空间，此过程是同步阻塞的；而对于异步IO模型，当数据报准备好时，内核不会再通知用户进程，而是自己默默将数据报从内核拷贝到用户空间后然后再通知用户进程说，数据已经拷贝到用户空间啦，你直接进行业务逻辑处理就行。\nJava中的IO模型，BIO,NIO,AIO BIO(Blocking I/O)同步阻塞IO 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量.\nNIO(Non-blocking/New I/O)多路复用IO Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\nAIO(Asynchronous I/O)异步IO AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n","permalink":"https://coderrenxy.github.io/posts/blog/io/","summary":"JAVA补充面试题 五种IO模型与理解 IO最常接触的场景是读取文件和等待网络信息，一般而言，用户态是不能够直接操纵IO的，这就说明一定要向操作","title":""},{"content":"思特奇 一面 1.自我介绍 和 项目介绍 \u0026hellip;\n2.Java有多少种数据类型 各占多少个字节 6数字，1字符，1布尔 int4，short2，byte1，long8，float4，double8，char2，boolean未说明，但按理说应该是1\n3.list 容器 ArrayList和LinkedList的区别 底层实现 ArrayList：数组 LinkedList：链表 插入删除，随机查找的区别\n4.ArrayList和LinkedList的应用场景 详细说说 排序插入删除，查找\u0026hellip;\n补充：（ 1.集合有几种类型，都有什么特点？ 4种，list，set，queue，map\n2.int和Integer有什么区别？ 略\u0026hellip; ）\n5.JVM了解吗 说说JVM的结构 类加载器 运行时区域 GC 编译器 JIT\n6.运行时数据区详细说说\n公有\u0026hellip; 私有\u0026hellip;.\n7.堆和栈有什么区别 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存 栈：每次方法调用的数据都是通过栈传递的\n8.GC 一般发生在哪个地方 GC发生在堆(heap)中\n9.多线程有了解过吗 了解过\u0026hellip;巴拉巴拉\n10.平时有用到吗？ 无\n11.那你说说框架里面哪些用到了？ 不知道\n12.设计模式有了解过吗 有，不过不多，只有单例模式和工厂模式\n13.说说单例模式和工厂模式 单例模式：巴拉巴拉 工厂模式：巴拉巴拉\n14.说说你的项目，都用到了什么 框架、数据库、Redis\u0026hellip;.\n15.说说你用到的框架 我着重说了SpringBoot AOP、IOC、为什么比Spring好、生态丰富\u0026hellip;.（一时紧张吧MVC忘记了）\n16.还有什么想问的？ 我还要再学点（补充点）什么？\n二面  为什么做这个项目(校园门户网站) 我看你们学校已经有了类似的没为什么还做呢? 你是组长的话都干了些什么 你说主要的数据库表是你来设计的,你那说说怎么设计 说说项目的每个模块 你的数据库表设计原则是什么 有什么校园经历,说说? 职业规划? 长远打算? 你还有什么要问的  ","permalink":"https://coderrenxy.github.io/posts/read/01%E6%80%9D%E7%89%B9%E5%A5%87/","summary":"思特奇 一面 1.自我介绍 和 项目介绍 \u0026hellip; 2.Java有多少种数据类型 各占多少个字节 6数字，1字符，1布尔 int4，short2，byte1，lon","title":""},{"content":"哈罗 开始\n1.自我介绍\u0026amp;项目介绍\n我的是新闻门户网站,介绍了一下都用到了什么技术,几个人开发,怎么协作\n2.先聊聊java基础,说说java面向对象的三大特征\n(ps:如果碰到了这个问题,能说多少说多少,拖时间,面试官一般不会轻易打断的) 封装继承多态,在延伸一些C++中的一些对比什么的\n3.接口和抽象类的区别?\n4.接口和抽象类的java版本不同,有了哪些变化?\n5.说说集合的种类\n6.HashMap底层实现 (ps:这里能扯得也很多,多说说别的来做对比,比如HashTable怎么怎么,比如扩容机制怎么怎么,能延伸多少是多少)\n7.解决哈希冲突的几种办法是什么?\n8.ConcurrentHashMap 和 Hashtable 的区别\n9.多线程知道吗,大概说说\n10.多线程的线程池讲一下,好处是什么?\n11.多线程的实现方式\n12.多线程线程池的参数都有什么,有哪些作用?\n13.多线程的拒绝策略有哪些?详细说说\n14.多线程的应用场景,详细说说 (ps:这里一般我们的项目接触不到,一定要去看看相关的案例什么的)\n15.ThreadLocal 原理和内存泄漏问题说说\n16.行,那来聊聊框架,说说spring和springboot的特点\n17.Spring/Spring Boot 常用注解\n18.单例 bean 的线程安全问题了解吗？\n19.数据库的事务都有哪些,用什么来保证这些特征\n20.一条sql怎么优化的呢?\n21.知道什么是覆盖索引和回表吗？\n22.什么是MVCC？\n23.直到redis嘛,Redis Stream消费者崩溃带来的会不会消息丢失问题\n24.Redis Steam 坏消息问题，死信问题\n25.说说Redis哈希槽的概念？\n26.Redis文件事件的模型,详细说说\n27.算法题:类似leetcode269 火星词典 (因为见过,这个题的思路很清晰,很快就写完了,面试官觉得不过瘾又来了一道)\n28.算法题:一道动态规划,没找到合适的类似题目\n你还有什么想问的吗?\n评价一下我的表现\n面试官:很不错,等消息吧\n","permalink":"https://coderrenxy.github.io/posts/read/02%E5%93%88%E7%BD%97/","summary":"哈罗 开始 1.自我介绍\u0026amp;项目介绍 我的是新闻门户网站,介绍了一下都用到了什么技术,几个人开发,怎么协作 2.先聊聊java基础,说说jav","title":""},{"content":"金蝶 一面  自我介绍 项目的架构图画一下 项目是怎么部署到服务器的 为什么要用 Docker 做项目的过程中遇到了什么问题没有，如何解决的，学到了什么。 项目数据库表怎么设计的 项目的日志怎么做的 项目有没有做权限管理，怎么做的 说一下自己对 IoC、AOP 的理解 网络协议说一下 数据库优化 有没有用过针对多表查询如何优化  HR面  自我介绍 学校的成绩，有没有获得过什么奖项 介绍一下项目，业务情况，当时是怎么做这个项目的 项目中充当的角色，负责做什么 项目带给你最大的收获是什么 说一件你在校园中做过对自己来说最有价值的事情 你觉得一个好的开发工程师应该具备怎样的素质 平时有健身运动的习惯么，频率怎么样 讲讲你的个人优势 手里的 offer 情况 反问  二面  Spring,Spring MVC,Spring Boot 之间什么关系? @Autowired 和 @Resource 的区别是什么？ 静态代理和动态代理的区别 除了 JDK 提供的动态代理实现还有其他实现方式么(CGLIB ) 谈谈对 MySQL 索引的了解，哪些字段应该考虑创建索引，哪些字段尽量不要创建索引 为什么 InnoDB 引擎要选择 B+Tree 作为索引数据结构？ MySQL 中 一条 SQL 语句的执行流程 从执行流程的层面说说如何优化一条 SQL 语句的查询速度，发生在哪个部分 多表联合查询的时候，SQL语句的执行流程 目前正在学习什么知识 反问：新人培训体系是怎么样的  三面  自我介绍 简单介绍一下自己的项目 项目中用了哪些设计模式 单例模式有什么好处 项目中用了线程池干什么 为什么实际生产建议使用 ThreadPoolExecutor 构造函数来创建线程池 如何理解线程安全和不安全 平时怎么学习的 反问：公司目前的技术栈，是否有 CodeReview  三面这个面试官基本没怎么问题技术，后面找我唠嗑半天就闲聊一些大学生活啥的。\n","permalink":"https://coderrenxy.github.io/posts/read/03%E9%87%91%E8%9D%B6/","summary":"金蝶 一面 自我介绍 项目的架构图画一下 项目是怎么部署到服务器的 为什么要用 Docker 做项目的过程中遇到了什么问题没有，如何解决的，学到了什么。 项目数据库表","title":""},{"content":"步步高 一面（50分钟）  介绍一下项目 项目是视频还是通过什么途径学习的？ 你认为项目中复杂的点是什么？ Redis的使用场景？ Redis的高并发是依靠什么去保证的？ ThreadLocal 用在哪，为什么选择 ThreadLocal呢？ 项目上线了嘛？部署在哪里？怎么部署的？ 注解实现缓存和日志统一处理是怎么做的？ SpringBoot分哪些模块？ 项目中的分页是怎么实现的？ 项目中都有哪些sql表说一下吧？ 消息队列MQ用过吗？说一下？- 分布式锁这块有用到吗？- 说一下常用的一些集合？ 说一下 HashSet的原理？ 说一下 HashSet 与 HashMap的区别？ 线程安全的集合类有哪些？ 锁重入了解过嘛？那些锁支持锁重入？ 说一下锁升级的过程？ 数据库中的锁有哪些？ Java8 的新特性 Stream 流、Lambda 表达式说一下？ TCP和HTTP 协议之间的关系，有什么区别？ TCP/IP 参考模型，每层都是封装的什么？ TCP是可靠的嘛？那么UDP呢？ TCP如何保证我们的可靠传输的？ 说一下TCP中拥塞控制的一个过程？ Linux查看ip地址的命令？ 说一下聚簇索引和非聚簇的区别？ 事务的隔离级别和每个级别所产生的问题? 实际开发中最常使用的隔离界别 创建线程的方式?说一下？ 讲一下同步和异步的区别？ 说一下项目中Nginx的作用？ 说一下JMM吧 说一下常见的垃圾回收算法吧？ JMM的三个特性是哪三个？ 如何保证原子性，volatile的作用呢？ ThreadLocal和synchronized的区别 Redis的rdb和aof说一下吧，区别呢？ 为什么fork一个子进程呢？ Redis有持久化为什么还要用MySQL呢？ MySQL数据也会有丢失的情况呀？是如何保证的呢？ 单节点和集群的区别，集群解决了什么问题？ 主从复制解决了什么问题？ Redis集群的原理 MySQL为什么要采用读写分离呢？ 除了MySQL、Redis外还了解过其他数据库嘛？ 用过Docker嘛？ 使用Docker部署的好处是什么？相比原始部署？ 最近看了哪些书呢？ 反问  二面(25分钟)  Redis为什么快？ 线程的创建方式？ 怎么在Linux服务器上部署项目？ 使用过Docker嘛？ Docker与Linux相比为什么性能更好？ 如何进行sql优化？你自己实践哪些手段？ 我们MySQL读写压力很大，怎么解决？ 说一下TCP三次握手、四次挥手？ MQ是什么？ 项目是怎么做的？实习项目还是自己做的？ 如何设计秒杀系统 实际开发中如何解决高并发的问题？你知道哪些手段？实践过哪些手段？ 校园的实践经历 为什么来参加春招，是没offer吗？ 手里有几个offer ？ 以后的发展方向是走技术管理，还是架构方向？ 说一下在你眼里技术管理和技术架构的区别？ 如果领导让你3天完成一个任务，但是你4天才能完成 谈一下你对加班的看法？ 你将来计划打算学到什么，提升Java哪方面技能？ 反问  三面（HR面，20分钟）  为什么会有写博客的习惯呢，出发点是什么？ 这个博客是有粉丝的吗？你有多少粉丝呢? 大学校园经历中有意义的一些事情？ 大学当中跟室友的关系怎么样？ 为什么没有参加秋招呢？ 找工作跟考研之间是怎么权衡的呢？ 讲一下在自己的个人项目中学到了什么呢？ 大学期间有没有低谷期间 手里有其他的公司的offer吗？ offer是哪家公司的？ 期望薪资是多少，年薪呢？ 反问  四面（终面，7分钟） 一个非常让人讨厌的领导，说话阴阳怪气的，开头第一句话就是你的成绩不咋地啊（无挂科平均成绩在80+）。\n 有没有实习的经验 ？ 为什么秋招没有找到工作？ 你是怎么学习一个技术的？说一个擅长的  ","permalink":"https://coderrenxy.github.io/posts/read/04%E6%AD%A5%E6%AD%A5%E9%AB%98/","summary":"步步高 一面（50分钟） 介绍一下项目 项目是视频还是通过什么途径学习的？ 你认为项目中复杂的点是什么？ Redis的使用场景？ Redis的高并发是依","title":""},{"content":"行云集团 自我介绍\n实习用到的技术栈和编程语言是什么？\n(实习是学校很水的5G通信实习，压根不沾边，随便就过了)\nJava是什么时候开始接触和学习的？\n学习数据结构的时候，对于Map这种数据结构，它的底层是怎么实现的或者有什么特征？\n(因为扯了大学学过数据结构就问了这个，但是Map没怎么接触，就扯了HashMap用了链表+红黑树，冲突少用链表，冲突多用红黑树，又扯了红黑树的基本原则和为了解决二叉查找树的平衡问题和JavaGuide里的B树B+树介绍，属于是乱答)\n做这个Map的时候，你自己用过什么类型的Map？不管是C++还是Java\n（还没用到过，就扯了用的比较多的是小项目里的链表啥的，顺便讲了下自己使用链表和做项目的思路）\n算法这块的话，排序算法接触过哪些算法？\n（讲了冒泡和快速，但是表示自己对快速的原理记得不是很清楚，含糊地说也不知道说了什么\u0026hellip;.） 他们的时间复杂度分别是多少？（冒泡n²，快速nlogn，也说了Java的一些类提供的方法应该用的比较多是快速排序）\n快速排序它的消耗稳定吗？\n（脑抽答了稳定，把平均和最差时间复杂度nlogn和稳定性混为一谈了，估计要g了）\n有学习过网络通讯吗？\n（表示还没开始学，但是了解过一点，比较含糊地讲了TCP三次握手四次挥手的基本过程原理，也是JavaGuide里的）\n有接触过并发编程吗？\n（表示有学过多线程的一些基本运用）\n还记得吗，比如怎么创建，开始一个线程之类的？\n（讲了创建线程的4种方式）\n你能举例一下什么时候会出现并发的场景吗？\n（不是很理解问题，乱答了一些比如要共同操作共享数据啥的，举了很低级的例子比如多个人向同一账户存款啥的可能会出现线程安全问题，感觉有点跑题了）\n可能是跑题了，接着面试官问 能举一个Java编程上的例子吗？比如什么样的代码可能会出现并发的风险？\n（多线程没怎么深入学，也可能是对问题有点懵，就表示现在还没有很深入的去学，又扯回刚刚的例子和线程安全问题，还扯了多线程的好处，太菜了）\n数据库这块主要接触的是哪个数据库？\n（还没学到，但是有过一些入门了解，说了前面的B+树是MySQL的索引数据结构）\nSQL最近有写过吗？\n（还没写，但是有了解过事务，讲了要么都执行要么都不执行，举了转账的例子，属于是乱答了。表示后面会深入去学）\n","permalink":"https://coderrenxy.github.io/posts/read/05%E8%A1%8C%E4%BA%91%E9%9B%86%E5%9B%A2/","summary":"行云集团 自我介绍 实习用到的技术栈和编程语言是什么？ (实习是学校很水的5G通信实习，压根不沾边，随便就过了) Java是什么时候开始接触和学习的","title":""},{"content":"中税汇金 1.你的redis怎么和mysql同步数据的？（我已经忘了我当时做的那个收藏功能同步没有同步，问下xdm这样的收藏功能一般是怎么做的）\n2.你的项目中有MinIO，是什么？\n3.左关联右关联内关联有什么区别？\n4.讲讲springAOP\n5.设计模式你也会？我看你写的有策略模式，讲一讲（感觉被质疑了）\n6.那你对sql优化这块有了解吗，做过什么优化吗\n7.你对集合熟悉吗，说一下ArrayList和HashMap的区别\n8.ACID你是真的会用还是只是看了一些资料（感觉又被质疑了，我就解释了一下4个特性），面试官：就相当于你是了解过4个特性，没有配置过每个特性对应的实际参数。\n9.我看你会查sql执行流程，那你知道怎么给他优化吗？\n10.建索引的原则，哪些字段可以建索引？\n11分库分表你用过吗\n","permalink":"https://coderrenxy.github.io/posts/read/06%E4%B8%AD%E7%A8%8E%E6%B1%87%E9%87%91/","summary":"中税汇金 1.你的redis怎么和mysql同步数据的？（我已经忘了我当时做的那个收藏功能同步没有同步，问下xdm这样的收藏功能一般是怎么做的","title":""},{"content":"字节大数据基础架构部门 字节面经 一面 2.17\n 自我介绍 接口和抽象类的区别 了解过啥设计模式 单例模式是啥 工厂模式的作用，为什么要用工厂模式？ 解耦, 把对象的创建和使用的过程分开(就是Class A 想调用Class B,那么只是调用B的方法，而至于B的实例化，就交给工厂类) 建造者模式的实现方式 在设计模式中你使用抽象类还是接口比较多 了解哪些Java锁 死锁的必要条件 Mysql索引了解吗(那时候不会就直接说不会了) MySql事务隔离级别 说一下你用过的Java框架 (说了Spring 的 ioc/aop 还没说aop就下一问了) 项目中如何使用git和maven的 代码题:  写一个快排 1. 快排是否稳定 2. 什么情况下会退化 3. 如何优化 4. 时间复杂度 写一个二分查找 1. 复杂度 代码题写的太快了, 然后他说时间还没到在问几个问题   了解分布式吗(NO) 说一下Java基础类型 为什么int是2的31次方 了解Docker吗(NO) 什么是Java同步和异步  反问: 1. 部门的业务 2. 对我的评价\n字节跳动二面 2.18\n 进程之间的通信 管道通信 命名管道通信 消息队列 共享内存 信号量 套接字 信号 说一下你了解的锁 说一下synchronized 和 reentranlock 介绍一下Reentrantlock 单例模式中变量前加的关键字(volatile) 单例模式并发下实现方式 双重检查锁(DCL) 内部类 枚举类 volatile的作用是什么 防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性 会主动刷新存储 聚集索引和非聚集索引的区别 1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。** 2.非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引** mysql三大范式说一个你了解的 mysql的ACID是什么 Maven包冲突怎么解决 介绍一下HashMap HashMap扩容了解吗?说一下扩容因子(loadFactor) 红黑树的特点, 为啥红黑树比较二叉树快   每条路上黑节点的数量是固定的, 高度限制搜索快 红黑树特点 :   每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 Redis为什么快? 直接操作内存 单线程没有多线程创建销毁的开销 IO多路复用 Redis缓存机制(我觉得应该是处理流程) 算法题: LeetCode 25 困难 K个一组反转链表改版(最后n个不足也反转)  字节面经 三面Leader面 - 2.21(挂)\n Object类里有什么方法 有用过Object类中相关锁的方法吗 wait notify notifyAll Java垃圾回收的方法新生代和老年代的不同的算法 设计模式中有用到锁的模式 如果没有使用两个锁单例会有什么问题 MySQL使用还是对他的原理有什么了解 使用JavaEE开发过一些项目吗 在开发项目中有什么问题吗, 然后最后解决了的 算法题: LeetCode 101简单  对称二叉树 还是题刷的不够多,没写到这题也没多写二叉树,我居然用BFS写的    ","permalink":"https://coderrenxy.github.io/posts/read/07%E5%AD%97%E8%8A%82%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E9%97%A8/","summary":"字节大数据基础架构部门 字节面经 一面 2.17 自我介绍 接口和抽象类的区别 了解过啥设计模式 单例模式是啥 工厂模式的作用，为什么要用工厂模式？ 解耦, 把对象的","title":""},{"content":"美团 一面  挖项目，问的太多了，这里就不一一列举了，大部分是某个功能是怎么实现的或者如果要加某个功能应该怎么实现。 进程线程区别。 死锁，死锁条件。 知不知道中断和轮询的区别。 数据库索引，讨论了一下B+树能存多少数据。 数据库存储引擎知道哪些，有什么区别。 数据库锁。 算法题：起始点到终点最短路径。  二面  问项目。 什么是序列化反序列化。 负载均衡，知道哪些负载均衡 。 什么时候会OOM，服务OOM怎么办，如何排查。 Spring 启动流程。 Spring 设计模式。 对于模版模式的理解，应用场景，你在项目中是怎么使用的。 HTTP 请求过程 。 TCP 和 UDP 区别。 Linux知道哪些命令。 设置索引有什么注意的地方。 最近看了哪些书，有什么收获。 算法题：合并有序数组 O(N)时间 O(1)空间。 数据库设计：只能以半小时为单位订会议室。  华为 一面  项目、论文。 String 能否被继承。 Java 内存泄露和排查。 Hash 方式和 Hash 冲突解决。 静态代理和动态代理。 线程通信方式。 Volitate关键字。 Java 高效拷贝数组。 算法题 跳跃游戏 leetcode 55。  二面  简单说说项目、论文。 项目是自己学习的还是落地项目。 本科保研绩点高，为啥研究生期间没有刷绩点。 对华为的了解，这个聊了比较久 因为我本身就是华为用户，比较了解，主管也给我介绍和补充。 实习时间。 反问部门、技术栈，是否可以自己选项目。  字节 一面  问项目，聊怎么实现，从项目里学到什么。 手写单例模式，和 Spring 的单例有什么区别。 算法题：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 SQL 题：根据题目要求写出对应的 SQL，由于太久没写，不会做。 智力题 1-N批次其中有一批次重量不合格 用最少称重次数找到  1） 刚开始说二分 面试官说不是最优\n2） 提示可以从每批次拿不同数量：第N批拿N个 算重量差值就可以确定\n二面  问项目。 volitate 关键字。 JVM新生代怎么划分，大对象怎么分配。 新生代有哪些垃圾回收器。 ParNew 原理。 Innodb 默认隔离级别，RR能防止幻读吗，RR默认使用间隙锁吗。 怎么理解最终一致性，有哪些实现方案。 分布式事务。 算法题：数组里每个数右边第一个比他大的数。  三面  问项目。 RAFT 脑裂、一致性。 负载均衡。 各种排序算法，分析复杂度和稳定性。 其他想不起来了，八股很少，一直问项目。 算法题：旋转图像(90度旋转矩阵)。  ","permalink":"https://coderrenxy.github.io/posts/read/08%E7%BE%8E%E5%9B%A2%E5%8D%8E%E4%B8%BA%E5%AD%97%E8%8A%82/","summary":"美团 一面 挖项目，问的太多了，这里就不一一列举了，大部分是某个功能是怎么实现的或者如果要加某个功能应该怎么实现。 进程线程区别。 死锁，死锁条件。","title":""},{"content":"念神面经篇 Java基础篇  JDK \u0026amp; JVM \u0026amp; JRE的区别 包装类型的常量池技术 接口和抽象类的区别 String、StringBuffer、StringBuilder的区别 泛型擦除的原理 反射的应用场景 异常的类型，具体的例子有哪些 说说常用的容器和各自的特点 ArrayList的扩容机制 HashMap源码实现 ConcurrentHashMap的底层实现 Lambda表达式有什么好处，什么坏处，应用场景有哪些  Java并发篇  为什么要使用多线程，有什么好处，举例具体场景 线程的生命周期以及每个周期进入和结束的标志 避免死锁的三个必要条件 简述哲学家进餐问题和银行家算法 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ 场景题：如何实现一个实时排序的游戏战力榜单 场景题：如何实现一个竞技场挑战功能，考虑高并发 volatile的用法 synchronized和ReentrantLock的区别 乐观锁和悲观锁的底层实现 不加锁如何保证线程安全 synchronized是可重入锁么 使用了vector就一定能保证线程安全吗 多线程的实现方式 场景题：高并发的情况下保证数据的一致性怎么做到 场景题：有10个线程分别对 i = 0 做10次自增操作，最后 i 的值会是多少，为什么 ThreadLocal的原理 场景题：在生产者消费者问题中怎么保证当消费者用完产品后生产者会马上得知，不能使用while循环去解决 Java的线程池类型有哪些 Java线程池的参数以及其具体意义 线程池的拒绝策略  JVM篇  JVM的基本结构 双亲委派模型的好处 运行时数据区的基本结构，各种结构都有什么用途 垃圾回收策略 垃圾回收器都有哪些 如何判断一个类是无用的类 查看运行内存，JVM状态有什么方法 G1回收器与之前的回收器相比最大的不同是什么 类加载的过程是什么，每个过程具体做到了什么事 JVM的常用参数有哪些 JVM调优常用的手段是什么  Spring篇  Spring的特性和优势是什么 Spring有哪些组件 场景题：如果实现一个你自己的Spring框架需要考虑那些方面，简单聊聊 Spring MVC底层实现原理 IOC 和 AOP 具体介绍一下 Spring Bean是什么 IOC 和 DI 是什么关系 IOC 配置的三种方式 依赖注入的三种方式 为什么推荐构造器注入方式？ 场景题：在使用构造器注入方式时注入了太多的类导致Bad Smell怎么办 AspectJ注解方式接触过吗，具体说说有什么特点和不足 Spring为何不能解决非单例属性之外的循环依赖？ Spring中Bean的生命周期介绍一下 场景题：自定义一个你自己的starter怎么实现（开共享屏幕实现）  MyBatis篇  接口层和数据库交互的方式有哪些 简述MyBatis的层次结构 sqlSessionFactory 与 SqlSession介绍一下 Excutor的概念 动态SQL有哪些，都有什么用途 为什么要使用连接池 $ 和 # 的区别  计算机网络篇  OSI和TCP/IP介绍一下 HTTP和HTTPS的区别 HTTPS的加密手段是什么 三次握手的过程以及每一次起到了什么作用 四次挥手的过程以及每一次起到了什么作用 TCP协议中的流量控制起到什么作用 介绍一下ARQ协议 从输入URL到页面加载发生了什么 HTTP 如何保存用户状态 Cookie 的作用是什么 Cookie 和 Session 有什么区别 HTTP状态码有哪些  数据库篇  数据库设计通常分为哪几步 MySQL的分页怎么做的 MyISAM和InnoDB的区别 MySQL日志都有什么，分别有什么作用 读锁和写锁实现的底层原理 表级锁和行级锁的实现原理 事务的特性 并发事务带来的问题有哪些 事务隔离级别有哪些 场景题：MySQL对于千万级的数据库或者大表怎么处理 MVCC解决什么问题 索引有什么作用 索引的底层数据结构 为什么InnoDB使用B+树作为索引的数据结构 索引有哪些种类 为什么会出现回表查询，怎么避免 解释一下最左前缀法则 覆盖索引是什么意思 MySQL读写分离方案 MySQL主从复制是什么意思 MySQL主从的延迟怎么解决  Redis篇  为什么Redis 是单线程的 Redis 一般有哪些使用场景 Redis 有哪些数据类型，每一种都有什么实际应用 sds存在的意义 为什么会设计Redis Stream Redis Stream消费者崩溃带来的会不会消息丢失问题 Redis Steam 坏消息问题，死信问题 Redis 的持久化机制是什么 AOF是写前日志还是写后日志 Redis 过期键的删除策略有哪些 Redis 内存淘汰算法有哪些 Redis如何做内存优化 Redis事务相关命令 Redis事务中出现错误的处理 为什么 Redis 不支持回滚 Redis缓存有哪些问题，如何解决 Redis6.0之前为什么一致不用多线程  ","permalink":"https://coderrenxy.github.io/posts/read/09%E5%BF%B5%E7%A5%9E%E9%9D%A2%E7%BB%8F/","summary":"念神面经篇 Java基础篇 JDK \u0026amp; JVM \u0026amp; JRE的区别 包装类型的常量池技术 接口和抽象类的区别 String、StringBuffer、StringBui","title":""},{"content":"百度Java中级面试 Spring BeanFactory 和 ApplicationContext 有什么区别 1、BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义， 以便在接收到客户端请求时将对应的 bean 实例化。\n2、BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始 化方法（initialization methods）和销毁方法（destruction methods）。\n3、从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。\n 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件  Spring Bean 的生命周期 1、Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。\n2、Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n 初始化之后调用的回调方法。 销毁之前调用的回调方法。  Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：\n  InitializingBean 和 DisposableBean 回调接口\n  针对特殊行为的其他 Aware 接口\n  Bean 配置文件中的 Custom init()方法和 destroy()方法\n  @PostConstruct 和@PreDestroy 注解方式\n  Spring IOC 如何实现 1、Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IoC 容器的基础。\n2、BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。\nApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的 WebApplicationContext。\n3、org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。\n说说 Spring AOP 1、面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有 update 方法的执行时间时间，操作人等等信息，记录到日志， 通过 spring 的 AOP 技术，就可以在不修改 update的代码的情况下完成该需求。\nSpring AOP 实现原理 1、Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类。\n2、如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB （Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final， 那么它是无法使用 CGLIB 做动态代理的。\n动态代理（cglib 与 JDK） 1、JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用 Java 动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而 CGLIB 则可以实现对类的动态代理。\nSpring 事务实现方式 1、编码方式\n 所谓编程式事务指的是通过编码方式实现事务，即类似于 JDBC 编程实现事务管理。  2、声明式事务管理方式\n 声明式事务管理又有两种实现方式：基于 xml 配置文件的方式；另一个实在业务方法上进行@Transaction 注解，将事务规则应用到业务逻辑中  Spring 事务底层原理 a、划分处理单元——IOC\n由于 spring 解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用 spring中的 IOC 划分了事务处理单元。并且将对事务的各种配置放到了 ioc 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。\nb、AOP 拦截需要进行事务处理的类\nSpring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用 TransactionProxyFactoryBean 接口来使用 AOP功能，生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取 ioc 容器事务配置属性，转化为 spring 事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为 TransactionAttribute 表示的数据对象。\nc、对事物处理实现（事务的生成、提交、回滚、挂起）\nspring 委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource 数据源支持、hibernate 数据源事务处理支持、JDO 数据源事务处理支持，JPA、JTA 数据源事务处理支持。这些支持都是通过设计PlatformTransactionManager、AbstractPlatforTransaction 一系列事务处理的支持。 为常用数据源支持提供了一系列的 TransactionManager。\nd、结合\nPlatformTransactionManager 实现了 TransactionInterception 接口，让其与TransactionProxyFactoryBean 结合起来，形成一个 Spring 声明式事务处理的设计体系。\n如何自定义注解实现功能 1、创建自定义注解和创建一个接口相似，但是注解的 interface 关键字需要以@符号开头。\n2、注解方法不能带有参数；\n3、注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的\n数组；\n1、注解方法可以有默认值；\n2、注解本身能够包含元注解，元注解被用来注解其它注解。\nSpring MVC 运行流程 1.spring mvc 将所有的请求都提交给 DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。\n2.DispatcherServlet 查询一个或多个 HandlerMapping,找到处理请求的 Controller.\n3.DispatcherServlet 请请求提交到目标 Controller\n4.Controller 进行业务逻辑处理后，会返回一个 ModelAndView\n5.Dispathcher 查询一个或多个 ViewResolver 视图解析器,找到 ModelAndView 对象指定的视图对象\n6.视图对象负责渲染返回给客户端。\nSpring MVC 启动流程 在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext, DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化了\nSpring MVC 总的组件。\nSpring 的单例实现原理 Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是\nConcurrentHashMap 对象。\nSpring 框架中用到了哪些设计模式 代理模式—在 AOP 和 remoting 中被用的比较多。\n单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。\n模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。\n前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。\n视图帮助(View Helper )—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。\n依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。\n工厂模式—BeanFactory 用来创建对象的实例。\nNetty 为什么选择 Netty   API 使用简单，开发门槛低；\n  功能强大，预置了多种编解码功能，支持多种主流协议；\n  定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；\n  性能高，通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优；\n  成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为NIO 的 BUG 而烦恼；\n  社区活跃，版本迭代周期短，发现的 BUG 可以被及时修复，同时，更多的新功能会被加入；\n  经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。\n  正是因为这些优点，Netty 逐渐成为 Java NIO 编程的首选框架。\n说说业务中，Netty 的使用场景 1、构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等， Netty 主要作为基础通信框架提供高性能、低时延的通信服务；\n2、公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的WebSocket 协议栈；\n3、各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。\n4、原生的 NIO 在 JDK 1.7 版本存在 epoll bug ，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些 而已，它并没有得到根本性解决。\n什么是 TCP 粘包/拆包 1、要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。\n2、待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。\n3、要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。\n\u0026gt; 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\nTCP 粘包/拆包的解决办法 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。\n2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将 不同的数据包拆分开。\nNetty 线程模型 首先，Netty 使用 EventLoop 来处理连接上的读写事件，而一个连接上的所有请求都保证在一个 EventLoop 中被处理，一个 EventLoop 中只有一个 Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个 EventLoopGroup 包含多个 EventLoop，可以把一个 EventLoop 当做是 Reactor 线程模型中的一个线程，而一个 EventLoopGroup 类似于一个 ExecutorService\n说说 Netty 的零拷贝 “零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。\nNetty 内部执行流程 1、Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2、Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一 个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer\n","permalink":"https://coderrenxy.github.io/posts/read/10%E7%99%BE%E5%BA%A6/","summary":"百度Java中级面试 Spring BeanFactory 和 ApplicationContext 有什么区别 1、BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义， 以便在","title":""},{"content":"京东Java中级面试 1、哪些情况下的对象会被垃圾回收机制处理掉？ 利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用链\n向下寻找，如果某个对象不能通过 GC Roots 寻找到，虚拟机就认为该对象可以被回收掉。\n1.1 哪些对象可以被看做是 GC Roots 呢？ 1）虚拟机栈（栈帧中的本地变量表）中引用的对象；\n2）方法区中的类静态属性引用的对象，常量引用的对象；\n3）本地方法栈中 JNI(Native 方法）引用的对象；\n1.2 对象不可达，一定会被垃圾收集器回收么？ 即使不可达，对象也不一定会被垃圾收集器回收，\n1）先判断对象是否有必要执行 finalize()方法，对象必须重写 finalize()方法且没有被运行过。\n2）若有必要执行，会把对象放到一个队列中，JVM 会开一个线程去回收它们，这是对象最后一次可以逃逸清理的机会。\n2、讲一下常见编码方式？ 编码的意义：计算机中存储的最小单元是一个字节即 8bit，所能表示的字符范围是 255 个， 而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻 译成计算机能懂的语言。\n1）\nASCII 码：总共 128 个，用一个字节的低 7 位表示，\n0〜31 控制字符如换回车删除等；\n32~126 是打印字符，可通过键盘输入并显示出来；\n2）ISO-8859-1,用来扩展 ASCII 编码，256 个字符，涵盖了大多数西欧语言字符。\n3）GB2312:双字节编码，总编码范围是 A1-A7,A1-A9 是符号区，包含 682 个字符，B0-B7 是\n汉字区，包含 6763 个汉字；\n4）GBK 为了扩展 GB2312,加入了更多的汉字，编码范围是 8140~FEFE，有 23940 个码位，能\n表示 21003 个汉字。\n5）UTF-16: ISO 试图想创建一个全新的超语言字典，世界上所有语言都可通过这本字典\nUnicode 来相互翻译，而 UTF-16 定义了 Unicode 字符在计算机中存取方法，用两个字节来表\n示 Unicode 转化格式。不论什么字符都可用两字节表示，即 16bit，固叫 UTF-16。\n6）UTF-8：UTF-16 统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪\n费存储空间，而 UTF-8 采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成。\n3、utf-8 编码中的中文占几个字节 int 型几个字节？\nutf-8 是一种变长编码技术，utf-8 编码中的中文占用的字节不确定，可能 2 个、3 个、4 个，\nint 型占 4 个字节。\n4、静态代理和动态代理的区别，什么场景使用？ 代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问， 将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。\n区别：\n1）静态代理：由程序员创建或是由特定工具生成，在代码编译时就确定了被代理的类是哪一个是静态代理。静态代理通常只代理一个类；\n2）动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类；\n实现步骤：a.实现 InvocationHandler 接口创建自己的调用处理器；b.给 Proxy 类提供ClassLoader 和代理接口类型数组创建动态代理类；c.利用反射机制得到动态代理类的构造函数；d.利用动态代理类的构造函数创建动态代理类对象；\n使用场景：Retrofit 中直接调用接口的方法；Spring 的 AOP 机制；\n5、Java 的异常体系 Java 中 Throwable 是所有异常和错误的超类，两个直接子类是 Error（错误）和 Exception（异常）：\n1）Error 是程序无法处理的错误，由 JVM 产生和抛出，如 OOM、ThreadDeath 等。这些异常发生时，JVM 一般会选择终止程序。\n2）Exception 是程序本身可以处理的异常，又分为运行时异常(RuntimeException)(也叫 Checked Eception) 和 非 运 行 时 异 常 ( 不 检 查 异 常 Unchecked Exception) 。 运 行 时 异 常 有 NullPointerException\\IndexOutOfBoundsException 等，这些异常一般是由程序逻辑错误引起的，应尽可能避免。非运行时异常有 IOException\\SQLException\\FileNotFoundException 以及 由用户自定义的 Exception 异常等。\n6、谈谈你对解析与分派的认识。 解析指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。\n分派可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。动态分派则需要根据实际类型来调用相应的方法。\n7、修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？ 会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和==都是比较栈内局部变量表中指向堆内存地址值是否相等。\n8、Java 中实现多态的机制是什么？ 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。这样就可以不用修改源程序，就可以让引用变量绑定到各种不同的类实现上。\nJava 实现多态有三个必要条件：\n继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。\n9、如何将一个 Java 对象序列化到文件里？ ObjectOutputStream.writeObject()负责将指定的流写入，ObjectInputStream.readObject()从指定流读取序列化数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //写入  try { ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\u0026#34;D:/student.txt\u0026#34;)); os.writeObject(studentList); os.close(); } catch(FileNotFoundException e) { e.printStackTrace(); } catch(IOException e) { e.printStackTrace(); }   10、说说你对 Java 反射的理解 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性。这种能动态获取信息及动态调用对象方法的功能称为 java语言的反射机制。\n反射的作用：开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用 java 的反射机制通过反射来获取所需的私有成员或是方法。\n  获取类的 Class 对象实例 Class clz = Class.forName(\u0026ldquo;com.zhenai.api.Apple\u0026rdquo;);\n  根 据 Class 对 象 实 例 获 取 Constructor 对 象\n  Constructor appConstructor = clz.getConstructor();\n 使 用 Constructor 对 象 的 newInstance 方 法 获 取 反 射 类 对 象 Object appleObj = appConstructor.newInstance();\n  获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\u0026ldquo;setPrice\u0026rdquo;, int.class);5) 利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14);\n  通过 getFields()可以获取 Class 类的属性，但无法获取私有属性，而 getDeclaredFields()可以获取到包括私有属性在内的所有属性。带有 Declared 修饰的方法可以反射到私有的方法，没有 Declared 修饰的只能用来反射公有的方法，其他如 Annotation\\Field\\Constructor 也是如此。\n  11、说说你对 Java 注解的理解 注解是通过@interface 关键字来进行定义的，形式和接口差不多，只是前面多了一个@\n1 2 3  public @interface TestAnnotation { }   使用时@TestAnnotation 来引用，要使注解能正常工作，还需要使用元注解，它是可以注解 到注解上的注解。元标签有@Retention @Documented @Target @Inherited @Repeatable 五种\n@Retention 说明注解的存活时间，取值有 RetentionPolicy.SOURCE 注解只在源码阶段保留， 在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到 JVM 中。\nRetentionPolicy.RUNTIME 可以留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。\n@Documented 注解中的元素包含到 javadoc 中去\n@Target\n限 定 注 解 的 应 用 场 景 ， ElementType.FIELD 给 属 性 进 行 注 解 ；\nElementType.LOCAL_VARIABLE 可以给局部变量进行注解；ElementType.METHOD 可以给方法进行注解；ElementType.PACKAGE 可以给一个包进行注解 ElementType.TYPE 可以给一个类型进行注解，如类、接口、枚举\n@Inherited 若一个超类被@Inherited 注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解；\n注解的作用：\n1）提供信息给编译器：编译器可利用注解来探测错误和警告信息\n2）编译阶段：软件工具可以利用注解信息来生成代码、html 文档或做其它相应处理；\n3）运行阶段：程序运行时可利用注解提取代码\n注解是通过反射获取的，可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了某个注解，再通过 getAnnotation()方法获取 Annotation 对象\n12、说一下泛型原理，并举例说明 泛型就是将类型变成参数传入，使得可以使用的类型多样化，从而实现解耦。Java 泛型是在Java1.5 以后出现的，为保持对以前版本的兼容，使用了擦除的方法实现泛型。擦除是指在一定程度无视类型参数 T，直接从 T 所在的类开始向上 T 的父类去擦除，如调用泛型方法，传入类型参数 T 进入方法内部，若没在声明时做类似 public T methodName(T extends Fathert){}，Java 就进行了向上类型的擦除，直接把参数 t 当做 Object 类来处理，而不是传进去的 T。\n即在有泛型的任何类和方法内部，它都无法知道自己的泛型参数，擦除和转型都是在边界上发生，即传进去的参在进入类或方法时被擦除掉，但传出来的时候又被转成了我们设置的 T。\n在泛型类或方法内，任何涉及到具体类型（即擦除后的类型的子类）操作都不能进行，如new T()，或者 T.play()（play 为某子类的方法而不是擦除后的类的方法）\n13、Java 中 String 的了解 1）String 类是 final 型，固 String 类不能被继承，它的成员方法也都默认为 final 方法。String对象一旦创建就固定不变了，对 String 对象的任何改变都不影响到原对象，相关的任何改变操作都会生成新的 String 对象。\n2）String 类是通过 char 数组来保存字符串的，String 对 equals 方法进行了重定，比较的是值相等。\n1 2 3  String a = \u0026#34;test\u0026#34;; String b = \u0026#34;test\u0026#34;; String c = new String(\u0026#34;test\u0026#34;);   a、b 和字面上的 test 都是指向 JVM 字符串常量池中的\u0026quot;test\u0026quot;对象，他们指向同一个对象。而new 关键字一定会产生一个对象 test，该对象存储在堆中。所以 new String(\u0026ldquo;test\u0026rdquo;)产生了两个对象，保存在栈中的 c 和保存在堆中的 test。而在 java 中根本就不存在两个完全一模一样的字符串对象，故在堆中的 test 应该是引用字符串常量池中的 test。\n例：\nString str1 = \u0026ldquo;abc\u0026rdquo;; //栈中开辟一块空间存放引用 str1，str1 指向池中 String 常量\u0026quot;abc\u0026quot;\nString str2 = \u0026ldquo;def\u0026rdquo;; //栈中开辟一块空间存放引用 str2，str2指向池中 String 常量\u0026quot;def\u0026quot;\nString str3 = str1 + str2;//栈中开辟一块空间存放引用 str3\n//str1+str2 通过 StringBuilder 的最后一步 toString()方法返回一个新的 String 对象\u0026quot;abcdef\u0026quot;\n//会在堆中开辟一块空间存放此对象，引用str3指向堆中的(str1+str2)所返回的新String对象。\nSystem.out.println(str3 == \u0026ldquo;abcdef\u0026rdquo;);//返回 false\n因为 str3 指向堆中的\u0026quot;abcdef\u0026quot;对象，而\u0026quot;abcdef\u0026quot;是字符池中的对象，所以结果为 false。JVM对 String str=\u0026ldquo;abc\u0026quot;对象放在常量池是在编译时做的，而 String str3=str1+str2 是在运行时才知道的，new 对象也是在运行时才做的。\n14、String 为什么要设计成不可变的？ 1）字符串常量池需要 String 不可变。因为 String 设计成不可变，当创建一个 String 对象时，若此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。\n如果字符串变量允许必变，会导致各种逻辑错误，如改变一个对象会影响到另一个独立对象。\n2）String 对象可以缓存 hashCode。字符串的不可变性保证了 hash 码的唯一性，因此可以缓存 String 的 hashCode，这样不用每次去重新计算哈希码。在进行字符串比较时，可以直接比较 hashCode，提高了比较性能；\n3）安全性。String 被许多 java 类用来当作参数，如 url 地址，文件 path 路径，反射机制所需的 Strign 参数等，若 String 可变，将会引起各种安全隐患。\n","permalink":"https://coderrenxy.github.io/posts/read/11%E4%BA%AC%E4%B8%9C/","summary":"京东Java中级面试 1、哪些情况下的对象会被垃圾回收机制处理掉？ 利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用","title":""},{"content":"蚂蚁面试题总结 1. jdk1.7到jdk1.8 Map发生了什么变化(底层)?\n1.8之后hashMap的数据结构发生了变化，从之前的单纯的数组+链表结构变成数组+链表+红黑树。也就是说在JVM存储hashMap的K-V时仅仅通过key来决定每一个entry的存储槽位（Node[]中的index）。并且Value以链表的形式挂在到对应槽位上（1.8以后如果value长度大于8则转为红黑树）。\n但是hashmap1.7跟1.8 中都没有任何同步操作，容易出现并发问题，甚至出现死循环导致系统不可用。解决方案是jdk的ConcurrentHashMap，位于java.util.concurrent下，专门解决并发问题。\n2. ConcurrentHashMap\n思路与hashMap差不多，但是支持并发操作，要复杂很多\n3. 并行跟并发有什么区别？\n并发：指应用交替执行不同的任务，多线程原理\n并行：指应用同时执行不用的任务\n区别：一个是交替执行，一个是同时执行。\n4. jdk1.7到jdk1.8 java虚拟机发生了什么变化?\nJVM中内存份为堆、栈内存，及方法区。\n**栈内存主要用途：**执行线程方法，存放本地临时变量与线程方法执行是需要的引用对象的地址。\n**堆内存主要用途：**JVM中所有对象信息都存放在堆内存中，相比栈内存，堆内存大很多所以JVM一直通过对堆内存划分不同功能区块实现对堆内存中对象管理。\n堆内存不够常见错误：OutOfMemoryError\n栈内存溢出常见错误：StackOverFlowError\n在JDK7以及其前期的JDK版本中，堆内存通常被分为三块区域Nursery内存(young generation)、长时内存(old generation)、永久内存(Permanent Generation for VM Matedata)，显示如下图：\n在最上面一层是Nursery内存，一个对象被创建以后首先被房到Nuersery中的Eden内存中，如果存活周期超过两个Survivor（生存周期）之后会被转移到Old Generation中。\n永久内存中存放对象的方法、变量等元数据信息。永久内存不够就会出现 以下错误：java.lang.OutOfMemoryError:PermGen\n但是在JDK1.8中一般都不会得到这个错误，原因在于：1.8中把存放元数据的永久内存从堆内存中已到了本地内存（native Memory）中，1.8中JVM内存结构变成了如下图：这样永久内存就不占用堆内存，可以通过自增长来避免永久内存错误。\n-XX:MaxMetaspaceSize=128m 这只最大的远内存空间128兆\nJDK1.8移除PermGen，取而代之的是MetaSpace源空间\nMetaSpace 垃圾回收：对僵死的类及类加载器的垃圾回收机制昂在元数据使用达到“MaxMetaSpaceSize”参数的设定值时运行。\n**MetaSpace 监控：**元空间的使用情况可以在HotSpot1.8的详细GC日志输出中得到。\n更新JDK1.8的原因：\n1.字符串存在永久代当中，容易出现性能问题和内存溢出\n2.类及方法的信息比较难确定其大小，因此对永久代的大小制定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n3.永久代会为GC带来不必要的复杂度，并且回收效率偏低\n4.Oracle可能会想HotSpot 与 JRockit 合并。\n5. 如果叫你自己设计一个中间件,你会如何设计?\n我会从以下几点方面考虑开发：\n1) 远程过程调用\n2) **面向消息：**利用搞笑的消息传递机制进行平台无关的数据交流，并给予数据通信来进行分布式系统的集成，有一下三个特点：\ni) 通讯程序可以在不同的时间运行\nii) 通讯晨旭之家可以一对一、一对多、多对一甚至是上述多种方式的混合\niii) 程序将消息放入消息队列会从小吸毒列中取出消息来进行通讯\n3) 对象请求代理：提供不同形式的通讯服务包括同步、排队、订阅发布、广播等。可构筑各种框架如：事物处理监控器、分布数据访问、对象事务管理器OTM等。\n4) 事物处理监控有一下功能：\na) 进程管理，包括启动server进程、分配任务、监控其执行并对负载进行平衡\nb) 事务管理，保证在其监控下的事务处理的原子性、一致性、独立性和持久性\nc) 通讯管理，为client和server之间提供多种通讯机制，包括请求响应、会话、排队、订阅发布和广播等\n6. 什么是中间件？\n中间件是处于操作系统和应用程序之间软件，使用时旺旺是一组中间件集成在一起，构成一个平台（开发平台+运行平台），在这组中间件中必须要有一个通信中间件，即中间件=平台+通信。该定义也限定了只有勇于分布式系统中才能称为中间件\n主要分类：远程过程调用、面向消息的中间件、对象请求代理、事物处理监控。\n7. ThreadLock用过没有,说说它的作用?\nThreadLock为本地线程，为每一个线程提供一个局部变量，也就是说只有当前线层可以访问，是线程安全的。原理：为每一个线程分配一个对象来工作，并不是由ThreadLock来完成的，而是需要在应用层面保证的，ThreadLock只是起到了一个容器的作用。原理为ThreadLock的set()跟get()方法。\n实现原理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; } return setInitialValue(); }    dubbox和spring cloud区别?\n  dubbox的源码看过没,dubbox有哪些组件,介绍下?\n  10. Hashcode（）和equals（）和==区别?\n(1) hashcode()方法跟equals()在java中都是判断两个对象是否相等\n(2) 两个对象相同，则hashcode至一定要相同，即对象相同 \u0026mdash;-\u0026gt;成员变量相同 \u0026mdash;-\u0026gt;hashcode值一定相同\n(3) 两个对象的hashcode值相同，对象不一定相等。总结：equals相等则hashcode一定相等，hashcode相等，equals不一定相等。\n(4) ==比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间）\n11. mysql数据库中,什么情况下设置了索引但无法使用?\n(1) 索引的作用：在数据库表中对字段建立索引可以大大提高查询速度。\n(2) Mysql索引类型：\na) 普通索引\nb) 唯一索引：唯一索引列的值必须唯一允许有空值，如果是组合索引，则列值的组合必须唯一：\nCREATE UNIQUE INDEX indexName ON mytable(username(length)) \u0026ndash; 修改表结构 ALTER mytable ADD UNIQUE [indexName] ON (username(length)) \u0026ndash; 创建表的时候直接指定 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );\nc) 主键索引：一种特殊的唯一索引，不允许有空值，一般在创建表的时候创建主键索引：\nCREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );\nd) 组合索引：CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );\n为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是\t将 name, city, age建到一个索引里：代码如下:\nALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);\n(3) 什么情况下有索引，但用不上？\na) 如果条件中有OR，即使其中有部分条件带索引也不会使用。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。\nb) 对于多了索引，不是使用的第一部分，则不会使用索引。\nc) Like查询以%开头，不使用索引\nd) 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引\ne) Where 子句里对索引列上有数学运算，用不上索引\nf) Where 子句中对索引列使用函数，用不上索引\ng) Mysql估计使用全表扫描要比用索引快，不使用索引\n(4) 什么情况下不推荐使用索引？\na) 数据唯一性差的字段不要使用索引\nb) 频繁更新的字段不要使用索引\nc) 字段不在where语句中出现时不要添加索引，如果where后含IS NULL/IS NOT NULL/LIKE ‘%输入符%’等条件，不要使用索引\nd) Where子句里对索引使用不等于（\u0026lt;\u0026gt;），不建议使用索引，效果一般\n12. mysql优化会不会,mycat分库,垂直分库,水平分库?\n(1) 为查询缓存优化你的查询\n(2) EXPLAIN select查询：explain 的查询结果会告诉你索引主键是如何被利用的\n(3) 只需要一行数据时使用limit1\n(4) 为搜索字段添加索引\n(5) 在关联表的时候使用相当类型的例，并将其索引\n(6) 千万不要ORDER BY RAND()\n(7) 避免select*\n(8) 永远为每张表设置一个ID\n(9) 使用ENUM而不是VARCHAR\n(10) 从PROCEDURE ANALYS()提取建议\n(11) 尽可能的使用NOT NULL\n(12) Java中使用Prepared Statements\n(13) 无缓冲的查询\n(14) 把IP地址存成UNSIGNED INT\n(15) 固定表的长度\n(16) 垂直分库：“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。\n(17) 水平分库：“水平分割”是一种把数据库中的表按行变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。\n(18) 越小的列会越快\n(19) 选择正确的存储引擎\n(20) 使用一个对象关系映射器\n(21) 小心永久链接\n(22) 拆分大的DELETE活INSERT语句\n13. 分布式事务解决方案?\n(1) 什么是分布式事务？\na. 什么情况下需要用到分布式事务？\na) 当本地数据库断电、机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠TCP、存储数据丢失、其他异常等需要用到分布式事务。\nb) 例如：当本地事务数据库断电的这种秦光，如何保证数据一致性？数据库由连个文件组成的，一个数据库文件和一个**日志文件，**数据库任何写入操作都要先写日志，在操作前会吧日志文件写入磁盘，那么断电的时候及时才做没有完成，在重启数据库的时候，数据库会根据当前数据情况进行undo回滚活redo前滚，保证了数据的强一致性。\nc) 分布式理论：当单个数据库性能产生瓶颈的时候，可能会对数据库进行分区（物理分区），分区之后不同的数据库不同的服务器上\t，此时单个数据库的ACID不适应这种清苦啊，在此集群环境下很难达到集群的ACID，甚至效率性能大幅度下降，重要的是**再很难扩展新的分区了。**此时就需要引用一个新的理论来使用这种集群情况：CAP定理\nd) CAP定理:由加州肚饿伯克利分销Eric Brewer教授提出，指出WEB服务无法同时满足3个属性：\na. 一致性：客户端知道一系列的操作都会同时发生（生效）\nb. 可用性：每个操作都必须以可预期的响应结束\nc. 分区容错性：及时出现单组件无法可用，操作依然可以完成。\n具体的将在分布式系统中，在任何数据库设计中，一个WEB应\n至多只能同时支持上面两个属性。设计人员必须在一致性和可用\n性之间做出选择。\ne) BASE理论：分布式系统中追求的是可用性，比一致性更加重要，BASE理论来实现高可用性。核心思想是：我们无法做到羟乙酯，单每个应用都可以根据自身的业务特点，采用适当的方式使系统达到最终一致性。\nf) 数据库事务特性：ACID\ni. 原子性\nii. 一致性\niii. 独立性或隔离性\niv. 持久性\n(2) 分布式系统中，实现分布式事务的解决方案：\na. 两阶段提交2PC\nb. 补偿事务TCC\nc. 本地消息表（异步确保）\nd. MQ事务消息\ne. Sagas事务模型\n(3)\n14. sql语句优化会不会,说出你知道的?\n(1) 避免在列上做运算，可能会导致索引失败\n(2) 使用join时应该小结果集驱动大结果集，同时把复杂的join查询拆分成多个query，不然join越多表，会导致越多的锁定和堵塞。\n(3) 注意like模糊查询的使用，避免使用%%\n(4) 不要使用select * 节省内存\n(5) 使用批量插入语句，节省交互\n(6) Limit基数比较大时，使用between and\n(7) 不要使用rand函数随机获取记录\n(8) 避免使用null，建表时，尽量设置not nul，提高查询性能\n(9) 不要使用count（id），应该使用count（*）\n(10) 不要做无谓的排序，尽可能在索引中完成排序\n(11) From语句中一定不要使用子查询\n(12) 使用更多的where加以限制，缩小查找范围\n(13) 合理运用索引\n(14) 使用explain查看sql性能\n15. mysql的存储引擎了解过没有?\n(1) MySQL存储引擎种类：\n(2) https://blog.csdn.net/m0_37888031/article/details/80704344\n(3) https://blog.csdn.net/m0_37888031/article/details/80664138\n(4) 事务处理：在整个流程中出现任何问题，都能让数据回滚到最开始的状态，这种处理方式称之为事务处理。也就是说事务处理要么都成功，要么的失败。\n16. 红黑树原理？\n(1) 红黑树的性质：红黑树是一个二叉搜索树。在每个节点增加了一个存储位记录节点的颜色，可以是RED，也可以是BLACK，通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的两倍，加以平衡。性质如下：\ni. 每个节点颜色不是黑色就是红色\nii. 根节点的颜色是黑色的\niii. 如果一个节点是红色，那么他的两个子节点就是黑色的，没有持续的红节点\niv. 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点。\n","permalink":"https://coderrenxy.github.io/posts/read/12%E8%9A%82%E8%9A%81/","summary":"蚂蚁面试题总结 1. jdk1.7到jdk1.8 Map发生了什么变化(底层)? 1.8之后hashMap的数据结构发生了变化，从之前的单纯的数组+链","title":""},{"content":"软通动力Java中级 1、锁可以锁在哪里？ Java 为程序加锁的方式主要有两种：synchronized 与 Lock。\n1、synchronized 可以修饰的作用域如下：\n 非静态方法（加的锁为对象锁）； 静态方法（加的锁为类锁）； 代码块（对象锁与类锁均可）；  2、Lock 采用 lock()对代码加锁，unlock()进行解锁\n参考文章：https://blog.csdn.net/yx0628/article/details/79086511\n2、怎么利用反射获取类中的对象？\n 获取 Class 对象 通过 Class 对象获取构造方法 通过构造方法调用 newInstance()方法创建对象实例  参考文章 ：https://baijiahao.baidu.com/s?id=1619748187138646880\u0026amp;wfr=spider\u0026amp;for=pc\n3、HTTP 和 https 区别？ 1、 HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。\n2、使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。\n3、HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\n4、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80， 后者是 443。\n5、HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS比 HTTP 要更耗费服务器资源。\n参考文章：https://www.runoob.com/w3cnote/http-vs-https.html\n4、谈谈你对 TCP / IP 协议的了解 \\1. TCP/IP 是一个协议簇，是一个开放的协议标准，所有人都可以免费使用，并且是独立于硬件和操作系统的。\n2、TCP/IP 协议是不区分网络硬件的，它在局域网，广域网和互联网中都被广泛使用。\n3、TCP/IP 协议使用统一的网络地址分配的方案，网络中的每台电脑都具有唯一的 IP地址。\n\\4. TCP/IP 协议是一个标准的高层协议，拥有极高的可靠性，可以为用户提供可靠的服务。\n参考文章： https://blog.csdn.net/my_learning_road/article/details/79941273\n5、说说 Aop 和 IOC 的应用 IOC 的主要应用场景体现在 BeanFactory 接口，BeanFactory 下面有具体的实现类来实现 IOC 的功能。\nAOP 的主要应用场景：日志、权限、事物等。\n6、Spring 中 bean 是线程安全的吗？ Spring 容器中的 Bean 本身不具备线程安全的特性，但是具体还是要结合具体scope 的 Bean 去研究。\n1、Spring 容器中的 Bean 默认是单例的，所有线程都共享一个单实例的 Bean，因此是存在资源的竞争。\n如果单例 Bean,是一个无状态 Bean，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的。\n比如Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。对于有状态的 bean，是线程不安全的，但是我们可以通过ThreadLocal 去解决线程安全的方法。\n2、对于原型 Bean（即 scope=\u0026ldquo;prototype\u0026rdquo;）,每次创建一个新对象，也就是线程之间并不存在 Bean 共享，自然是不会有线程安全的问题。\n参考文章：https://blog.csdn.net/qq_29645505/article/details/88432001\n7、Maven 中 package 和 install 区别 package 是把 jar 打到本项目的 target 下，而 install 时把 target 下的 jar 安装到本地仓库，供其他项目使用。\n8、遇到过哪些设计模式？ 参考文章：https://www.cnblogs.com/Leo_wl/p/6067267.html\n9、谈谈简单工厂和抽象工厂的区别 简单工厂模式：是由一个工厂对象创建产品实例，简单工厂模式的工厂类一般是使用静态方法，通过不同的参数的创建不同的对象实例 可以生产结构中的任意产品，不能增加新的产品\n抽象工厂模式： 提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类，生产多个系列产品 生产不同产品族的全部产品，不能新增产品，可以新增产品族\n参考文章：https://www.cnblogs.com/gclokok/p/10029088.html\n10、说说你常用的 Linux 基本操作命令\nls - 用来显示目标列表\ncd - 用来切换工作目录\npwd - 以绝对路径的方式显示用户当前工作目录\ncat - 文件内容查看\ngrep - 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行\n打印出来tail - 输出文件中的尾部内容\nps - 用于报告当前系统的进程状态\nkill - 命令用来删除执行中的程序或工作\ntop - 可以实时动态地查看系统的整体运行情况\n11、谈谈 Currenthashmap 的扩容机制 JDK1.7**：**\n先对数组的长度增加一倍，然后遍历原来的旧的 table 数组，把每一个数组元素也就是 Node 链表迁移到新的数组里面，最后迁移完毕之后，把新数组的引用直接替换旧的。\nJDK1.8**：**\n扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用 tabAt 方法获得 i 位置的元素 f，初始化一个 forwardNode 实例 fwd，如果 f == null，则在 table 中的 i 位置放入 fwd，否则采用头插法的方式把当前旧table 数组的指定任务范围的数据给迁移到新的数组中，然后 给旧 table 原位置赋值fwd。\n直到遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新 sizeCtl 为新数组大小的 0.75 倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断 head 节点是否为 forwardNode 节点，如果是就帮助扩容。\n参考文章：https://blog.csdn.net/axibaaa/article/details/97109455\n","permalink":"https://coderrenxy.github.io/posts/read/13%E8%BD%AF%E9%80%9A%E5%8A%A8%E5%8A%9B/","summary":"软通动力Java中级 1、锁可以锁在哪里？ Java 为程序加锁的方式主要有两种：synchronized 与 Lock。 1、synchronized 可以修","title":""},{"content":"银盛支付Java中级 1. 说说springcloud的⼯作原理 springcloud由以下⼏个核⼼组件构成：\nEureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉\n取注册表，从⽽知道其他服务在哪⾥\nRibbon：服务间发起请求的时候，基于Ribbon做负载均衡，从⼀个服务的多台机器中选择⼀台\nFeign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求\nHystrix：发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，避免了服务雪崩\n的问题\nZuul：如果前端、移动端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务\n2. ⽤什么组件发请求 在Spring Cloud中使⽤Feign, 我们可以做到使⽤HTTP请求远程服务时能与调⽤本地⽅法⼀样的编码体验，开发者完全感知不到\n这是远程⽅法，更感知不到这是个HTTP请求。\n3. 注册中心心跳是几秒 1、Eureka的客户端默认每隔30s会向eureka服务端更新实例，注册中⼼也会定时进⾏检查，发现某个实例默认90s内没有再收到\n⼼跳，会注销此实例，这些时间间隔是可配置的。\n2、不过注册中⼼还有⼀个保护模式（服务端在短时间内丢失过多客户端的时候，就会进⼊保护模式），在这个保护模式下，他\n会认为是⽹络问题，不会注销任何过期的实例。\n4. 消费者是如何发现服务提供者的 a. 当⼀个服务实例启动，会将它的ip地址等信息注册到eureka；\nb. 当a服务调⽤b服务，a服务会通过Ribbon检查本地是否有b服务实例信息的缓存；\nc. Ribbon会定期从eureka刷新本地缓存。\n5. 多个消费者调用同⼀接⼝，eruka默认的分配方式是什么 a. RoundRobinRule:轮询策略，Ribbon以轮询的⽅式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问;\nb. RandomRule:随机选择，也就是说Ribbon会随机从服务器列表中选择⼀个进⾏访问;\nc. BestAvailableRule:最⼤可⽤策略，即先过滤出故障服务器后，选择⼀个当前并发请求数最⼩的;\nd. WeightedResponseTimeRule:带有加权的轮询策略，对各个服务器响应时间进⾏加权处理，然后在采⽤轮询的⽅式来获取相\n应的服务器;\ne. AvailabilityFilteringRule:可⽤过滤策略，先过滤出故障的或并发请求⼤于阈值⼀部分服务实例，然后再以线性轮询的⽅式从\n过滤后的实例清单中选出⼀个;\nf. ZoneAvoidanceRule:区域感知策略，先使⽤主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例\n清单，依次使⽤次过滤条件列表中的过滤条件对主过滤条件的结果进⾏过滤，判断最⼩过滤数（默认1）和最⼩过滤百分⽐（默\n认0），最后对满⾜条件的服务器则使⽤RoundRobinRule(轮询⽅式)选择⼀个服务器实例。\n6. 说说常⽤的springboot注解，及其实现？\na. @Bean：注册Bean\ni. 默认使⽤⽅法名作为id，可以在后⾯定义id如@Bean(\u0026ldquo;xx\u0026rdquo;)；\nii. 默认为单例。\niii. 可以指定init⽅法和destroy⽅法：\n  对象创建和赋值完成，调⽤初始化⽅法；\n  单实例bean在容器销毁的时候执⾏destroy⽅法；\n  多实例bean，容器关闭是不会调⽤destroy⽅法。\n  b. @Scope：Bean作⽤域\ni. 默认为singleton；\nii. 类型：\n singleton单实例（默认值）：ioc容器启动时会调⽤⽅法创建对象放到ioc容器中，以后每次获取就是直接从容器中拿  实例；\n prototype多实例：ioc容器启动不会创建对象，每次获取时才会调⽤⽅法创建实例；\n  request同⼀次请求创建⼀个实例；\n  session同⼀个session创建⼀个实例。\n  c. @Value：给变量赋值\ni. 代码：\n1 2 3 4 5 6 7 8 9 10 11  import org.springframework.beans.factory.annotation.Value; public class Person extends BaseEntity{ @Value(\u0026#34;xuan\u0026#34;) private String name; @Value(\u0026#34;27\u0026#34;) private int age; @Value(\u0026#34;#{20-7}\u0026#34;) private int count; @Value(\u0026#34;$person.nickName}\u0026#34;) private String nickName; }   i. ⽅式：\n  基本数字\n  可以写SpEL（Spring EL表达式）：#{}\n  可以写${}，取出配置⽂件中的值（在运⾏环境变量⾥⾯的值）\n  d. @Autowired：⾃动装配\ni. 默认优先按照类型去容器中找对应的组件：BookService bookService = applicationContext.getBean(BookService.class);\nii. 默认⼀定要找到，如果没有找到则报错。可以使⽤@Autowired(required = false)标记bean为⾮必须的。\niii. 如果找到多个相同类型的组件，再根据属性名称去容器中查找。\niv. @Qualifier(\u0026ldquo;bookDao2\u0026rdquo;)明确的指定要装配的bean。\nv. @Primary：让spring默认装配⾸选的bean，也可以使⽤@Qualifier()指定要装配的bean。\ne. @Profile：环境标识\ni. Spring为我们提供的可以根据当前环境，动态的激活和切换⼀系列组件的功能；\nii. @Profile指定组件在哪个环境才能被注册到容器中，默认为\u0026quot;default\u0026quot;@Profile(\u0026ldquo;default\u0026rdquo;)。\niii. 激活⽅式：\n  运⾏时添加虚拟机参数：-Dspring.profiles.active=test\n  代码⽅式：\n  7. spring的事务注解是什么？什么情况下事物才会回滚 a. spring事务实现机制：\nb. 事务注解@transactional；\nc. 默认情况下，如果在事务中抛出了未检查异常（继承⾃ RuntimeException 的异常）或者 Error，则 Spring 将回滚事务。\nd. @Transactional 只能应⽤到 public ⽅法才有效：只有@Transactional 注解应⽤到 public ⽅法，才能进⾏事务管理。这是因为\n在使⽤ Spring AOP 代理时，Spring 在调⽤在图 1 中的 TransactionInterceptor 在⽬标⽅法执⾏前后进⾏拦截之前，\nDynamicAdvisedInterceptor（CglibAopProxy 的内部类）的的 intercept ⽅法或 JdkDynamicAopProxy 的 invoke ⽅法会间接调\n⽤ AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）\n的 computeTransactionAttribute ⽅法。\n8. 说说spring事物的传播性和隔离级别 a. 七个事传播属性：\n  PROPAGATION_REQUIRED \u0026ndash; ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。\n  PROPAGATION_SUPPORTS \u0026ndash; ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。\n  PROPAGATION_MANDATORY \u0026ndash; ⽀持当前事务，如果当前没有事务，就抛出异常。\n  PROPAGATIONREQUIRESNEW \u0026ndash; 新建事务，如果当前存在事务，把当前事务挂起\n  PROPAGATIONNOTSUPPORTED \u0026ndash; 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。\n  PROPAGATION_NEVER \u0026ndash; 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。\n  PROPAGATIONNESTED \u0026ndash; 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与 PROPAGATIONREQUIRED类似的操作。\n  b. 五个隔离级别：\n  ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.\n  另外四个与JDBC的隔离级别相对应：\n  ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种\n  隔离级别会产⽣脏读，不可重复读和幻读。\n ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。\n  ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。\n  ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。\n  c. 关键词：\n1、脏读（新增或删除）：脏读就是指当⼀个事务正在访问数据，并且对数据进⾏了修改，⽽这种修改还没有提交到数据库 中，这时，另外⼀个事务也访问这个数据，然后使⽤了这个数据；\n Mary的原工资为1000，财务人员将Mary的工资改为了8000（但未提交事务） Mary读取自己的工资，发现自己的工资变为了8000，欢天喜地！ 而财务发现操作有误，回滚了事务，May的工资又变为了1000像这样，Mary记取的工资数8000是一个脏数据。  2、不可重复读（修改）：是指在⼀个事务内，多次读同⼀数据。在这个事务还没有结束时，另外⼀个事务也访问该同⼀数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改，那么第⼀个事务两次读到的的数据可能是不⼀样的。这样在⼀个事务内两次读到的数据是不⼀样的，因此称为是不可重复读。（解决：只有在修改事务完全提交之后才可以读取数据，则可以避免该问题）；\n 在事务1中，May读取了自己的工资为1000，操作并没有完成 在事务2中，这时财务人员修改了Mary的工资为2000，并提交了事务. 在事务1中，Mary再次读取自己的工资时，工资变为了2000  3、幻读（新增或删除）：是指当事务不是独⽴执⾏时发⽣的⼀种现象，例如第⼀个事务对⼀个表中的数据进⾏了修改，这种修改涉及到表中的全部数据⾏。同时，第⼆个事务也修改这个表中的数据，这种修改是向表中插⼊⼀⾏新数据。那么，以后就会发⽣操作第⼀个事务的⽤户发现表中还有没有修改的数据⾏，就好象发⽣了幻觉⼀样（解决：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题）。\n目前工资为1000的员工有10人。\n 事务1，读取所有工资为1000的员工。 这时事务2向employee表插入了一条员工记录，工资也为1000 事务1再次读取所有工资为1000的员工共读取到了11条记录。  9. mysql的引擎有什么？他们的区别 a. InnoDB：\n  ⽀持事务处理\n  ⽀持外键\n  ⽀持⾏锁\n  不⽀持FULLTEXT类型的索引（在Mysql5.6已引⼊）\n  不保存表的具体⾏数，扫描表来计算有多少行\n  对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引\n  DELETE 表时，是一行一行的删除\n  InnoDB 把数据和索引存放在表空间⾥⾯\n  跨平台可直接拷⻉使⽤\n  表格很难被压缩\n  b. MyISAM：\n  不⽀持事务，回滚将造成不完全回滚，不具有原⼦性\n  不⽀持外键\n  ⽀持全⽂搜索\n  保存表的具体⾏数,不带where时，直接返回保存的⾏数\n  DELETE 表时，先drop表，然后重建表\n  MyISAM 表被存放在三个⽂件 。frm ⽂件存放表格定义。 数据⽂件是MYD (MYData) 。 索引⽂件是MYI (MYIndex)引伸\n  跨平台很难直接拷⻉\n  AUTO_INCREMENT类型字段可以和其他字段⼀起建⽴联合索引\n  表格可以被压缩\n  c. 选择：因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原⼦性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接⽤备份覆盖恢复。如果系统读少，写多的时候，尤其是并发写⼊⾼的时候。InnoDB就是⾸选了。两种类型都有⾃⼰优缺点，选择那个完全要看⾃⼰的实际类弄。\n10. innodb如何实现mysql的事务 事务进行过程中，每次sql语句执⾏，都会记录undo log和redo log，然后更新数据形成脏⻚，然后redo log按照时间或者空间等条件进⾏落盘，undo log和脏⻚按照checkpoint进⾏落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发⽣崩溃，则⾸先检查checkpoint记录，使⽤相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤undo log进⾏事务回滚。事务执⾏COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚继续按照checkpoint进⾏落盘。如果此时发生了崩溃，则只使⽤redo log恢复数据。\n11.mysql索引谈⼀谈 12.说说b+树的原理 a. B-tree：\nB-tree 利⽤了磁盘块的特性进⾏构建的树。每个磁盘块⼀个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级⽐原来的⼆叉树少了，减少数据查找的次数和复杂度。\nB-tree巧妙利⽤了磁盘预读原理，将⼀个节点的⼤⼩设为等于⼀个⻚（每⻚为4K），这样每个节点只需要⼀次I/O就可以完全载入。\nB-tree 的数据可以存在任何节点中。\n B+tree：  B+tree 是 B-tree 的变种，B+tree 数据只存储在叶⼦节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少\n所以查询数据更快，所有指关键字指针都存在叶⼦节点，所以每次查找的次数都相同所以查询速度更稳定;\n13. 让你设计⼀个索引，你会怎么设计 a. mysql默认存储引擎innodb只显式⽀持B树索引，对于频繁访问的表，innodb会透明建⽴⾃适应hash索引，即在B树索引基础上建⽴hash索引，可以显著提⾼查找效率，对于客户端是透明的，不可控制的，隐式的。\n14. 还问了git和svn的区别 1、Git是分布式的，⽽Svn不是；\n2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件\n3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；\n4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。\n5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹络问题\n时降低对版本库的破坏。)\n15. git命令的⼀些底层原理以及流程 https://www.jianshu.com/p/2b47a3078a46\na. git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库是这样的：\n1 2 3 4 5 6 7 8 9 10 11  - HEAD - branches - config - description - hook - objects - - info - - pack - refs - - heads - - tags    description⽤于GitWeb程序 config配置特定于该仓库的设置（还记得git config的三个配置级别么） hooks放置客户端或服务端的hook脚本 HEAD传说中的HEAD指针，指明当前处于哪个分⽀ objectsGit对象存储⽬录 refsGit引⽤存储⽬录 branches放置分⽀引⽤的⽬录 其中description、config和hooks这些不在讨论中，后⽂会直接忽略。  b. git add：Git commit之前先要通过git add添加⽂件：\n可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个\n4d96d5b00d98959ea9960f069585ce42b1349a⽂件。\n其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。\nc. git commit：\n","permalink":"https://coderrenxy.github.io/posts/read/14%E9%93%B6%E7%9B%9B%E6%94%AF%E4%BB%98/","summary":"银盛支付Java中级 1. 说说springcloud的⼯作原理 springcloud由以下⼏个核⼼组件构成： Eureka：各个服务启动时，Eur","title":""},{"content":"中软国际Java中级 1、java 中==和 equals 和 hashCode 的区别 1）==若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。对象是存放在堆中，栈中存放的对象的引用，所以==是对栈中的值进行比较，若返回 true 代表变量的内存地址相等；\n2）equals 是 Object 类中的方法，Object 类的 equals 方法用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。若是类中覆盖了 equals 方法，就要根据具体代码来确定，一般覆盖后都是通过对象的内容是否相等来判断对象是否相等。\n3）hashCode()计算出对象实例的哈希码，在对象进行散列时作为 key 存入。之所以有hashCode 方法，因为在批量的对象比较中，hashCode 比较要比 equals 快。在添加新元素时，先调用这个元素的 hashCode 方法，一下子能定位到它应该旋转的物理位置，若该位置没有元素，可直接存储；若该位置有元素，就调用它的 equals 方法与新元素进行比较，若相同则不存，不相同，就放到该位置的链表末端。\n4）equals 与 hashCode 方法关系：\nhashCode()是一个本地方法，实现是根据本地机器上关的。equals()相等的对象， hashCode()也一定相等；\nhashCode()不等，equals()一定也不等；\nhashCode()相等，equals() 可能相等，也可能不等。\n所 以 在 重 写 equals(Object obj) 方 法 ， 有 必 要 重 写 hashCode() 方 法 ， 确 保 通 过equals(Object obj)方法判断结果为 true 的两个对象具备相等的 hashCode()返回值。\n5）equals 与==的关系：\nInteger b1 = 127;在 java 编译时被编译成 Integer b1 = Integer.valueOf(127);对于-128到 127 之间的 Integer 值，用的是原生数据类型 int，会在内存里供重用，也就是这之间的Integer 值进行==比较时，只是进行 int 原生数据类型的数值进行比较。而超出-128〜127的范围，进行==比较时是进行地址及数值比较。\n2、int、char、long 各占多少字节数 int\\float 占用 4 个字节，short\\char 占用 2 个字节，\nlong 占用 8 个字节，byte/boolean 占用 1 个字节\n基本数据类型存放在栈里，包装类栈里存放的是对象的引用，即值的地址，而值存放在堆里。\n3、int 与 integer 的区别 Integer 是 int 的包装类，int 则是 java 的一种基本数据类型，Integer 变量必须实例化才能 使用，当 new 一个 Integer 时，实际是生成一个指向此对象的引用，而 int 是直接存储数据的值，\nInteger 默认值是 null，而 int 默认值是 0\n4、谈谈对 java 多态的理解 同一个消息可以根据发送对象的不同而采用多种不同的行为方式，在执行期间判断所引用的对象的实际类型，根据其实际的类型调用其相应的方法。\n作用：消除类型之间的耦合关系。实现多态的必要条件：继承、重写（因为必须调用父类中存在的方法）、父类引用指向子类对象\n5、String、StringBuffer、StringBuilder 区别 都是字符串类，String 类中使用字符数组保存字符串，因有 final 修饰符，String 对象是不可变的，每次对 String 操作都会生成新的 String 对象，这样效率低，且浪费内存空间。但线程安全。\nStringBuilder 和 StringBuffer 也是使用字符数组保存字符，但这两种对象都是可变的，即对字符串进行 append 操作，不会产生新的对象。它们的区别是：StringBuffer 对方法加了同步锁，是线程安全的，StringBuilder 非线程安全。\n6、什么是内部类？内部类的作用 内部类指在类的内部再定义另一个类。\n内部类的作用：\n1）实现多重继承，因为 java 中类的继承只能单继承，使用内部类可达到多重继承；\n2）内部类可以很好的实现隐藏，一般非内部类，不允许有 private 或 protected权限的，但内部类可以；\n3）减少了类文件编译后产生的字节码文件大小；内部类在编译完后也会产生.class 文件，但文件名称是：外部名称$内部类名称.class。\n分为以下几种：\n1）成员内部类，作为外部类的一个成员存在，与外部类的属性、方法并列，成员内部类持有外部类的引用，成员内部类不能定义 static 变量和方法。应用场合：每一个外部类都需要一个内部类实例，内部类离不开外部类存在。\n2）静态内部类，内部类以 static 声明，其他类可通过外部类.内部类来访问。特点：不会持有外部类的引用，可以访问外部类的静态变量，若要访问成员变量须通过外部类的实例访问。\n应用场合：内部类不需要外部类的实例，仅为外部类提供或逻辑上属于外部类，逻辑上可单独存在。设计的意义：加强了类的封装性（静态内部类是外部类的子行为或子属性，两者保持着一定关系），提高了代码的可读性（相关联的代码放在一起）。\n3）匿名内部类，在整个操作中只使用一次，没有名字，使用 new 创建，没有具体位置。\n4）局部内部类，在方法内或是代码块中定义类，\n7、抽象类和接口区别 抽象类在类前面须用 abstract 关键字修饰，一般至少包含一个抽象方法，抽象方法指只有声明，用关键字 abstract 修饰，没有具体的实现的方法。因抽象类中含有无具体实现的方法，固不能用抽象类创建对象。\n当然如果只是用 abstract 修饰类而无具体实现，也是抽象类。抽象类也可以有成员变量和普通的成员方法。抽象方法必须为 public 或 protected（若为 private，不能被子类继承，子类无法实现该方法）。\n若一个类继承一个抽象类，则必须实现父类中所有的抽象方法，若子类没有实现父类的抽象方法，则也应该定义为抽象类。\n接口用关键字 interface 修饰，接口也可以含有变量和方法，接口中的变量会被隐式指定为public static final 变量。方法会被隐式的指定为 public abstract，接口中的所有方法均不能有具体的实现，即接口中的方法都必须为抽象方法。若一个非抽象类实现某个接口，必须实现该接口中所有的方法。\n区别：\n1）抽象类可以提供成员方法实现的细节，而接口只能存在抽象方法；\n2）抽象类的成员变量可以是各种类型，而接口中成员变量只能是 public static final 类型；\n3）接口中不能含有静态方法及静态代码块，而抽象类可以有静态方法和静态代码块；\n4）一个类只能继承一个抽象类，用 extends 来继承，却可以实现多个接口，用 implements\n来实现接口。\n7.1、抽象类的意义 抽象类是用来提供子类的通用性，用来创建继承层级里子类的模板，减少代码编写，有利于\n代码规范化。\n7.2、抽象类与接口的应用场景 抽象类的应用场景：1）规范了一组公共的方法，与状态无关，可以共享的，无需子类分别\n实现；而另一些方法却需要各个子类根据自己特定状态来实现特定功能；\n2）定义一组接口，但不强迫每个实现类都必须实现所有的方法，可用抽象类定义一组方法\n体可以是空方法体，由子类选择自己感兴趣的方法来覆盖；\n7.3、抽象类是否可以没有方法和属性？ 可以\n7.4、接口的意义 1）有利于代码的规范，对于大型项目，对一些接口进行定义，可以给开发人员一个清晰的\n指示，防止开发人员随意命名和代码混乱，影响开发效率。\n2）有利于代码维护和扩展，当前类不能满足要求时，不需要重新设计类，只需要重新写了\n个类实现对应的方法。\n3）解耦作用，全局变量的定义，当发生需求变化时，只需改变接口中的值即可。\n4）直接看接口，就可以清楚知道具体实现类间的关系，代码交给别人看，别人也能立马明\n白。\n8、泛型中 extends 和 super 的区别 限定参数类型的上界，参数类型必须是 T 或 T 的子类型，但对于 List，不能通过 add()来加入元素，因为不知道是 T 的哪一种子类； 限定参数类型的下界，参数类型必须是 T 或 T 的父类型，不能能过 get()获取元素，因为不知道哪个超类； ## 9、父类的静态方法能否被子类重写？静态属性和静态方法是否可以被继承？ 父类的静态方法和属性不能被子类重写，但子类可以继承父类静态方法和属性，如父类和子类都有同名同参同返回值的静态方法 show()，声明的实例 Father father = new Son(); (Son extends Father)，会调用 father 对象的静态方法。静态是指在编译时就会分配内存且一直存在，跟对象实例无关。 ## 10、进程和线程的区别 进程：具有一定独立功能的程序，是系统进行资源分配和调度运行的基本单位。 线程：进程的一个实体，是 CPU 调度的苯单位，也是进程中执行运算的最小单位，即执行处理机调度的基本单位，如果把进程理解为逻辑上操作系统所完成的任务，线程则表示完成该任务的许多可能的子任务之一。 关系：一个进程可有多个线程，至少一个；一个线程只能属于一个进程。同一进程的所有线程共享该进程的所有资源。不同进程的线程间要利用消息通信方式实现同步。 区别：进程有独立的地址空间，而多个线程共享内存；进程具有一个独立功能的程序，线程不能独立运行，必须依存于应用程序中； ## 11、final，finally，finalize 的区别 final：变量、类、方法的修饰符，被 final 修饰的类不能被继承，变量或方法被 final 修饰则不能被修改和重写。 finally：异常处理时提供 finally 块来执行清除操作，不管有没有异常抛出，此处代码都会被执行。如果 try 语句块中包含 return 语句，finally 语句块是在 return 之后运行； finalize：Object 类中定义的方法，若子类覆盖了 finalize()方法，在在垃圾收集器将对象从内存中清除前，会执行该方法，确定对象是否会被回收。 ## 12、序列化 Serializable 和 Parcelable 的区别 **序列化**：将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输； **为什么要进行序列化**：开发过程中，我们需要将对象的引用传给其他 activity 或 fragment使用时，需要将这些对象放到一个 Intent 或 Bundle 中，再进行传递，而 Intent 或 Bundle只能识别基本数据类型和被序列化的类型。**Serializable**：表示将一个对象转换成可存储或可传输的状态。 **Parcelable**：与 Serializable 实现的效果相同，也是将一个对象转换成可传输的状态，但它的实现原理是将一个完整的对象进行分解，分解后的每一部分都是 Intent 所支持的数据类型，这样实现传递对象的功能。 **Parcelable 实现序列化的重要方法**：序列化功能是由 writeToParcel 完成，通过 Parcel 中的 write 方法来完成；反序列化由 CREATOR 完成，内部标明了如何创建序列化对象及数级， 通过 Parcel 的 read 方法完成；内容描述功能由 describeContents 方法完成，一般直接返回 0。 **区别**：Serializable 在序列化时会产生大量临时变量，引起频繁 GC。Serializable 本质上使用了反射，序列化过程慢。Parcelable 不能将数据存储在磁盘上，在外界变化时，它不能很好的保证数据的持续性。 **选择原则**：若仅在内存中使用，如 activity\\service 间传递对象，优先使用 Parcelable，它性能高。若是持久化操作，优先使用 Serializable **注意**：静态成员变量属于类，不属于对象，固不会参与序列化的过程；用 transient 关键字编辑的成员变量不会参与序列化过程；可以通过重写 writeObject()和 readObject()方法来重写系统默认的序列化和反序列化。\r## 13、谈谈对 kotlin 的理解 特点：\r1）代码量少且代码末尾没有分号；\r2）空类型安全（编译期处理了各种 null 情况，避免执行时异常）；\r3）函数式的，可使用 lambda 表达式；\r4）可扩展方法（可扩展任意类的的属性）；\r5）互操作性强，可以在一个项目中使用 kotlin 和 java 两种语言混合开发； ## 14、string 转换成 integer 的方式及原理 1）parseInt(String s)内部调用 parseInt(s, 10)默认为 10 进制 。 2）正常判断 null\\进制范围，length 等。 3）判断第一个字符是否是符号位。 4）循环遍历确定每个字符的十进制值。 5）通过*=和-=进行计算拼接。 6）判断是否为负值返回结果。","permalink":"https://coderrenxy.github.io/posts/read/15%E4%B8%AD%E8%BD%AF%E5%9B%BD%E9%99%85/","summary":"中软国际Java中级 1、java 中==和 equals 和 hashCode 的区别 1）==若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。","title":""},{"content":"北京(上) 大家好，我是大白，以程序员的视角看北京系列终于和大家见面了。因为北京适合程序员工作的企业实在太多了，所以怎样给大家介绍北京适合程序员的工作机会一直让我十分头疼。如果写的太简单，我跟大家说北京有百度、腾讯、阿里、美团等等，大家一定觉得我是在废话，但把所有企业一次性全介绍了工作量太大，并且文章也看不出重点了。所以我最终决定，北京拆成三篇来讲，一篇介绍北京的国企央企研究所、一篇介绍北京的大型互联网公司和大型外企、一篇介绍北京的中小型互联网公司。\n我发现在互联网公司工作的程序员都对国企央企以及研究所十分好奇，但是因为这些单位的信息比较封闭，所以大家对于这些企业的工作方式以及薪酬情况都都不清楚。为了能给北京系列开个好头，第一篇文章我就以我熟悉的北京的国企央企研究所来给大家介绍了。想提前声明一点，虽然我有很多同学和朋友在北京国企央企以及研究所，但是同一个公司，不同的部门或者不同的组差别都太大了。尤其是研究所，每个系列都有数量庞大的下属研究所，并且下属的研究所独立性都特别高，所以风格差别很大。我只能把我见到的情况给大家做一个介绍，具体去到哪个研究所哪个团队还得你们自己去详细打听。只能说我的介绍相对于更接近一些真实。如果大家发现哪里有误，欢迎大家指出。\n下面还是分开来介绍：\n国企\u0026amp;央企 在这篇文章中说的都是国企和央企的直属软件开发中心，子公司是不包含在里面的。子公司的工作风格差别很大。总体来说，国企和央企在软件技术上都是差互联网公司一大截的，待遇好不好真的看具体公司。是有些好的国企，我一个朋友在某国企虽然工资不太高，但是上了两年没加过班。也有一些国企，加班比拼多多都重，但是工资低且福利差。\n银行软件开发中心 最近几年计算机相关专业应届毕业生对于银行的软件开发中心热情越来越高，主要是由于银行的软件开发中心比较稳定，薪酬也还可以。目前应届生选择比较多的是工行、农行、中国银行、邮储银行的软件开发中心。大家比较感兴趣就分开详细介绍下吧。银行软件开发中心在校招时和互联网公司不太一样，hr 只会和你说一个大概的工资，hr 说的工资只能参考，工资还是以实际发放为准。如果想知道具体工资你得私下去问和你关系好的学长学姐，或者只能等工资发下来了才能知道。另外银行软件开发中心的稳定也只是说轻易不会开除你，但是忙不忙就要看你运气了。银行软件开发中心有的组忙起来完全不虚 PDD。\n工商银行软件开发中心 和同行相比，工商银行的软件开发中心算技术最好的了。工行喜欢招应届生，社招进来的比较少。刚进来的应届生职级是助理经理，税前年薪差不多是20万左右（到手15-16万吧，加上年终奖和节假日补贴）。工资发放方式稍微有点奇怪，就是每月发八九千，然后留一部分年底一并发放。每月会有饭补，过节也会有节假日补贴（放三天的节日假期给 1000，国庆给 2000，过年 4000）。这个职级的工资对于在北京工作来说还是有点难顶的，毕竟光跟人合租每月就要画掉两千多了。如果你是本科毕业进入工行，从助理经理升到经理一需要两年时间，硕士只需要一年，这个职级基本上全都能按时达到，不过工资变化不太大。从经理一升到经理二大约要一到两年的时间，这就看你能力了，经理二以后工资就相对多一些了，经理二绩效不太好的话每年到手能拿 22 万左右，如果绩效好，可能能拿到 29 万左右。经理二升经理三就完全看你自己能力了，到经理三以后每年到手都能 35 万左右，收入就很可观了。另外在工行发专利什么的也有些奖金，一个专利貌似是奖励 5000.\n工行的总行是在珠海。工行在西安、杭州等地也设立了研发中心，都是属于总行。目前北京这边也一直在动员员工去西安，薪资和北京差不太多。听说西安那边的工行加班比较严重。北京这边总体还好，卷不卷看你组长了，不过你也可以不甩你领导，他们是很难开掉你的，他们能的只是绩效给你打低点，你工资少点。\n农业银行软件开发中心 感觉农业银行的软件开发中心技术比工行差一点，不过工资比工行多一些，刚毕业的应届生税前能到税前25万-32万（这是hr说的啊，我了解到的西安每月税后到手是 1万2，加上年终奖税前能算 20 万的年包，北京比西安稍微多一点点，但是多不了太多）。农行软件开发中心有个大问题就是工资分配很平均，但是工作量分布不均，有的组十分养生，有的组忙的受不了（越接近客户用的产品线越累）。我的一个学长天天早早就下班了，另外一个同学周末跟我吃个饭都急匆匆的，为了投产要加班到凌晨。目前农行内部的怨气比较大，这点大家在脉脉上也能看出来。农行想要升职还要去考软考。\n中国银行软件开发中心 中国银行软件开发中心算是给钱最少的了，年包15万左右。这钱在北京确实太少了。不过工作是目前几个银行软开里最轻松的，家里不怎么缺钱，只想找个轻松稳定的可以选。\n邮政储蓄银行软件研发中心 第一年包含试用期，年薪税前总包 26w, 第二年年薪税前总包 31w。加不加班看你运气了，运气好被分到好的组不怎么加班，运气不好就很惨了。在北京工作的话不会被外调，但是在西安等地工作的许多人会被外调。\n券商 曾经农行软开的一位领导来我们学校校招宣讲时就说因为银行的工资有限制，涨薪比较慢。所以很多银行软开的职工干几年后就会跑到券商去挣钱。那时我才知道券商居然还招不少程序员。后来我发现中信建投证券是真不错，北京这边校招生进来月薪 18k ，年终奖 6 个月，虽然薪资还是不及互联网公司，但是涨薪速度相比于其它国企央企还是快很多的。另外只有股票开市的日子用上班，加班很少。不过对于学历的要求比较高，必须是985硕士，并且还卡本科。\n对于其它券商的情况我知道的就不多了，这里给大家提供一个找工作的思路，大家可以多去了解下。\n运营商 这里说的运营商说的是移动联通还有电信的研究院。移动的工资发放风格和工行有异曲同工之妙，每个月发的工资很少，到年终会一起再发一些。应届生年薪大概 20w 左右，平时工资发一半，年终把剩下的一半发给你。联通在北京的研究院有两个，一个叫联通研究院，一个叫联通软件研究院。我听说的是联通研究院比较好，联通软件研究院比较坑。 电信研究院的据说很轻松，但是工资低，没朋友在这里，我不太确定，只是听说。\n研究所 北京有着数量庞大的研究所，比如航天科技系列、航空工业系列、中船舶系列、中科院系列、中电科系列、军事科学院下属系列、工信部下属研究院、中国兵器等等。不得不说计算机相关专业真的是万金油，因为上述研究所，不管他们主营业务是啥，他们全都招计算机相关专业的毕业生，并且招的还不少。\n近几年想成为这些研究所的正式职工都需要是硕士以上了，签的本科生基本都是劳务派遣。户口的事放在生活里统一说。\n可能家里的长辈听到你去了研究所会觉得很有面子。但是单论软件技术来说，目前研究所是落后于互联网公司的，并且差距还不算小。研究所和互联网公司的办事风格不太一样，互联网公司会把岗位划分的很细致甚至有的互联网公司会无限的细分一个岗位（这点是我觉得不太好的地方，因为划分的太细了，以后跳槽会存在问题），但是研究所的岗位又划分的太粗糙了（从订需求、写开发文档、代码开发、测试、到和客户扯皮这些流程全的你来搞）。另外因为研究所的大部分领导软件方面技术没有互联网那么专，所以对工作量的评估不是太准，有时候安排起活来就比较离谱。是否来研究所要想想明白以下几个问题：（1）你家庭的经济情况，至少北京买房首付家里能掏出来。（2）你的兴趣（如果只想安安静静的写代码，研究所不太合适）。（3）面试通过后你要充分的了解你所在的团队情况，同一个研究所，不同的团队的差别那可大了去了。\n总体来说，个人感觉如果你在一个二线城市的研究所工作会比在一线城市研究所工作舒服。在一线城市去互联网公司干几年攒点钱撤一个二线城市压力没那么大。在北京的研究所工作北京户口是拿了，但是干几年根本攒不下多少钱，一线城市研究所分房这事就不用做梦了，充其量会给你提供一个宿舍，这种宿舍也就是毕业三到五年内可以住，以后就不能住了。相比于二线城市的研究所，一线城市研究所的工资每月多个两三千，但是房价是二线城市的三到五倍，生活幸福感会大打折扣。\n航天科技\u0026amp;航空工业 我有很多的校友都在航空航天系列的研究所。研究所的具体薪资都比较保密，大部分研究所在给你 offer 的时候不会像互联网公司那样把薪资给你说的清清楚楚并且写在合同上，而是大概和你说个数。而且你入职后两到三个月的薪资往往都很少，等三四个月以后薪资稳定了你才能确定你开多少钱。\n航空航天目前效益比较好，算是研究所中薪资比较高的。另外食堂和宿舍都有，如果没宿舍还会有租房补贴。但是挣钱和互联网公司肯定没法比。薪资的话刚毕业的学生每月到手大概是一万出头，工资加上各种补贴年薪差不多税前能到20多万。加班没有加班费，出差会有出差补贴，有的团队出差一天补300，有的团队出差一天补400。所以如果你一个月都驻在外面的话，一个月工资到手也两万多呢。但是一年有个一两月出差还行，有的项目组一年有三分之二时间在外面出差，你会怀疑人生的。其实刚毕业头两年航空航天的薪资和互联网公司差距不大，不过在两三年后薪资水平就会逐渐拉开，研究所薪资涨的都慢。\n另外航空航天的研究所是很忙的，所以别想着进来轻松。研究所的忙法和互联网公司不是一种忙法，有的人在工作强度大的互联网公司待过的可能觉得自己 996 和 007 都能抗，来个研究所还怕啥？我是想说你可能想的有点简单了，在研究所写代码只是工作的一小部分，让你烦心的事多着呢。只是说你如果不把领导打了的话，他不太容易把你开掉。另外研究所有个好处是比较支持在职读博，如果你的组不是太忙，提升下学历是个不错的选择。\n工信部下属研究院 工信部下属的研究院整体上都不错，就比如信通院（中国信息通信研究院），如果你对这个单位陌生的话你可以看看你的行程码下面服务提供商排在第一个的是谁。信通院是制定标准的单位，也是监理单位。在信通院的话代码就很少写了，更多就是写文档了，不过信通院这种地方的视野肯定高一些。薪资的话信通院每个职工薪资差别很大，刚进去工资很低，可能就四五千块钱，但是薪资每个月都会变化，然后稳定在一个数。薪资低的每月到手有一万出头，但我知道每月到手两三万甚至更多的也是有的（不是领导啊，只是职工）。\n中科院系列 中科院系列下计算机相关最强的三个所就是自动化所（搞 nlp 的应该都听过宗成庆老师）、软件所、计算所。另外还有信工所、电子所也还凑合。整体待遇上，中科院系列的待遇不如航空航天系列的。你可以把中科院系列的研究所完全的想象成一个大学（嗯，不用想象，确实是个大学，中国科学院大学嘛）。每个团队就是你们研究生的实验室。基本上就是一个大老板，带几个小老板，再带几个职工，另外再配几个中科院的学生。课题组想要挣钱也是需要大老板出去拉活，然后小老板带着学生去干活。工作方式和技术水平和你们研究生的实验室一模一样的，就是多了一些硕士博士职工罢了。\n中科院系列各个所和各个课题组的待遇以及工作方式差距特别大，工资有少量的比较高的（我说的比较高是能和互联网公司持平），大部分刚进来的硕士应届生工资差不多就是八九千，博士一万多点。有的所提供宿舍，有的所连宿舍都没。总体上来说想在中科院有好的发展，需要你是博士，然后多发论文。等你成为小老板后，且团队可以项目成果转化，或者孵化企业后你的待遇会有比较大的变化。\n中电科系列 中电科系列的待遇比航空航天系列稍差，比中科院系列稍强一些。我感觉中电科系列的加班强度比较高，认识的几个在中电科系列的经常 996 甚至 007，还经常出差。待遇的话基本工资也是每月1万出头，然后出差也是有出差补贴，每天300 或者400，具体要看团队。感觉工资主要是靠出差补贴堆起来的。大部分下属院所会提供职工宿舍，中电科系列下属研究所风格差别很大，好起来是真好，坑起来是真坑啊。\n中国兵器系列 中国兵器系列计算机相关专业招的不是太多，其实每年一共招的人也不多。我最初对中国兵器系列的研究所有了解是一个所来我们学校宣讲。感觉中国兵器在西安的几个所能算的上是西安研究所的天花板了吧，待遇还不错（和航天504所比我有点不太确定）但是在北京我就不太清楚了。\n军事科学院系列 军事科学院系列的研究所招的职位都是军队文职，也就是说都需要考试的。我上时，听过几家军事科学院下属单位来宣讲，只是有个粗略的了解。军队文职也是上班制的，上班时也是需要穿军装的，下班后的生活不干预。工资有个很详细的职称对应表，硕士进去我记得是一万出头。想有好的发展最好去抓总单位，因为上面提的很多研究所想要项目都得抓总单位批。不过抓总单位的科研岗都要博士了，硕士进去只能是支撑岗位。\n北京来我们学校宣讲的几家军科院下属研究所都是承诺户口以及包解决子女上学问题的。当时说的是博士进去副营级，会提供一个四十平左右的房子住。硕士就是普通两人一间的宿舍。\n生活方面 北京具体的房价、美食教育等情况我放到下一篇讲北京互联网公司的文章中好好去讲下。这篇文章只讲一个事，那就是北京户口。北京户口的主要用处就是子女教育问题，其它的一些好处就是有北京户口可以申请共有产权房还有摇车牌等。应届毕业生是最好搞定户口的时候了，如果你能进这篇文章中讲的这些单位，大概率你是有户口的。不过拿户口的同时都要签一个五年的服务期合同，违约金每个单位不一样， 20万-50万不等，逐年递减。对于应届生来说户口貌似吸引力没有特别的大，毕竟现在自己还顾不过来，也不知道自己子女在哪呢。但是对于已经有子女的人来说，我一提给北京户口的事他们眼睛就亮了。\n北京这些年对于户口有也逐渐放宽，一些互联网公司的特殊应届招聘计划也会给户口，另外今年双一流学科的硕士以上应届毕业生都给户口了。\n另外想要户口还可以走积分落户，不过想要靠积分落户解决北京户口，就需要你头上有犄角，身后有尾巴了。\n好啦，这篇文章就介绍这么多，期待下一篇北京有哪些大型互联网公司和外企吧！\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n ","permalink":"https://coderrenxy.github.io/posts/read/beijing-01/","summary":"北京(上) 大家好，我是大白，以程序员的视角看北京系列终于和大家见面了。因为北京适合程序员工作的企业实在太多了，所以怎样给大家介绍北京适合程序","title":""},{"content":"北京(下) 大家好呀，我是大白。第一篇“程序员在北京可以选择哪些国企、央企以及研究所”发出后被一些读者和号主夸奖了，十分开心。没看过的朋友也可以通过链接进去看看呀。今天我们就继续来看看北京有哪些大型的互联网公司。写完这篇再写下北京比较不错的中小型互联网公司，就可以收官了。\n北京的繁华程度自然不用我多说。特别是对于程序员来说，北京有数量庞大的互联网公司。所以许多计算机相关专业的学生刚毕业时都会想着来北京闯一闯，一方面多学点东西，另一方面多挣点钱。今天这篇文章我们会介绍一下互联网大厂和大型外企在北京这边的部门以及特点。再讲下大厂程序员在北京的生活。\n这里再说一句，虽然北京依然在资源和机会上是领先其它准一线和二线城市一大截的。但是由于现在杭州、苏州、成都、西安等等城市发展的都不错，像长沙、大连、天津、青岛等地也比较安逸。再加上由于现在网络越来越发达，不像前些年一样许多事情只能在北京、上海、广州这些地方才能体验到。所以大家根据自身情况选择合适自己的城市就好了，硬往北京卷也没必要。\n工作机会 互联网大厂 谈到互联网公司，免不了说薪资。很多应届生校招时由于没有工作经验，容易被哄。首先要知道，校招给你开出的薪资是可以 argue 的，也就是说可以和 hr 商量。然后我主要想说的是，要谈你去和 HR 谈 base（每月基础工资）, 可不敢去和 hr argue 每年多少薪哈。一个哥们给我讲了个真事，他们公司一个应届生嫌 25k x 15 少，HR 跟他说那给你 25k X 16 吧，然后那个应届生就开心的答应了。HR 给你承诺的每月 base 是没问题的，但是说每年发多少个月的月薪只是一个期望，最终给你发几个月的年终奖要根据你到年底的评分以及你所在团队年底的评分共同决定。\n下面我说的各个公司薪资时说的每年多少薪也是 HR 说的一个期望薪资呀！许多说发 4 个月年终奖的，实际上一半人拿不到。\n百度 坐标：西北旺\n2022校招薪资：开发岗白菜价 22k，sp 24k，ssp 26k 。算法岗白菜价 26k，sp 29k，ssp 32k。每年 16 薪。\n个人评价：曾经十分强大的百度这几年逐渐和腾讯阿里拉开了差距。不过就我个人而言还是比较喜欢百度的。首先百度是以技术为导向的，这一点作为程序员应该会有比较好的体验，另外百度总体来说加班不是特别严重。工作制差不多 975 或者是 985, 前两周我趁着去找在百度的同学玩的机会，周六下午三点左右在百度大楼里转了一圈，最起码周末是没几个工位上有人的。工位上有人的看样子也是趁周末想自己单独学习会。另外百度的办公环境还不错，食堂也很好。百度在北京的部门以及岗位都特别齐全，只是大量的开发岗位用 php 有点难顶。\n百度这两年集中发展人工智能，这一点在给校招开出的薪资上也能看得出来。不得不说这两年校招的薪资是真高呀，就不用说算法岗校招的薪资，开发岗校招的薪资都倒挂了不少老员工。百度在算法上投入的决心是挺大的，自己能搞出深度学习框架 PaddlePaddle 十分让我敬佩。读研时实验室显卡不够我还经常上百度的 AI Studio 平台上薅羊毛，有次顺手打了个比赛得了个名次，排名不高，但百度还真给我寄来几百块钱的购物券。只是最近百度无人车进展的不太顺利，感觉是百度人工只能发展的一大挫折了。\n腾讯 坐标：西北旺\n2022校招薪资：19-25k，每年 16 薪；每月 4k 租房补贴；6-10 w的签字费分两年发放。\n个人评价：北京这边腾讯和百度的办公楼离得很近，腾讯在北京这边的部门主要是 PCG 事业群（PCG 中都是腾讯和媒体宣传相关的部门，包含腾讯视频、腾讯新闻、腾讯QQ等，另外央视频也是包给北京这边的腾讯做的。话说PCG 在脉脉上被喷的很惨）。腾讯主要用的语言是 C++ 和 Go，我见过一个部门招 Java 的，不过一方面是招的人数太少，一方面在腾讯做 Java 总觉得有点怪怪的。介绍百度时说的百度是以技术为导向的是说给腾讯听的，因为腾讯是以产品为导向的。产品的话语权比程序员大。\n腾讯的福利是特别香的，食堂也很好。特别今年把租房补贴涨到了4k。那肯定有鹅选鹅呀。\n近期搜狗也并入腾讯了，并到了腾讯的 Pcg 事业群下，目前各方面已经和腾讯对齐了。我有个同学先在腾讯的 PCG 实习，然后校招最终选择了去搜狗，结果又被并回 PCG 了，也是特别的缘分。上面的图就是我在搜狗茶水间拍到的照片~可以看到已经都换成腾讯 logo 了。搜狗不在西北旺，搜狗在五道口附近呀。\n阿里巴巴 坐标：望京\n2022校招薪资：开发岗白菜价 21-24k，sp 25-28k，ssp 29-30k。算法岗白菜价 25k，sp 29-31k，ssp 33-36k。每年 16 薪，签字费 1-10w，还会额外发 6k 的搬家费。\n个人评价：北京的阿里巴巴大楼在望京。另外目前阿里巴巴的北京总部也在建设中，预计2023年投入使用。阿里巴巴近两年一直有负面消息，我个人而言也不太喜欢阿里的狼性文化。但是有一说一，阿里的技术在国内的互联网是数一数二的。从阿里出来的职工跳槽的认可度绝对是很高的。不过还是求求你们别卷啦！\n字节跳动 坐标：中航广场\n2022校招薪资：开发岗白菜价22-24k，sp 26-28k，ssp 30-33k。算法岗白菜价26-29k，sp 30-32k，ssp 35k。每年15薪，还有1w-12w的签字费，我看大部分是 1w！住在 30分钟内可以到达公司的地方额外会有 1500 的租房补贴。\n个人评价：目前字节慢慢的把 BAT 中的 B 换成了 ByteDance 的 B，字节目前技术的认可度是很高的。我的一位学长 18 年时纠结去京东还是去字节（18年时我听字节跳动这个名字还有些许陌生），最终去了字节。然后他现在的薪资已经让我十分惊叹了。字节跳动的福利待遇也特别好，最近因为业务影响裁应届生虽然是无奈之举，不过或多或少对公司有点影响。字节最近在西安设立了研发中心，另外听说在青岛开了一个元宇宙研发中心，工作地点在市北，校招招人，感兴趣的可以去看看。\n美团 坐标：望京\n2022校招薪资：开发岗白菜价21k，sp 24k，ssp 27-29k。算法岗白菜价 24k，sp 27k，ssp30-32k。每年15.5薪。其余的福利也就是每天 30 饭补和 9 点以后打车了。\n个人评价：美团的技术绝对没得说，特别是对于应届生有不错的培养，美团的学城上有很多质量很高的技术资料，许多从美团离职的员工都想念美团的学城。另外给的薪资从去年薪资大涨后也算不错了。虽然今年校招比去年没怎么涨，只是在 ssp 的薪资上做了一些调整，但是凭良心讲，一个应届生这个价确实不低了。不过美团的办公环境和福利就太差劲了，首先美团的办公大楼都是租的，工位也都很简陋，也没食堂。别的公司过节发礼品，好家伙，你团发个贺卡，要么发个微信的红包专属封皮\u0026hellip;\n京东 坐标：亦庄\n2022校招薪资: 开发岗白菜价 19.5-23k，sp 25-26.5k，ssp 29k。算法岗白菜价 27.5k，sp 31-33.5k，ssp 36.5k。每年 15 薪。\n个人评价：首先说坐标哦，京东在亦庄，租房会相对便宜一些，省到就是赚到。然后说薪资，京东有个不太好的地方就是薪资的 20% 是绩效，虽然绩效一般都能拿满，但是这部分绩效就不用交住房公积金了呀。京东周末很少加班，周内大部分 8 点左右下班的样子。\n网易 坐标:西北旺\n2022校招薪资:北京这边网易的薪资划分的不太明确，我看开发爆料出的月薪从 18.4k、22k、24k、25.5k的都有。算法爆出的月薪 25.5k，27.5k, 30k的都有。每年 15 薪。\n个人评价:北京这边基本上都是网易有道团队的，今年薪资给的不太行呀，不过我百度的朋友和我说他每次晚上看网易大楼的灯总是关的最早的（西北旺聚集的几家公司在楼上可以互相看到对方）\n大型外企 外企的 wlb（工作生活平衡）一直是大家十分喜欢的，不过近几年由于国内互联网大厂给的实在太多了。同样的水平国内互联网给的薪资大概会比外企多50%左右。另外一些同学也会担心在外企待几年后工作和技术适应不了国内的强度。所以许多 offer 收割机拿到许多大厂 offer 和大型外企 offer 后也会犹豫该去哪。\n许多人会问面外企是否需要用英文面试？我问了几位在外企的老哥，共同的说法是要看你面的组和职级。有的组是频繁和国外开会交流的，这自然需要你英语好，但是如果你面的组和国外开会少，那么就不需要你英语好。另外看你面的职级是否比较高，如果职级高，和国外交流的事自然少不了。但是如果你只是组长给你布置活你干的话，也不需要你英语好。\nHulu 坐标：望京\n2022校招薪资：Hulu 招人的量不大，所以爆料薪资的人不多。有限的几个爆料的年包都在 50w 以上。\n个人评价：可能做开发的同学没听说过这个公司，不过做算法的同学应该知道这家公司的很多，这家公司出了一本挺不错的书籍叫《百面机器学习》。有许多同学应该在准备算法面试时看过这本书。Hulu 是美国的一个比较热的视频网站。严格的来说 Hulu 应该算是一家小而美的公司，不能算大型企业。但是因为 Hulu 工资不错，技术很好，另外也不加班。所以 Hulu 的 offer 比许多大型企业的 offer 还有诱惑力。\n微软 坐标：离五道口也不远。\n个人评价：微软的薪资情况和面试考察重点等在介绍苏州时已经详细介绍过了，就不在重复介绍了，大家感兴趣的可以看这里。不过相比在微软苏州工作而言，在北京的房价和消费情况水平下，微软北京的薪资就不算太香了。什么？给我 offer 我去不去? 马上去！ 微软北京前些年的落户指标比较多，不过近几年微软的落户指标相对少一些了。\nShoppe（虾皮） 坐标：五道口附近，和搜狗挨着。那片有好多互联网公司。\n2022校招薪资：白菜价 22k，sp 25k，ssp 27k。有3万签字费，以及12万股票分三年发放。\n个人评价：你可以把虾皮想象成东南亚的淘宝。我还是比较喜欢虾皮的，薪资很高，技术也不错。但是网传的 965 是没几个组能达到的，虾皮说是外企其实和国内互联网公司风格差不太多。近几年虾皮也越来越卷了。虾皮周六应该是不用加班，前两周周六我和我同学去转了一圈，大门是锁着的。听说周内 7 点到 10 点下班的组都有。\nAmazon 坐标：朝阳区远洋国际中心\n2022校招薪资：亚马逊的基础年薪我看到有30w和34.9w 两个档，配给员工的股票也有 23w 和 27w 两个档（第一年发5%，第二年发15%，第三年和第四年都是发40%），签字费第一年会给9.5w的签字费，第二年还会给6.9w的签字费。\n个人评价：最近几年外企不如国内互联网大厂开出的薪资高，但是外企的养生一直是大家十分喜欢的。亚马逊在外企中算是比较抠的，不过因为近几年亚马逊股票涨的多，所以给了员工股票后员工还是大赚。另外有个缺点就是亚马逊在国内的业务相对比较边缘，但是亚马逊的光环很耀眼，员工出来还是很受欢迎的。\nApple 坐标：朝阳区建国门外大街国贸大厦\n个人评价：苹果的保密相当的严格，我也没有关系好的在苹果上班的朋友，所以我也没找到苹果今年校招的薪资是多少。苹果北京的业务比较边缘，岗位基本都是做功能本土化的工作。工作时间是去掉午休后满 8 小时就可以。\nAirbnb 坐标:朝阳区环球金融中心\n2022校招薪资：基础年薪35w，额外基础薪资 15% 的奖金，8w 美元股票分 4 年发放。\n个人评价：爱彼迎优势是 wlb（工作生活平衡），且薪资也很不错，这个股票太有诱惑力了。 当然缺点也是有的，这里引用脉脉上一个 Airbnb 职工的匿名评论“Airbnb单纯做项目基本学不到啥技术 、框架封装的太完善且都是业务。自学能力强的话可以来，如果想单纯靠做项目提升能力就需要慎重了”。我感觉这个挺适合我的哦~ 上班干活，六点下班再写写文章，完美。\n好了，详细介绍的就这么多了。另外谷歌由于在国内招的人十分的少，我也没有在谷歌上班的大神朋友，所以谷歌的信息我就不知道了。Paypal 我找到的信息也有点少，也不展开介绍了，貌似 PayPal 在上海部门比较齐全，北京这边工作地点我最初都没搜到，还是根据朋友圈一个朋友提醒在 boss 上找到的，在朝阳区金地中心。\n生活成本 在北京的生活就仁者见仁智者见智了，有的人喜欢他的繁华与机遇，有的人讨厌他的拥挤与压力。\n房价 买房的事往后稍稍，咱们先说租房的事。注意啊，我下面说的上班方便基本上就是出门后一个小时内到公司呀！来了北京后大概率事要和人合租了，像上面说的在腾讯百度等西二旗这片区域上班的，大多数选择在回龙观这块和人合租，相对便宜且有地铁站上班比较方便。在回龙观这块租一个 10 来平的卧室大约 2500 左右吧。 在五道口那片上班和望京那片上班的在附近租房要更贵点，租一个 10 来平的卧室大概每月要花 3000+。当然在望京上班可以沿着14号线租的远点，租金会便宜点，上班直接坐着地铁过来也还挺方便。在亦庄那边上班的租房会相对便宜点，2000多点基本可以。想要一个住且在上述公司上班方便，租一个30平左右的一居室基本最低每月都要 5000 以上了。\n另外大家还可以瞅着点公租房，租金会比较便宜，单租一间 40 平的房子也就不到 3000，只是限制会比较多。部分公司会有公租房名额，我记得度小满就能协助职工申请公租房。申请一居室的会容易点，两居室的难申请。\n下面就说买房的事了，算了，我对北京买房的事也没什么见解。贴个图你们自己看吧，数据不一定准，就感受下房价有多高吧\u0026hellip;.密云延庆什么的就太远了，当然有很多人在北京上班在天津买房或者廊坊买房的。\n美食 有一句话叫“京城无美食”。虽然这句话有点极端但是也有点道理的。美食的聚集地大部分是沿山沿海沿河沿江的地方，北京一直不是一个美食原料富足的地方。北京常说的北京名菜特点不像鲁菜川菜江苏菜那样特点鲜明。我能想到的北京特色的饭也就是烤鸭、涮羊肉、爆肚、炒肝、京酱肉丝、炸酱面，除了这些还真不太好想了。在北京有个好处是你能在这里吃到全国各地的美食，因为北京全国各地甚至世界各地的人都有，所以各省各国风味的餐厅都会有，但是感觉风味上还是根据北京这边的口味做了一些改变。\n抛开美食说一个现实的问题，就是吃饭的花销。你在学校时一顿饭也就是十块左右。来到北京后吃饭的花销基本上要比你学校的花销贵一倍左右（因为老板的房租也会摊到饭的价格中）。如果你公司有食堂还好，要是公司没食堂只能吃外卖的话，自己的腰包和胃都受不了。说到这我觉得我以后晚饭还是自己做吧。\n教育\u0026amp;医疗 北京的教育和医疗肯定全国顶级了。再往详细的介绍我觉得我写不出什么有深度的东西了，对于教育和医疗来说，我觉得我这个刚毕业不到一年的人肯定不如在北京待了多年的并且有孩子的了解的多。我只是知道虽然北京的高考会比其它省份容易很多，但北京一贯实行的素质教育对于孩子家长来说会很累，今天陪孩子学个交谊舞，明天学个马术，后天学校开个家长联谊会。对于 996 或者 995 的程序员家长来说真的有点难顶，不像我们上学时很少叫家长了。\n娱乐 北京值得去的玩的地方很多的，圆明园、颐和园、故宫、香山、各种胡同、各种博物馆、各种茶馆。听个相声、听个演唱会，看个体育比赛都是不错的休闲方式。去各种商场转一转买点东西也是休闲。当然因为北京这么大所以周末出来玩一趟会特别花时间。北京的国家级景区票价是比较便宜的，我记得颐和园门票也就四五十，不像其它地区的景区动辄好几百的门票。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/beijing-02/","summary":"北京(下) 大家好呀，我是大白。第一篇“程序员在北京可以选择哪些国企、央企以及研究所”发出后被一些读者和号主夸奖了，十分开心。没看过的朋友也可","title":""},{"content":"长沙 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越来越全面了，但相同公司不同部门不同组的情况也差别很大，这里只能介绍一个总体情况，如果大家有更多的信息，欢迎联系我补充呀。\n这篇文章我们来以程序员的视角带你看长沙，长沙的房价真的是太香了。如果工资还可以的话，以长沙这个房价在长沙生活，是真的幸福。下面我们还是分工作机会，生活环境两个角度进行介绍。\n首先我们来看工作机会！\n工作机会 总体来说，长沙的互联网环境还是太差了！不过，相比于几年前也是在慢慢改进中！近几年许多知名互联网企业纷纷落户长沙，比如深信服、华为。不过，这些公司在长沙的研发岗位一般都很少，相当于一个办事处的感觉。\n长沙本土互联网公司的话，首推芒果 TV 和兴盛优选。另外，长沙这边的互联网公司集中于岳麓区，在这里会有更多选择。\n腾讯云 腾讯云和腾讯的关系一直是很多人好奇的，许多人把腾讯云称作腾讯的内包。腾讯云目前在西安、重庆、长沙三个城市设点。应届生水平根据薪资爆料差不多是 14k * 16，据说今年4月底时腾讯云的公积金已经调至 12% 了，也还不错。腾讯云的职级和腾讯不是完全对齐的，这点要注意。社招的话可以看下在 boss 的薪资水平。\n中兴 中兴校招给的薪资全国基本都一样，除蓝剑计划给的很高外，大部分人月薪给的集中在 13k 和 15k，少部分有 17k。社招的话大家看下boss上的薪资水平。\n芒果 TV 芒果 TV 是国内 A 股首家国有控股的视频平台，成立于 2006 年，公司总部位于湖南省长沙市金鹰影视文化城湖南国际会展中心西附楼。\n芒果 TV 可以说是长沙最能打的几家互联网公司之一了（虽然也有一些不好的地方）。\n根据其官网招聘来看，前端开发、产品经理、架构师等岗位都在招人。\n关于薪资的话，看准网上的参考薪资还是挺高的！像 Java 达到了 20k+ ，Go 达到了 16k+。不过，我觉得实际情况应该要稍微低一些。\n据说芒果 TV 平时加班很少，各种福利待遇都还不错！\n芒果 TV 内部大部分人养老，比较轻松，少部分人比较累。\n浩鲸科技 浩鲸科技前身是中兴软创（中兴的子公司），后来被阿里收购，加入了阿里云的生态圈（浩鲸科技非外包，浩鲸智能是外包！）。\n公司的技术一般，和大厂还是有一些差距。不过，被阿里收购以后，引入了不少阿里的技术体系。所以，应该也还是能够学到一些东西（很有限，和项目也有很大关系）。\n薪资水平在行业内算中等水平吧，现在研发岗，本科应届生也能给到 9-12k 的样子。不过内部加薪比较慢，待个几年后就会感觉比外面低了。这也算是行业通病了，加薪靠跳槽。\n公司福利的话只能说一般，班车补贴、餐补、出差补贴、端午、中秋、生日礼物也都有。\n另外，近几年加班强度明显一年比一年强，不过属于那种一阵忙一阵闲的，加班强度最大的应该是交付岗。有的岗位出差比较多，像国际中心，调研和交付岗，每年最少有半年在出差。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 13k +）、Web 前端开发工程师（薪资大概在 12k +）。\n总的来说，在长沙工作的话，浩鲸科技还是值得推荐的（虽然也有一些不好的地方）。\n兴盛优选 社区电商独角兽，湖南省第一家估值超过 10 亿美金的“独角兽”企业。兴盛优选发展还可以，获得了腾讯、京东、红杉资本等十余家投资机构的投资。\n在兴盛优选官网可以找到技术岗位的招聘信息。从招聘信息可以看出，薪资相对来说还是很高的!\n天鹅到家 天鹅到家（原 58 到家）成立于 2014 年，是国内 Top 级别的家庭服务平台。\n相对来说，天鹅到家还是值得推荐的，不过，长沙这边招聘的技术岗位不多。\n校招的话，先去公司参加笔试，面试体验还可以，问的问题都是基础的问题，都是在学校里学的知识比如数据结构，数据库，算法、网络。社招的话，面试一般难很多，会问很多多线程、分布式、数据库方面的问题。\n关于薪资的话，智联招聘上的高级 Java 后端开发参考薪资在 15k 左右。\n拓维云创 拓维云创是一家主要做外包的公司，2008 年登陆深圳证券交易所成功上市。公司总部位于岳麓区桐梓坡西路 298 号拓维软件园，在北京、上海、深圳等地有子公司。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 10k +）、.Net 开发工程师（薪资大概在 10k +）、C++开发工程师（薪资大概在 15k +）。\n这家公司技术面试的一般没有笔试，难度也一般。\n华为 长沙这边有一个华为长沙研究所，地址也在长沙市岳麓区。\n如果想在长沙追求高薪的话，华为是很好的选择，按照华为的工资水平在长沙买房简直是轻轻松松！\n不过，据我了解，华为在长沙仅仅是一个办事处而已，研发岗位很少很少，毕竟已经有武汉研究所了。\n武汉离长沙也比较近，如果想去华为的话，还是建议选择武汉的华为研究所。\n华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。\n华为在长沙的社招我不是特别清楚，只是知道华为社招大部分给的是 OD ，社招想拿正式 offer 基本都需要 16 级以上的评级。\n在华为上班是压力比较大，也比较累的，这个就不多说了，大家应该都清楚。\n深信服 深信服在长沙也有分部，不过，研发岗位比较少。\n京北方 一家大型外包公司，总部位于北京，在广东、山东、江苏、长沙、程度等地有子公司。\n不过，据说北方有点坑，实际情况和招聘的时候说的那一套严重不符，工资也非常低。另外，还有网友爆料这家公司有随便开人的嫌疑，\n我一个哥们当时也去了这里面试，不过，据他所说：“体验极差，面试官看着非常油腻，格局不大！”（作为参考，不同的面试官带来的面试体验差别很大）。\n一般是先电话面试，然后现场面试，会问一些项目上的技术问题，不过，都比较简单。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 9k +）和软件测试工程师（薪资大概在 5k +）。\n另外，大型外包公司中软国际在长沙也有分公司。\n科大讯飞 科大讯飞在长沙岳麓区有一个小分部，不过，招聘的很多都不是技术岗位。\n中国长城科技 大型国企，相对来说还行。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 10k +）、后端架构师（薪资大概在 12k +）、全栈工程师（薪资大概在 12k +）。\n福利这块的话，公积金还是可以的。\n湖南竞网智赢 湖南竞网智赢网络技术有限公司主要提供的是互联网营销综合服务。公司总部设在长沙高新区麓谷企业广场，全省服务团队规模过 1000 人，服务企业 20000 家。\n面试体验的话还行，整体面试过程流畅，两轮的面试官整体素质都很高，HR 问得有点细，工作环境感觉还是不错的，就是大小周有点可惜。\n关于薪资的话，看准网上的后端开发参考薪资在 10k 左右。\n超维创想信息技术有限公司 这家公司的总部位于北京，网上的信息少之又少！\n根据智联招聘上的最新数据，目前，长沙的招聘岗位只有 Java 开发工程师，薪资大概在 7k+。\n东华软件 东华软件 2001 年 1 月成立，总部位于北京中关村，在长沙、武汉、上海等地有子公司，2006 年 8 月在深圳主板上市。\n这个公司规模还挺大的，不过，据说待遇很一般，工资比较低，平时也没什么福利。并且， 领导爱画饼，也学不到什么技术。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师、项目经理。\n关于薪资的话，看准网上的 Java 开发参考薪资是 12k 左右，不过，我觉得实际情况应该要稍微低一些。\n梦网云创科技有限公司 梦网云创科技有限公司是国内最大规模之一的企业云通信平台，总部位于深圳，在长沙、重庆等地有子公司。\n不过，研发岗位主要集中在深圳和长沙。\n根据智联招聘上的最新数据，目前，长沙的招聘岗位有 Java 开发工程师（薪资大概在 13k +）和软件测试工程师（薪资大概在 7k +）。\n薪资待遇相对来说，还是挺不错的！\n梦网云这家公司在网络上几乎没找到任何评价，所以，我这里也不多做评价。感兴趣的小伙伴，可以自己了解一下！\n其他 其他还有像 福米信息、万兴科技 、亚信 等公司，这里就不多介绍了。\n其实程序员在长沙，目光不要只着眼于互联网软件公司，长沙有许多军工芯片类型的公司待遇也很好。另外许多大型制造业公司，比如三一重工、中联重科、山河智能等公司也在招程序员，待遇也很好。\n生活环境\u0026amp;生活成本 房价 长沙的房价真的就太香太香太香了！！！作为一个省会城市，房价竟然还要比很多普通的地级市都要低。\n以下房价数据来源于安居客，可以作为参考。\n可以看到长沙新房的均价在 9500 附近。\n即使是互联网公司比较多的岳麓区，新房均在也才在 12000 附近。\n教育 先来看高中！\n长沙有四大，长郡/雅礼/师大附中/一中，每一个都是全国有名的重点高中。有多厉害？长沙市雅礼中学“一本录取率”：92.6%，长沙市长郡中学“一本录取率”：93.4% \u0026hellip;\u0026hellip;\n长沙人虽然也重视教育，但是学区房之类的价格还是比较友好的。\n再来看大学!\n长沙有 3 所 985 高校，分别是国防科大、中南大学、湖南大学。放眼全国，一所城市能够 3 所 985 的少之又少！\n其他的比较好的学校还有 湖南师范大学（211）、湖南农业大学（一本）、长沙理工大学（一本）、湖南科技大学（一本）\u0026hellip;\u0026hellip;。\n医疗 医疗资源在二线城市中算不错的。湘雅三个医院，省人民医院，省妇幼，都是还不错的医院。\n交通\u0026amp;气候\u0026amp;娱乐\u0026amp;美食 交通一般，这几年一直在修地铁（12 条线路），道路复杂。并且，长沙的司机素质普遍比较差，感觉每个人都很急，很赶时间。\n气候讲真不太友好，多雨，炎热，夏天的时候没有空调真活不下去。\n基本没有说错，这是个基本只有夏季和冬季，但是夏季冬季随机播放，没有空调基本没法生活的城市。\n娱乐和美食这个就不用多说了，毕竟长沙的娱乐业还是比较发达的，美食也有很多（很多外地人专门跑到长沙吃美食）。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/changsha/","summary":"长沙 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越","title":""},{"content":"成都 在一些读者的强烈要求后，我终于开始对成都下手了。成都近些年发展的速度极其的快，感觉西部地区的互联网环境能发展成这样实属不易。今天我们就以程序员的视角带你看成都。\n其实我读大学时没怎么接触过四川人，直到读研来了西安，感觉西安的四川人好多啊（西安到成都最快的一趟车3个小时17分钟）。身边接触的四川人逐渐多了起来，加上我的四川舍友（读研来报道时我的四川舍友看着暖气研究了很久），让我逐渐对四川有了一些了解。感觉四川人普遍是真爱吃火锅，真爱吃辣呀，另外我发现四川人普遍懂得享受生活~ 在开始介绍城市前先为成都定一个基调吧，那就是 享受生活。\n本篇文章还是从成都的工作机会、生活成本两个角度来介绍成都。\n工作机会 互联网公司 嗯\u0026hellip;刚把主题定成享受生活，不过调查了下发现，在成都的这几个互联网大厂还都挺卷的。不过成都这个消费水平，加上这几个大厂这么高的工资，扶我起来，我还能加班。为了描述方便，我把一些严格意义上不算互联网的也一起介绍了。\n腾讯 基本情况：腾讯在成都的部门算是挺多的了。天美（王者荣耀）、WXG（在成都主要是做企业微信的那部分）、PCG 。\n薪酬福利情况：腾讯在成都的薪资体系是和总部对齐的（参考去年校招，给的工资是17k，18.5k，20k，21.5k，23k五档)。不过给你工资的定档会稍微低一些。比如你的能力面腾讯总部是大Sp，去成都的腾讯可能给你定档就只能是小Sp了。另外有租房补贴有食堂，全额住房公积金。\n面试特点：校招笔试不是必须做。面试八股文+手撕代码。2-3轮技术面，1轮hr面。\n工作强度：听说成都这边的腾讯加班挺严重的。不过成都这样的房价，在腾讯这么好的部门、开这么多工资，还要啥自行车？\n阿里巴巴 基本情况：我去阿里巴巴招聘官网查了一下，阿里在成都的需求量很大。根据贴出的招聘信息感觉在成都需求最多的就是蚂蚁，其次本地生活和菜鸟的需求也不少。平头哥和阿里云也有招聘需求，但感觉不是很多。\n薪酬福利情况：阿里成都的薪资也是和总部对齐的，住房公积金全额12%。成都的阿里巴巴目前在蚂蚁C空间办公，没有食堂！不过楼下是银泰城商业街，吃的选择还比较丰富。中午和晚上吃饭各补贴 20 块钱，中午直接给现金，晚上是餐券。\n面试特点：笔试必须做，笔试题难度挺大。一道 Leetcode 中等难度和一道困难难度的题在一个小时内做完，基本上测试用例过30%能进面试。面试后手撕代码不多，不过对于原理性知识问的比较深入。\n**工作强度：**成都阿里工作强度大部分部门是 995。\n字节跳动 基本情况：看了下字节跳动在成都的岗位很多，前段、后端、客户端、SRE、算法都有。\n薪酬福利情况：成都的字节会在北京字节薪资的基础上打个九折，所以在校招薪水上看薪资爆料会看到很多带小数点的薪资报价，住房公积金全额12%。。比如 23.4k * 15，这个薪资相当于北京的 26k * 15。字节的食堂一直是让人很羡慕的，成都字节也直接包了三餐。省到就是赚到呀。\n面试特点：有的部门通过内推可以免笔试，有的部门笔试必须做。3轮技术面+一轮hr。面试比较注重手撕代码。\n工作强度：成都字节加班也不轻，基本上是早上十点上班，晚上十点下班。\n美团 基本情况：美团在成都主要是闪购、企业平台、餐饮生态、外卖。在成都这边的美团部门都比较边缘。\n薪酬福利情况：薪酬福利部门我开水团就和上面几家有差距了。成都的美团的薪资会在美团北京薪资的基础上打个八五折，住房公积金8%。。就比如去年北京美团 sp 是 24k，在成都就是 20.4k。公积金食堂不是自己的，是外包食堂。美团的办公环境也不太好。\n面试特点：笔试必须做。2-3轮技术面+一轮hr。面试比较注重手撕代码。\n**工作强度：**美团成都的工作强度相对来说没那么大，技术方面还是可以的。\n京东 基本情况：成都京东的业务布局还是很全面的，商城技术线、技术中台、商城客服线、数科客服线、物流都有。听说京东健康也打算过去。\n薪酬福利情况：京东的福利待遇一般，之前的一年14薪一直被诟病，不过今年成了16薪了。京东成都薪资基本上是在北京薪资的基础上打8.5折。另外京东的薪资构成里面会加绩效。住房公积金是交6%，这有点过分呀。京东在北京的食堂感觉不错，但是在成都的京东食堂我没找到相关信息，有了解的老哥跟我说下。\n面试特点：可以通过部门直推免笔试。2-3轮技术面+一轮hr。面试八股文问的多，手撕代码较少。面试难度总体上较为友好。\n工作强度：京东周末一般是不加班的，周内早上9点上班，晚上下班时间看部门，7点到10点下班的都有。\n华为 基本情况：华为在成都的部门挺齐全的。基本上每个产品线都有。\n薪酬福利情况：成都华为和西安华为的薪酬基本一致。校招生的话根据评级月薪 13k-19k 都有，如果干的好工资涨的还挺快。12%住房公积金。食堂也不错。\n面试特点：笔试必须做，三轮技术面。第一轮主要是笔试代码的复盘，第二轮面试八股文+写代码，第三轮总监面半问技术半聊理想。\n工作强度：华为的产品线都是很累的，不过加班费挺到位的。做技术预研的相对好点。\nOPPO 基本情况：成都 OPPO 的岗位挺全的，项目主要是平台技术中心、浏览器、手机软件、中间件等。\n薪酬福利情况：一个 OPPO，一个 VIVO，给钱贼大方。我 看OPPO 成都去年给应届生开的价总包基本都在30w以上了。也太有钱了。\n面试特点：感觉面试总体难度适中。2轮技术面+1轮hr面。技术面基本就是八股文面试+手撕代码。\n工作强度：OPPO 在成都各个部门的加班情况不太一样，大部分部门能双休，但也大部分部门晚上9点以前走不了。\n龙湖数科 基本情况：你们是不是觉得混入了一个奇怪的公司~ 我看到成都有，就给大家介绍下龙湖的数字科技部吧。龙湖数科成立时间不久，现在也在砸钱组建团队。我参加过龙湖仕官生的招聘（这个计划会把你当成核心来培养，龙湖有个好处是可以自己选择是否技术轮岗）。\n薪酬福利情况：龙湖为了组建团队现在也是下了血本，应届硕士校招都能开到四五十万的年包了，不过工资构成主要是通过年终奖把总包提起来的。相关福利也都不错，听入职的同学说好像他们上班有个什么积分（好像是叫龙积分），这个积分还能用来买东西。工作一定年限后买龙湖房子也能打折。\n面试特点：我感觉面试难度不大，校招时一面就简单问了问项目，然后提了两个比较基础的问题。二面稍微上了一些强度，就面完了。让我提问，我问了问他们在做什么，通过他们的讲述我感觉他们的技术和目前的互联网公司还是存在一定差距的。\n工作强度：因为组建不久，所以工作强度还没上来。\n建制齐全业务全面的大型互联网公司主要是上面这些了。还有一些互联网公司在成都也设立研发岗位，我快速给大家过一遍。\n滴滴：滴滴因为之前的事现在日子不太好过，在成都主要是橙心优选业务。\n爱奇艺：手游岗位和算法岗位在成都。\n**新浪：**主要事绿洲业务，岗位不多。\n**携程：**我去扒了下招聘网站，没看到现在招人。好像会不定期招人。\n**科大讯飞：**科大讯飞主要事围绕语音在做的，成都主要是智慧城市业务。\n中兴：在成都规模不大，中兴的薪资不算高，给应届毕业硕士月薪差不多是15 k。\n联想：在成都的岗位挺多的，Java、物联网、边缘计算等都有招人。\n国企研究所 中电29所、中电10所、中电30所 基本情况：成都的几个中电系列的研究所效益还算不错。其实在效益比较好的中电系列的研究所收入还可以，但是这伴随着你要经常的出差和加班。中电系列的研究所出差一天貌似是要给 280 左右的补助。很多中电系列研究所的职工一年有三分之一的时间在外面出差。工资加上出差补助每年挣得其实也不少了。但是天天在外面飘着得感觉可不好受。效益比较好的中电系列得研究所大部分是 996 起步。\n中航工业611所 基本情况：611所基本上是在成都的研究所的最好的选择了。我说明一下，航天工业是负责出地球的，也就是造火箭相关的。航空工业是造飞机相关的。航天工业和航空工业的效益普遍好一些，福利待遇也比较完善，但是这几年工作也挺累的。工资涨幅比较慢。\n核动力研究院 基本情况：工资不是很高，年薪大概15万左右（税前），工作比较稳定。\n总体上这几个研究所的性价比是 中航工业611所 \u0026gt;核动力研究院 = 中电系列研究所。研究所工作比较稳定，但工资涨的很慢，工作中扯皮的现象会比较多。喜欢哪种生活看个人了。\n农行软开 基本情况：我对农行软件开发中心的印象挺不错的。部分部门会加班比较严重（有个哥们在农行挺苦逼的），不过大部分部门还是比较轻松的。技术和互联网公司有一定差距，不过工作稳定。转正后每月月薪到手是一万二。在成都节奏慢点享受下生活不香吗？\n招银网络 基本情况：招银网络算是招银的子公司，为了归类较为统一我就把他放在这里了，但是招银网络不是国企啊。和招行信用卡中心不一样，招行信用卡中心是属于招行总行的。招银网络算是银行软件开发里最像互联网公司的，给的工资水平基本能和互联网公司持平。\n工行软开 基本情况：工行软开的技术在银行软开中还是不错的。不过工资给的不如农行多。西安和成都工行给的工资相对于北上广珠要少一点。成都的工行软开属于总行序列。本科生和硕士生进入工行后职级都是助理经理，年薪总包 20 万左右，本科生每月工资就比硕士生少几百块钱。工行软开每月发的工资会少一些，然后年终会一下发好几万的年终奖。本科生需要两年才能升经理一，硕士需要一年就可以升 经理一。升到 经理一 后表现好一年就可以升 经理二，不过从助理经理到经理二的薪资涨幅不大。从毕业到升职成为经理三（相当于组长）最快需要五年，经理三的年薪还是很可观的。\n除此之外邮储银行的软开、中信银行的软开以及浦发银行的软开也不错，注意，浦发银行的软件开发中心被子公司化了。另外成都各银行的省分行的科技岗位待遇也不错。\n生活成本 房价 让很多在一线工作多年的程序员把成都当作第一撤退选择的就是成都的房价。在有上述这么多互联网公司的城市里，成都的房价几乎是最低的了。在青羊、武侯、高新、锦江、天府新区等几个区买房会贵一点，均价都在两万以上了，其它几个区的房价都在每平一万多的水平。8月份成都二手房均价是一万四每平。下图来自安居客，大家可以参考下。如果在上面列出的公司工作的话，买房压力不会特别大，另外相对于去北上广深，刚毕业在成都租房会便宜很多，这样也能更多的把工资省下来。\n教育 感觉四川的高等教育方面不错，但小学、初中、高中教育资源并不是很好，高考难度不小。不过四川的优质教育资源基本都在成都了。大学方面，985有两所，四川大学和电子科技大学。211有3所，四川农业大学、西南交通大学和西南交通大学。另外成都理工大学、成都大学、成都信息工程大学等也不错。\n高中方面成都的七中林荫校区、树德宁夏校区、石室文庙校区、七中高新等等都很不错。成都有30所左右的高中，高考的一本率都能超过50%。\n美食\u0026amp;娱乐 成都的美食就很多了，美食之都不是白叫的。成都也是川菜的发源地。大家都知道四川人喜欢吃辣，不过四川的辣是香辣，还是很不错的。美食我就不一个个数了，数也数不过来呀。\n娱乐方面我是发现四川人是真的爱玩。成都的小酒馆和麻将馆都是四川人十分喜爱的。好多人中午吃完饭就急匆匆的往麻将馆跑，去迟了就打不上了。另外想去景区玩一玩的话成都的旅游景点也非常的多。\n交通 成都的交通方面也很棒，近年来大力发展轨道交通，截止今年6月，已经开通12条线路了，地铁运营里程排行全国第四。开车的话堵车是肯定会堵的，现在还没见过哪个二线以上城市不堵的，但是成都相对其它同级别城市会好不少。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/chengdu/","summary":"成都 在一些读者的强烈要求后，我终于开始对成都下手了。成都近些年发展的速度极其的快，感觉西部地区的互联网环境能发展成这样实属不易。今天我们就以","title":""},{"content":"大连 大家好呀，我是大白。今天我们来以程序员的视角看一下美丽的大连。话说我印象中大连是没有什么程序员的就业机会的。但是一直有读者想让我写，那我就安排一下。不过在调研大连的互联网环境时，还是发现几个让我惊喜的公司，还有号称山海关以北最强的开发团队。一起来看吧！\n由于大连这边互联网的关注度较低，所以我废了九牛二虎之力也就搜寻到有限的信息。不能像其它的城市那样薪资福利列的明明白白了，只能我搜集到啥就说啥了！\n工作机会 大连的互联网公司特别少，主要是外包公司，还有挺多做软件的外企，话说我在调查大连的互联网环境时看到大连有这么多外企还挺吃惊的。这是我第一次介绍程序员的就业机会先介绍外企，在大连的软件行业来说，这些外企确实比其它类型的公司值得加入。\n外企 LINE LINE 基本上是程序员回大连的第一选择了，可能很多人没听说过。LINE是做社交聊天工具的，在日本和韩国特别火，你可以把它想象成日本和韩国的微信。LINE的技术是很强的，号称山海关以北最强开发团队，面试的技术要求挺高，社招比较喜欢从 BAT 回大连的程序员。工作时间是 965，有的部门会加班。\n给的薪资福利在大连是数一数二的，网上没找到 LINE 的具体薪资爆料。问了一下了解的人，薪资大概和北京三线互联网公司开的薪资持平（在大连住开这个工资很带劲呀），加班有加班费。招聘的岗位比较少，就招 JAVA 和安卓。\nSAP 程序员在大连工作的话 SAP 也是一个好去处。SAP是一家德企，是全球最大的企业管理和协同化商务解决方案供应商。SAP 的技术挺不错的。待遇方面是基本工资＋10%左右的年终奖金。主要节日奖金888，有加班的话，双倍三倍全额付。t3以上买车有补贴。买公司股票有优惠。每年base也有稳定增长。\n思科 曾经的思科十分强大，但是近些年慢慢的不太行了。大连的思科主要是劳务派遣，跟大连软件园签合同。有机会转成正式职工，要看业绩。如果在思科做正式职工还是挺爽的，不加班，工资水平在大连也排在前列了。\nIBM IBM 大连还不错，但也没想象的那么好。IBM的办公楼在黄泥川，比较偏远。大连的IBM主要是对日本的业务。薪资方面前些年IBM还是很有优势的，不过近些年也只能算中等了。\nIBM的优势在于学习资源比较多，工作轻松且稳定，有着很不错的企业文化。\n花旗金融 花旗银行的岗位主要在上海，大连比较少。大连的工资基本上是上海的八五折，有个应届硕士校招薪资爆料是 15.8k * 12。这薪资在大连还是不错的。工作比较轻松，一般下午 6:30 都能下班。花旗的技术还是不错的。\n埃森哲 埃森哲虽然是外企不过也是外包。在网上说埃森哲好的和不好的都有。我调查了一下发现，进入埃森哲后，进入不同项目组后的工作体验差距十分的大。有的项目很好，也不忙，但是有的项目组进去以后加班十分严重。然后就是埃森哲工资水平比较低。校招薪水上有爆料，2021 年毕业的 211 硕士，月薪 7.4k * 13，这也太少了吧。\n大连的外企是真不少，我就不一一详细介绍了，我把他们列在下面，大家感兴趣的话去了解下。\nAVAYA、infosys、思佰益、富达、简伯特、甲骨文（逐渐放弃中国市场了）、HP、纬创、罗克韦尔\n互联网 腾讯大连无线研发中心 腾讯大连无线研发中心实际上是由两个大连公司合并而成，一个叫世纪鲲鹏，一个叫世纪成讯，腾讯100%控股。注意，腾讯大连无线研发中心算是腾讯的一个全资子公司，和腾讯的北京和深圳这些研发中心的性质不一样，所以薪资和福利不是对齐的。大连这边是属于腾讯 MIG 事业群的，工作地点在大连甘井子区，招聘岗位基本都是后端和游戏岗位。校招薪资多多少少有点辛酸，看一个硕士的校招薪资爆料，一个月税前一万，每年 1-2 月的年终奖。看 boss 上的社招薪资资还凑合，看下图。\n西山居 西山居是我比较喜欢的一个团队。大家可能对于这个名字有点陌生，西山居其实是金山的游戏团队，技术还挺强的，剑网 3 就是西山居的产品。西山居的部门主要是在北京和珠海，大连招聘的量比较少，在大连能去西山居工作的话还挺舒服的。薪资我没打听到准确的，有三年左右经验的月薪也就是税前13-15k左右吧。\n话说大连的互联网公司是真的约等于没有。能拿的出手的也就上面两个了，另外还行的就是大商天狗和长城汽车了，大商天狗是做电商的，不过产品使用人群仅局限于大连，流量很小。大商天狗招的岗位很多，看boss上放出的职位目标薪资在大连也还算过的去吧，岗位也比较丰富。长城汽车成立了一个数字化中心在大连也设有岗位，但是招的人也很少。\n外包 接下来就是大连的主要 IT 力量了，那就是外包！大连的外包公司是真多。最近我的一个朋友去了外包，也让我对外包有了更多的了解，话说我才发现外包公司给的工资比一些中小型的互联网公司还高。我朋友之前没有编程经验，经过培训去了西安的一家外包公司给华为做外包，和华为的上下班时间是一致的，周一周二周四加班到晚上 9 点，周三周五 6 点下班，周末加班的话三倍工资。福利基本就是逢年过节发点月饼和油之类的，年终奖几乎没有。每个月的工资和加班费加起来每月到手将近 1 万（他是跨行过来的，西安能给这么多我还是比较吃惊）。\n我个人认为去外包的发展是不如去有自己产品的公司的，不过对于一些计算机编程基础较差暂时进不到好的公司的同学来说，也是一个锻炼自己的地方。下面我就详细介绍一下东软吧，其它的大家感兴趣自己去了解。\n东软 东软在国内的外包里算是不错的。虽然是外包，不过接的项目还不错，都是比较大型的项目，主要接政府的外包。也做医疗方面的产品卖给医院。入职后也是和大的互联网公司一样有导师制的，东软一些员工的实力还不错，新人进去后对于个人能力的提升挺有帮助的。作息就看部门了，有的部门比较清闲，但是有的部门忙起来也是挺可怕的。东软的工作环境还是不错的，园区修的很漂亮。东软的工资和福利待遇方面就不太行了。\n大连这边的东软招聘的岗位很多，招聘数量也挺大的，放一张 boss 上招聘的截图，大家可以参考下呀。\n外包我也就不一一介绍了，我把有的外包列在下面，大家感兴趣的话自行去了解呀。\n中科创达、中软、华信、亿达信息、文思海辉、软通动力、华宇、心医国际\n生活成本 房价 大连的房价其实挺高的，在上述这种工资水平下，二手房挂牌价还将近每平1万6呢。不过有个好消息是最近大连的房价一直在跌，许多炒房的被套了，哈哈哈。要是再降一降，去个 Line 或者 SAP 以及腾讯大连的子公司工作，那美滋滋呀。\n教育 教育方面大连还是不错的。高校方面有一所 985（大连理工大学），一所 211（大连海事大学）。其它的大连交通大学，东北财经大学，大连大学，大连海洋大学等等也都不错。\n大连市共有75所高中，其中省级示范高中25所。大连24中，大连育明高中，大连八中，大连一中，大连二中，大连八中，大连十一中都非常的不错\n美食\u0026amp;交通\u0026amp;风景 首先因为大连是滨海城市，所以在大连的美食是海鲜为主的。话说在滨海城市吃海鲜，口感会比内陆好很多，内陆的海鲜大部分经过长时间的冷冻，吃起来口感会差很多。\n交通方面大连还是挺堵的，记得大连经常被百度地图列在十大堵城里。而且大连的地铁线路就三条就太少了。\n大连的美景绝对是让人留恋的，看看海还真的是让人心情舒畅啊。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/dalian/","summary":"大连 大家好呀，我是大白。今天我们来以程序员的视角看一下美丽的大连。话说我印象中大连是没有什么程序员的就业机会的。但是一直有读者想让我写，那我","title":""},{"content":"广州 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我把我最近收集到的信息以及读者的补充添加到了文章中。\n广州的互联网环境相对来说还不错。\n广州的繁华以及它的魅力不用我多说，无论从人文还是从经济来说都是不虚其它城市的。不过我在面试时发现，广州除了几个头部大厂是统一薪资标准外，相较于其它一线城市，广州的互联网行业给我的感觉是整体薪资水平偏低。\n大家注意呀，其实学计算机相关专业的想在广州挣钱，不止可以通过互联网公司，也可以通过当公务员，教师等方式去挣钱呀。应届生考进体制内当公务员，年薪也20多万呢，并且各方面福利待遇绝对到位，相当不错了。下面我们还是分互联网公司以及国企央企研究所介绍吧。\n声明一下，下面的内容仅代表我个人的调查结果，如果大家知道更多的信息，欢迎补充呀。\n工作机会 互联网公司 网易\n网易在广州主要是游戏部门。算是网易的核心业务了。注意，网易面试时候是散装的，网易互娱、网易雷火和网易互联网是分开招聘的，我当时投简历都是分开给他们投的，同样的简历我在网站上填了三次，累死。不过好处就是你有三次机会能进网易 ~ 注意，互娱、雷火、互联网的薪资方案也是不一样的。网易的薪资方案很复杂，这里面水太深，我感觉我有点把握不住~ 我知道有人拿到sp大概就是 25k * 16吧，还会有股票。网易食堂的伙食是真的好，大部分人去了工作一段时间都胖了。\n微信\n广州主要是腾讯的 wxg 事业群，也就是微信。wxg 事业群的效益非常好，能进 wxg 还是很棒的，不过面试难度也挺大的。腾讯去年校招的薪资分 17k，18.5k，20k，21.5k，23k 几个档次，hr说是应届生第一年保证18薪，不过第二年就不保证了哈。注意，腾讯开出的薪资是可以argue的，如果他给你的薪资不满意，你可以用其它offer跟腾讯的 hr argue 更高档次的薪资，有成功的。另外校招生还有签字费以及股票以及租房补贴。腾讯时不时送点小礼物，工作的舒适度还是不错的。\n字节跳动\n广州的字节整体上不如其它地方的字节加班严重，不过也要看部门，有的部门听说挺累的。字节之前一直是大小周，前不久刚刚宣布要取消大小周，有双休还是挺幸福的，就是要少挣不少钱了，看你是不是奋斗逼了。我看到21届字节校招的薪资主要是每月20k，22k，24k，26k，28k，30k不等。不过我看校招拿到广州这边offer的大部分是22k和24k的月薪，\n欢聚时代\n大家看到欢聚时代这个名称可能有点陌生，其实 YY 和 虎牙 都是欢聚时代的。欢聚时代的薪资水平我不清楚，我问了朋友也不清楚，我就去查校招薪水上的薪资爆料。有点迷呀，去年校招，开发方向的月薪14k、16k、18k 的都有，但是这算法薪资的爆料咋还直接就 27k 呢？这也差的太多了吧。有靠谱消息的老铁欢迎来补充。\n唯品会\n唯品会算是广州本地的一霸了吧，唯品会的福利挺给力的，包三餐，双休，租房补贴。本科生开发的月薪主要集中在14k-16k。\nSHEIN\n这家公司我熟，我就给你们展开讲讲。这家公司最近势头很猛，做跨境电商的，主要卖女装。我在去年秋招初期还面试过这家公司，面试难度比较友好。首先是 hr 给我发了个笔试链接，让我几天内找个时间做了。通过笔试后，第一轮面试，面试了大概有 30 多分钟，主要问了项目以及面试八股文，没有让写代码，然后面试就通过了。第二轮面试，面试官随便问了两个八股文问题就开始聊理想了。第三轮面试好像是他们的 cto，问我高考数学考多少分 ~ 问我上学期间大概写了多少行代码~ 然后又聊了几句就跟我结束面试了。就给我 offer了。后续hr跟我谈薪的时候说他们加班少，工资是 16k * 14，我觉得工资有点少，就没接offer。\n三七互娱\n我了解到三七互娱后端岗位大部分是 PHP，本科生校招进来薪资大概是12k 左右吧，每年发 15个月的工资。在知乎上对三七互娱的讨论比较多，有黑点，每个部门的情况也不太一样，大家可以再去了解下呀。\n小鹏汽车\n小鹏汽车最近风头正盛，应届生校招进来的工资基本在 16k 左右，每年15薪。小鹏汽车目前是大小周呀，工作强度还是比较大的。\n酷狗音乐\n酷狗音乐是腾讯的这应该大家都知道，不过内部的薪资职级不是完全对齐的哈。酷狗的不同部门工作强度差别很大，有的闲的要死，有的忙的要死。选择部门时要注意。\n4399\n4399大家应该都不陌生，好多小游戏都是从小开始玩的，工资也在16k左右。\n好了，我算看明白了。广州互联网这边除了几个头部大厂，做开发的应届生薪资差不多就是16k呀，感觉有点低。其它的在广州设点的互联网公司我直接列到下面啦，实在写不过来了，大家有兴趣的详细了解呀。\n分别有：科大讯飞、TCL、小鹏汽车、荔枝FM、多益游戏、太平洋、UC、CVTE、小米（目前正在建设中）、华为（正在建设中）\n运营商 感觉待遇一般，就是比较轻松，追求轻松和稳定的可以看下。\n移动\n移动每月的工资很低，可能到手就五六千块钱，然后年底会一下再发五六万的年终奖，有时候会更多一些。据说 18 年效益好年底一下发了 8 万，19 年就拉跨了。\n联通\n转正后每月到手八九千，绩效好能到手一万左右。\n电信\n我看到 offershow 上有做网络运维的爆料，入职第一年每月到手8.5k，年终发了3.5万。\n研究所 工信部第五研究所（赛宝实验室）\n据我所知，工信部下属的研究所福利待遇各方面都是不错的、平台也很大。但是每个部门的情况也差距很大呀，去研究所一定要找到那种效益好的部门，选对了起飞，选不对就坑了。\n中电7所（广州通信研究所）\n我打听了一下，这个研究所工资待遇不高，也就是图个轻松了。\n我找了下没找到航空航天类在广州的研究所。其它类型的研究所也会招计算机相关专业的，目前计算机专业是万金油，哪里也招，不过你进了重点不是放在计算机行业的研究所，技术上的发展肯定不太好。如果有比较好的研究所也欢迎补充呀。\n生活成本 房价 大家直接看图，相比于其它一线城市房价算是便宜了。但是按照广州互联网的工资水平想在广州差不多的区域和地段买房，压力是很大的。\n教育 广州的985大学有两所，分别是中山大学和华南理工，211也有两所是暨南大学以及华南师范大学，另外广州大学、广东工业大学等等也都不错。广州的高中也很给力，华南师范大学附属中学、广东实验中学、广东广雅中学、广州市执信中学、广州二中、六中等等学校都很不错。\n医疗 一线城市的医疗资源肯定是没问题的，我粗略数了一下，广州有不下40所三甲医院。我了解到顶级医疗资源主要有中山系、南方系、广中医系等等。\n风景\u0026amp;美食 广州的美景自然不用多说，另外空气质量也很好，说起空气质量，我这个北方人已经习惯冬天经常见不到太阳了。广州的美食也很多，白切鸡、煲仔饭和肠粉等等，还有很多我就不报菜名了，我在西安上学时食堂有个卖肠粉的窗口，我很爱吃，不过这个肠粉明显是本地化了。话说南北差异还是挺大的，我一个同学去广州上学，去洗澡带着搓澡巾，他的广州舍友都十分的好奇~ 当然广州的同学看我拍雪景也很好奇 ~ 还有一次实验室和厦门大学一起合作做项目，我和一个厦门大学的博士都要了一份豆腐脑，我加韭菜花，他加糖，我两面对面坐着都觉得对方的不能吃。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/guangzhou/","summary":"广州 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我","title":""},{"content":"杭州 一二线大厂 字节跳动  基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。今年 6 月，抖音电商落户杭州。 业务方向 ：抖音电商、抖音餐饮、字节跳动广告业务、字节跳动本地生活 工作地点 ：余杭区中国杭州 5G 创新园 5 层、余杭区杭州巨量引擎网络技术有限公司 1401 福利情况：六险一金(12%)、包三餐、免费下午茶+零食、免费健身房、Top 薪酬、住房补贴 招聘情况：主要招聘后端（Java、Go）、前端、测试等岗位。 面试 ： 面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。  阿里系  基本情况 ：阿里系占据了杭州互联网的一片天，相关联的企业是在是太多了。 业务方向 ：达摩院、淘宝、菜鸟、钉钉、飞猪、盒马、支付宝、夸克、UC、书旗小说\u0026hellip;\u0026hellip; 工作地点 ：西湖区、滨江区、余杭区\u0026hellip;\u0026hellip; 福利情况：7 险一金（全额住房公积金）、节日礼物、带薪假期、集体婚礼。 招聘情况：主要招聘 Java 后端开发、数据研发、数据分析、算法工程师等岗位。 面试 ： 不论是校招还是社招，技术面试问的都比较深入，通常会针对一个技术问题深入挖下去。 补充 ：加班的问题比较严重，受不了 996 的小伙伴慎重考虑。  京东  基本情况 ： 京东在杭州也有招聘，不过，招聘的岗位比较少。 业务方向 ：京东金融、京东云 工作地点 ：杭州拱墅区中国智慧信息产业园 M 座 12 楼 福利情况：五险一金、年度体检、住房补助、餐补、带薪假期 招聘情况：主要招聘 Java、产品经理等岗位 面试 ： 京东的技术面试采用常规面试，并且问的相对简单一些，而且可以部门直招，不需要笔试。技术面试有时候是两轮，有时候是三轮。在京东如果两轮面试以后你直接遇到了 HR 对你面试，你一般就是普通 offer 了。第三轮的主管面会决定是否给你 sp。但是！据我所知，京东 HR 面挂掉的人还挺多的，所以京东的技术面走完以后还不太稳。HR 面完你以后，如果隔一段时间问了你身份证号，并核对你毕业时间后，这就很稳了。我是 HR 面完的当天下午，HR 找我核对的。  网易  基本情况 ：网易在杭州有一个研究院，成立于 2006 年 6 月。 业务方向 ：⽹易杭州研究院，简称“杭研”。杭研是⽹易内部的基础技术研发中⼼和前沿技术研究中⼼，在云计算、⼤数据、安全、⼈⼯智能等⽅⾯进⾏前沿技术研究、关键技术攻关和基础技术平台研发，服务⽹易系游戏、邮箱、⾳乐、电商、新闻、在线教育等产品，触达近 10 亿⽤户。 工作地点 ：杭州滨江区网易大厦二期网商路 399 号 福利情况：运动设施、生日礼物、免费班车、五险一金、补充医疗险、重疾险、意外险、定期寿险 招聘情况：主要招聘 Java 、前端、区块链等岗位。 面试 ： 技术面试通常由 2 轮，最后 1 轮一般是 hr 面。注重项目和基本功 , 既要有广度还要有深度。  华为  基本情况 ：华为在杭州有一个研究所。 业务方向 ：智能摄像机、云服务 工作地点 ：杭州滨江区华为技术有限公司杭州研究所 福利情况：员工股权激励、薪资非常有竞争力。华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。 招聘情况：主要招聘软件开发（Java、C++）、嵌入式开发、测试等岗位。另外，华为社招一般都是 OD 模式。 面试 ： 面试的话，难度一般，主要看学历。 补充 : 华为加班比较多，压力可能会比较大。不过，薪资收入在全国绝对是 Top 级别。  其他 除了上面介绍到的这些一二线大厂之外，杭州还有下面这些不错的公司：\n 旷视科技 : 人工智能产品和解决方案，Face++云平台就是他们家的产品。 商汤 : Ai 领域独角兽，业务涵盖智慧商业、智慧城市、智慧生活、智能汽车四大板块。 \u0026hellip;\u0026hellip;  国企 中移杭研  基本情况 ：中国移动的一个全资子公司，2014 年在杭州成立。 业务方向 ：统一认证、融合通信、魔固云 工作地点 ：杭州余杭区中国移动(杭州研发中心)余杭塘路 1600 号 福利情况：五险两金（企业年金）、补充医疗保险、意外保险、带薪假期 招聘情况：主要招聘前端、后端、安卓、算法等岗位。 面试 ： 面试的话，难度一般，主要看学历。  之江实验室  基本情况 ：之江实验室是浙江省委、省政府贯彻落实科技创新思想，深入实施创新驱动发展战略的重大科技创新平台。 业务方向 ：智能感知、智能计算、智能网络、智能系统 工作地点 ：杭州市余杭区文一西路 1818 号中国人工智能小镇 10 号楼 福利情况：五险一金、Top 薪资、住房保障、优惠税收、带薪假期、餐补 招聘情况：主要招聘软件开发、芯片设计、DevOps 、测试等岗位 面试 ： 对学历要求特别高！  金融相关 同花顺  基本情况 ： 同花顺成立于 2001 年,总部位于杭州未来科技城，是国内第一家互联网金融信息服务业上市公司。同花顺作为一家互联网金融信息提供商，致力于为各类机构提供软件产品和系统维护服务、金融数据服务和智能推广服务，为个人投资者提供金融资讯和投资理财分析工具。 业务方向 ：旗下有多款热门投资理财类 APP。 工作地点 ：杭州余杭区同花顺新大楼总部同顺街 18 号 福利情况：薪资中等偏上，其他福利情况未知 招聘情况：主要招聘 Java、C++、前端、机器学习、产品经理等岗位 面试 ： 技术面试难度一般，而且通常就只有一轮技术面试。这是一位去面试同花顺后端开发的朋友给我反馈的面经：“面试官非常和善。上来就让你做个自我介绍，回答哪里毕业，毕业之后在哪工作，熟悉的技术栈。然后问了为什么离职之类的。之后开始问之前做的项目，重点问你做了哪些有亮点的项目，随便答了个高并发下保证原子性的项目，然后和面试官一起讨论会不会有更好的解决办法。”  51 信用卡  基本情况 ： 51 信用卡（母公司为杭州恩牛网络技术有限公司），公司创立于 2012 年，是一家服务于中国亿万信用卡用户的互联网金融公司。 业务方向 ：旗下有“51 信用卡管家”、“51 人品”、“51 人品贷”等 APP 工作地点 ：杭州西湖区中节能·西溪首座 B3、杭州西湖区西溪谷 G 座 福利情况：六险一金、生日礼物、节日贺礼、生育关怀、精彩团建、年度体检、年度旅游 招聘情况：主要招聘 Java、前端、安全、数据仓库等岗位 面试 ： 面试难度一般。技术面试一般会有 2 面，最后一面是 HR 面。  本土互联网公司 蘑菇街  基本情况 ：2011 年，蘑菇街正式上线，2016 年 1 月与美丽说战略融合，公司旗下包括：蘑菇街、美丽说、uni 等产品与服务。 业务方向 ：电商 工作地点 ：杭州西湖区黄龙万科中心 G 座 福利情况：无限的零食饮料供应、健身房、咖啡厅、 招聘情况：主要招聘 Java 后端、前端、移动开发等岗位。 面试 ：面试难度中等。技术面试一般会有 2 面，最后一面是 HR 面。 补充 : 据说公司的工作体验还不错！  有赞  基本情况 ：有赞，原名口袋通，2012 年 11 月 27 日在杭州贝塔咖啡馆孵化成立，是一家主要从事零售科技 SaaS 服务的企业，帮助商家进行网上开店、社交营销、提高留存复购，拓展全渠道新零售业务。2014 年 11 月 27 日，口袋通正式更名为有赞。2018 年 4 月 18 日，有赞完成在港上市。2019 年 4 月，腾讯领投有赞 10 亿港元融资。 业务方向 ：SaaS 服务（帮助商家网上开店、社交营销\u0026hellip;\u0026hellip;）、PaaS 云服务。 工作地点 ：杭州西湖区杭州有赞科技有限公司西溪路 698 号、杭州西湖区黄龙万科中心 G 座 福利情况：全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘后端、前端、移动开发等岗位。 面试 ：面试难度中等偏上。一般由 3 轮面试，前 2 面是技术面，最后 1 面是 HR 面。这是我的一位去面试有赞 Java 后端开发的朋友给我反馈的面经：“确定通过。面试官 nice，看中专业技能，1 小时以上。1 面问基础，很细很广，能问的基本都问了个遍。Java 基础、多线程、JVM、RPC、限流算法、降级算法、分布式事务中间件、Redis、分布式锁\u0026hellip;\u0026hellip;面了 70 多分钟，面的头晕眼花，还好大多都答出来了。直接约第二天 2 面 2 面，面试我的是未来的 leader,跟 1 面相比差不太多，有些偏重解决问题思路。3 面 leader 很年轻也很有个人魅力，交流了下个人情况也提了很多建议，离开的时候还送我下电梯送出大门面试体验很棒，公司环境也不错。” 补充 : 公司技术不错！主要招聘 Java 开发，做 Java 的可以优先考虑这家。  外企 Zoom  基本情况 ：Zoom 是一位美国华人企业家创办的公司，主营业务就是提供视频会议服务。总部位于硅谷，国内的话，杭州、苏州、合肥均有研发中心。 业务方向 ：视频会议 工作地点 ：杭州滨江区海康威视东流路 700 号 福利情况：全额五险一金、商业保险、餐补、年度旅游 招聘情况：主要招聘算法、测试、Web 前端、全栈、C/C++（后端开发这块 C++招聘偏多一些）、Java、Go。 面试 ：难度一般，外企一般比较重视计算机基础知识。 补充 : Zoom 的工作环境、企业文化什么的好评度在国内外都挺高的。不过，据说也存在部分项目组加班的情况。965 不加班，work life balance。技术氛围好，相处简单。  Cisco(思科)  基本情况 ：思科系统公司（Cisco Systems, Inc.），简称思科公司或思科，1984 年 12 月正式成立，是互联网解决方案的领先提供者，其设备和软件产品主要用于连接计算机网络系统，总部位于美国加利福尼亚州圣何塞。 业务方向 ：路由器、交换机等网络基础设施 工作地点 ：杭州上城区中豪·望江国际 4 幢 20 层 福利情况：全额五险一金、商业保险、餐补、年度旅游 招聘情况：主要招聘 Java、前端等岗位 面试 ：难度中等偏上，外企一般比较重视计算机基础知识。  其他 除了上面介绍的这几个外企之外，杭州的外企还有 ArcSoft(虹软) 、MicroStrategy (微策略) 、RingCentral、State Street (道福) 、Tata (塔塔) \u0026hellip;\u0026hellip;\n生活环境\u0026amp;生活成本 我们再来看看生活环境和生活成本。\n房价 杭州的房价不忍直视啊！！！涨的实在是太厉害了！个人感觉泡沫很大。\n以下房价数据来源于安居客，可以作为参考。\n教育 杭州只有一所 985，也就是浙江大学。除了浙江大学之外，浙江省就没有 211 工程院校了。不过，杭州电子科技大学虽然不是 211，但是实力很强，外界也很认可。\n交通 杭州的交通情况一般，经常听杭州的朋友吐槽杭州的交通很智障。\n根据杭州地铁官网上的数据，杭州目前一共有 10 条线路。\n从杭州这边去其他城市也都比较方便，大部分地方都有高铁或者飞机直达。\n美食 杭州饮食的包容性比较强，你想吃的在这边基本都能找到，种类非常多。\n各种火锅烤肉、川菜粤菜什么的随处可见。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/hangzhou/","summary":"杭州 一二线大厂 字节跳动 基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。今年 6 月，抖音电商落户杭州。 业务方向 ：抖音电商","title":""},{"content":"南京 大家好呀，我是大白。被读者催了好久，我终于开始调研南京的互联网公司了。南京是很有吸引力的一座城市，我在西安读研时听我导师和其它老师闲聊，就说很多我们学院看上的老师，最后都被南京的学校抢走了。最近我也发现许多安徽人都选择去南京工作生活。有句话说的很对，”安徽不能没有南京，就像东北不能没有三亚“。不过我调研中也发现，对于程序员来说，想要在南京留下也不是件很容易的事情，因为南京程序员的工作机会只能算一般，薪资水平这两年许多大公司选择在南京设立分部后才带起来一些，但是南京的房价已经很高了。\n提一下哈，在这个系列里说的校招薪资都是常规招聘计划的薪资，说的常规招聘计划给出的 offer 包含普通 offer，sp (special offer) 和 ssp。不包含那些比如华为天才少年、美团北斗之类的。那种神仙 offer 怎么样我这种凡人还真不了解。这些招聘的薪资也都是针对本科生和研究生的。如果你是博士，薪资方面和公司都好商量。\n南京的信息感觉相对较少，调研过程中几次自闭。所以校招薪资大家就当个参考，不是特别的准确，不过公司整体的基调应该都反映出来了。\n私企 阿里巴巴 校招薪资：招的人不多，具体薪资情况不太清楚。据说和总部薪资水平差不多。阿里的薪资水平可以参考下链接。\n个人评价：阿里巴巴在南京招人的部门主要是 CCO，阿里云也会有一些名额。岗位是挺齐全的，前端、后端、测试、算法都有。今年的校招 CCO 也就招了 20 个左右。\n字节跳动 校招薪资：字节在南京的薪资是字节在北京上海深圳薪资的 0.9。感觉薪资水平挺不错了。今年字节校招薪资也可以点这个链接查看。\n个人评价：南京这边字节的部门还是挺多的，游戏中台、客户端、数据平台、广告算法这些团队都在招人。团队也不能算边缘，在南京字节工作的话还是挺不错的。\n荣耀 校招薪资：月薪 17k - 27k（对应13-15级），每年 14-16 薪。\n个人评价：对于不太关注新闻的学生荣耀可能不太熟悉，今天展开介绍一下，你会发现接下来连着几家都是卖手机做通讯的。华为之前有荣耀手机的业务线，荣耀手机一直走价格较低的大众化路线，后来因为美国制裁，所以荣耀被拆了出来。目前荣耀大部分人员都是华为过来的，最近也在大量招人。所以荣耀目前可以看作一个翻版华为，各方面都是在学华为，但是后期能不能学的像就另说了。\n荣耀和华为校招面试时方法一样，根据你面试的表现给你定级，然后通过所定的级别来和你谈薪。大部分本科生是13级，面试表现很好的话可能会定到 14 级。研究生大部分是 14级，一些面试表现一般的可能也会定到13级。15级基本上需要读书期间发过有含金量的论文或者参与过重大开源项目。南京荣耀工作制度基本上就是 996。\n华为 校招薪资：13级月薪 20-21k，14 级 23-25k，15级月薪 26-27k。每年 14-16 薪。16级我就不清楚了。\n个人评价：感觉华为今年校招薪资水平提升了不少，我校招那年抠的要死，14a 才能给到 19k。要是今年这薪资水平我很可能就留到西安华为了，也就不北漂了。不过华为只给 5% 的公积金是有点低。感觉华为想要评到15级以上是需要你在读书期间有一些能证明你能力的东西，比如比较有含金量的论文，或者参与过重大的项目。如果手里没含金量的东西，靠面试表现来说最多也就是给到14级了。（反正我面试那年是这样）。华为对于部分特别牛逼的硕士会给到 16级。南京华为在几个研发中心算是加班比较少的，只是相对啊.\n小米 校招薪资：小米的薪资是挺抠，不过放在南京来看也还行。看校招薪水上南京的薪资爆料今年有 11k，14k，16k，18k，19k，21k，23k 几个档。11k，14k基本都是本科生，硕士做开发岗的大部分是16k，18k，19k这几个档。20k 以上的基本都是做算法的。\n个人评价：南京的小米算是一个比较大的研发中心，有些小米比较核心的部门。南京小米大部分组周末双休是能保证的，周内上班到几点各组情况不一致，总体上就是 995 这么个情况。\nVivo 校招薪资：南京这边目前看到给应届生的价钱分为月薪17k，20k，24k三个档，，每年15薪。额外每个月有 1500 的租房补贴。住房公积金5%。\n个人评价：之前 Vivo 是有大小周的（就是隔一周一次单休），去年九月份统一成双休了，工作制度差不多 995 或者 9105 的样子。周内就没时间干别的事了，不过 Vivo 这个薪资在南京确实算是还不错了。\nOPPO 校招薪资：具体薪资不太清楚，大致应届生月薪在 20k 上下，每年 14 -15 个月薪资。\n个人评价：OPPO 的薪资没调查清楚，信息比较少，不过应该和 VIVO 差不多。蓝绿两厂都是从步步高拆分出来的，两兄弟从薪资上以及工作模式上都很像。OPPO 和 VIVO 在南京都算是不错的选择。\n中兴 校招薪资：中兴常规计划（指的是普通 offer)的月薪基本都在20k 以内，蓝剑计划年薪会在 40w 以上。\n个人评价：中兴这两年的竞争力一直处在一个下滑的状态，感觉蓝剑计划还不错，但是名额很少，一个部门只有一两个名额。当时中兴蓝剑计划来我们学校宣讲过，我和一个部门的 leader 下来聊了下，看了我的情况以后说常规批次的最高的 offer 给我没问题，但是蓝剑他们目前备选的两个人手上都有含金量很高的论文和项目，我和人家差距很明显。中兴常规招聘计划的 offer 和大部分大公司就没法比了。\n360 校招薪资：没调查清楚，年薪差不多 23w 左右。\n个人评价：南京360有建邺区和九龙湖两个办公区，九龙湖的业务比较核心。360 目前工作生活比较平衡，在介绍北京时详细介绍过 360，大家可以点这里进去看下，来北京 360 我还是比较推荐的。南京 360 主要做 toB 业务，目前南京 360 的状况不太好，还传出过南京业务团队会被撤掉的传言（这只是传言啊，真实性不是很高，但是也反映出 360 南京业务情况不太好）想要去的话大家自己一定要问清楚。\n深信服 校招薪资：开发岗有3个档，月薪分布在15.6 - 22.8k 这个区间，算法岗也是三个档，月薪分布在19 - 25.2k 这个区间。每年13 - 15 薪\n个人评价：深信服总体来说加班挺严重的，不过南京的深信服相对深圳稍微好一点。比较好的就是深信服技术还不错，另外付出和收入成正比，其实大部分人不是吃不了苦，而是工作时付出和收入不成正比。\n趋势科技 校招薪资：看到校招薪资爆料有三个档，分别是年薪 20w，23.5w 和 25w。\n个人评价：趋势科技是一家外企，在南京很多年了，在安全方面做的不错。可以看出来，趋势科技的工资不算高（这个薪资在前两年还可以，但在今年各大厂校招薪资大涨的情况下就不太够看了），工资低伴随着公司很多技术大神流失。并且公司在20年底有次大的人员架构调整，也走了很多人。目前公司只是胜在工作轻松加班少了。\n亚信安全 校招薪资：基本上月薪在15-18.5k 这个区间，每年 13- 15薪。\n个人评价：亚信安全主要做运营商的项目。亚信科技知乎上被喷的还挺多的，不过亚信安全目前风评还可以，加班少些。\nSHEIN 校招薪资：目前看校招薪资爆料月薪基本集中在16-23k，有个说自己 27k 的不知道真的假的（如果是真的，感觉 SHEIN 大部分老员工要RUN了）。每年14薪。\n个人评价：SHEIN 我曾经还拿过这家公司的 offer。公司做跨境电商的，主要卖女装。面试相对容易一些，基本就是问些常问的八股文，都没让我手撕代码。SHEIN 技术还行，一些拿不到大厂 offer 的同学，先去这里也还不错。另外就是我听说南京的 SHEIN 越来越卷了，不是曾经的 965 了。\n满帮集团 校招薪资：校招薪水上的爆料开发月薪基本都在 20-30k 这个区间，算法基本都在 27-36k 这个区间。大部分人每年 14 薪。\n个人评价：满帮就是南京的本土企业，主要是做货运业务的。南京这边能给出上面的薪资，确实难得，不过从给这么多钱就能看出来，加班肯定少不了。满帮目前招人挺多的。\n国企 中电系列 南京有中电 28 所、中电 14 所、中电 841 所。有一些读者跟我说想去研究所，想法是去研究所可以工作生活平衡。但是现在有很多的研究所其实很忙的，工作生活平衡的研究所尤其不包括南京这几个。841 所还不是特别清楚。大部分互联网公司和中电 28 所以及 14 所 比起来还真是弟弟，不过根据南京的薪资的水平来说，这两个所得福利待遇算是顶级了。刚毕业的应届生进去工资大概每月到手是一万出头吧，有食堂有宿舍，出差会有出差补贴，差不多一天三四百，这几个所出差会非常的多。\n南瑞集团（国网电科院） 南瑞集团是国家电网直属的科研企业单位，主要做电力系统自动化相关设备，所以会招很多程序员。年薪 14 万左右。南瑞要给各个省公司做电力软件，所以出差的情况会非常多。面试上南瑞以后你还没有国家电网编制，想要编制还要去参加电网的考试。感觉性价比一般，不如去省公司，听说省公司工资还挺高的。\n运营商 几个运营商里只有联通在南京有研究院专门做软件相关，除此之外想去运营商就只有省公司了。一些运营商的子公司我就不多介绍了，我是感觉国企的子公司性价比一般，既没有国企的稳定也没互联网的高薪。\n烽火 简单说下烽火，下面有烽火星空还有烽火通信。是国企，不过感觉一直处于一个乙方的位置。项目很多是涉密项目，但是我劝大家尽量少碰涉密类型的项目。如果手头没大公司可以去烽火锻炼下，如果有其它大公司的 offer，我感觉还是优先其它大公司了。\n生活 房价 房价这里想多说一点，有些还没毕业的同学问我应该怎么选择幸福感高的城市。其实我的感觉是你在一座城市的幸福感很大程度取决于你工资和房价的比值，其它因素都是次要的。平均下来你每月的工资接近你所在城市还可以的区域的房价，那么你生活的就很舒服。就比如你工资每月到手一万二三，你所在城市房价也一万二三或者稍多点，那你买房压力并不大。但是如果你所在城市房价很高，就比如北京。你每月到手两三万的工资已经很厉害了，然而像昌平差不多的地段房价都四万以上了，那你买房压力肯定很大，换而言之你生活的幸福感肯定不高。天天租房还和人合租，能有啥生活幸福感？当然对于那些想待几年学点东西就撤的同学另当别论哈，我说的是定居的考虑。\n南京的房价还是比较高的，比较好的区域的房价直逼一线城市了，对于刚毕业的学生来说压力很大了，感觉这个房价应该逼走不少人。 另外南京物价也不低噢。下面这张图是网上找的，不一定准，可以当作参考。\n教育 南京高校资源方面很强。南京大学、东南大学、南航、河海大学、南理工等等都是很不错的学校。另外南邮、南京工业大学这些双非学校的计算机也很强。感觉近几年各个大厂陆续在南京设分布也是看中了南京有大量的计算机相关专业的毕业生。 江苏高考题的难是出了名的，当然江苏省的中小学教育资源也很优质，所以在教育这方面选择南京还是不错的。\n交通\u0026amp;风景\u0026amp;气候\u0026amp;美食 南京拥堵程度是上过全国前十榜单的，我租房是喜欢宁愿住的小一点差一点也尽可能离上班地方近一点，我比较抗拒通勤。宏观上来说，南京的地理位置特别好，离苏州、杭州、上海都很近，另外离安徽也很近，这也是安徽人喜欢往南京跑的原因。\n南京的风景不用多说，六朝古都的文化底蕴加上江南细腻的风景足够让人流连忘返，周末出去转一转还是挺令人放松的。\n南京气候感觉不怎么好，很潮，另外南京到夏天总会下很大的雨，我同学本科在南京上的，校园经常就被淹了。\n南京菜是挺有名的，南京菜比较杂，融合了很多地方的风味。大家应该都能找到适合自己口味的菜。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/nanjing/","summary":"南京 大家好呀，我是大白。被读者催了好久，我终于开始调研南京的互联网公司了。南京是很有吸引力的一座城市，我在西安读研时听我导师和其它老师闲聊，","title":""},{"content":"青岛 最近我发现青岛的呼声很高，所以我就先把青岛安排了。我和青岛的缘分来自于我的山东舍友、同学以及师兄。在三年的研究生生活中，以及我山东舍友带我们宿舍去青岛的毕业旅行，让我深刻的体会到了山东文化。我身边的山东同学一直给我一种努力并且踏实的感觉，还很热心。另外我发现山东人大部分都能哈酒，特别讲究酒文化，那个山东舍友带我们宿舍去青岛还有日照哈了一周的酒，最后真顶不住了。\n山东这边有个说法是不孝有三，没有编制为大。最初我还不理解，不过去山东转了一圈以后发现，如果是在青岛生活的话，还是去有编制的好。因为好私企真的有限呀。下面我就把招程序员的公司来捋一遍吧。\n工作机会 青岛软件行业的发展太滞后了，没有大规模的软件公司，做软件的公司大部分都是外包公司，而且规模还很小。\n海尔 海尔在青岛多年了，曾经有段辉煌期的。我舍友带着我在山东哈酒时，一个老大哥在酒桌上就跟我们聊起来，说他当初在海尔买家都是要请他们吃饭才卖给产品的。不过近些年海尔就不太行了，但依然在青岛是个工作上的好选择。海尔 Java 岗位给应届 985 硕士的报价是年薪 14 万。本科生相对少一点，年薪大概在 8万 到 12万 左右。我路过海尔时感觉海尔的园区还修的挺漂亮的。另外说一句，感觉海尔卡奥斯还行，在工业互联网领域做的还可以。\n海信 我之前总觉得海信和海尔有某种联系，不过我查了下并没有，路过海信的园区时觉得海信也修的挺漂亮的。一个 211 硕士爆料的薪资是每月 10k，然后一年 13 个月工资。福利待遇方面感觉还可以，前两年有免费宿舍，交通补贴每月 200，住房补贴 800 每月，可以领三年。试用期 6 个月，试用期间 90% 薪资，免费班车，公积金 10%，社保全额。工作早9晚6，中午休息一小时。\n另外就是如果还是喜欢互联网氛围的话去海信聚好看比较好，就是海信电视上那个 APP ，听说技术还不错，给的工资也相对较高。不过加班多啊。\n光大银行青岛研发中心 待遇听说还不错，以前是归分行管，现在归总行管。青岛这边主要开发云缴费业务。据说是有末尾淘汰机制。近几年好多员工都跑到青岛银行了。\n青岛银行 青岛银行总行的技术岗。薪资不算高，有薪资爆料是年薪12w，不过算是摸鱼的天堂了，活大部分是外包干。\n青岛凯亚 在青岛软件企业能算中上游了，不过全靠同行衬托。加上各种补贴，一年的工资差不多是是十二三万吧。试用期工资打五六折。技术还可以，不过有人爆料说他加班还挺多的。\n青岛鼎信 主要做通信的公司，一个应届硕士的爆料是税前13k，每年13个月的工资，有食堂，每个月600的饭补。\nYeelight Yeelight 算是在青岛为数不多的小而美的公司了，目前团队330人，研发人员超过一半，主要做智能照明，有小米的投资。听说团队氛围还不错，比较重视技术。我在网上没找到校招待遇的介绍，社招的话 BOSS 招聘 3-5年 Java 经验的报价是 12k-24k。\n中车四方 中车四方是国有控股公司，薪资待遇在青岛算中上。也招程序员。应届毕业生是6个月试用期，转正以后每年工资税前差不多15w左右。不过他这个工资构成和别人不一样呀。每月税前一万左右的工资好像其中六千左右是绩效，然后每年年中会发一个业绩奖金，不同部门的奖金差别很大。\n中电41所 说实话，我一直对中电系列的研究所印象不是很好，不过听说中电28所的薪资后对中电系列的印象有所改观（这里是闲扯一句哈，中电28所在南京，和青岛没啥关系）。注意41所得总部是在安徽，青岛只是一个分部，我了解到是加班会比较严重。\n好嘛，好不容易凑出来这几个程序员的工作机会，大家要是还知道一些比较好的工作机会，欢迎来补充呀。\n生活 房价 青岛房均价两万多了吧。崂山和市南比较贵，其它地相对好一些。下面这张图有各区的房价，不是太准，不过可以参考下呀。感觉程序员在北京干几年，攒个首付，然后回青岛找个相对稳定的公司上班，买房压力还不是很大（除了买崂山和市南啊）。\n教育 感觉青岛的教育方面很不错。\n大学方面，山东大学在青岛是有校区的，虽然离市区是真的远，但是人家有地铁呀。我记得坐那趟地铁去山东大学青岛校区找我舍友时穿越崂山，窗外的风景是真的漂亮。中国海洋大学也是一所985，校区是真的漂亮。中国石油大学是一所211，也挺不错的。另外像青岛大学、青岛理工大学、山东科技大学这些院校也是不错的。这几年各个高校也在青岛修建了研究院，感觉还是挺有发展前景的。\n高中方面，青岛二中、青岛一中、青岛五十八中、青岛九中、即墨一中等都非常好。不过山东高考的压力是真的大，感觉我大学和读研时身边的山东同学，当年高考都是英雄般的人物。\n风景\u0026amp;美食 青岛是真的挺美的，感觉在青岛既能感觉到现代化大都市的感觉、又能体验到民国风情还能体验到欧式风情。另外我同学带我在青岛转时，经常走着走着就见到了大海，这让我这个多年身居内陆，没见过海的少年来说还是挺欣喜的。感觉青岛比西安冷很多，今年4月西安已经很热了，花都开了，但是去了青岛以后发现柳树才刚有一点点绿，还挺凉快的。\n青岛的海鲜是挺丰富了，让我这个很少吃海鲜的少年一次吃了个够，还买了些海鲜给家里面寄了点。果然内陆的海鲜吃起来和沿海城市的海鲜差好多，另外山东菜是真的能倒酱油。\n交通 感觉青岛交通还是不错的，地铁线路挺发达，尤其是有条地铁线直接从市里通到山东大学让我觉得很赞。坐车在市里游荡的时候不知道是不是因为避开了拥堵的地区，我感觉堵车不太严重。不过山东人开起车来是真的有点猛。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/qingdao/","summary":"青岛 最近我发现青岛的呼声很高，所以我就先把青岛安排了。我和青岛的缘分来自于我的山东舍友、同学以及师兄。在三年的研究生生活中，以及我山东舍友带","title":""},{"content":"上海 大家中午好啊！我是大白。\n程序员视角观城市系列已经更新有 6 期了，我们一起看了西安、长沙、天津、广州、青岛。除了广州之外，其余的都是二线城市。\n最近，上海的呼声比较高（在上海工作的小伙伴很多啊）。于是，我利用晚上下班回家之后的自由支配时间整理了一下上海的互联网公司和生活情况。\n由于上海的互联网公司实在太多，这篇文章也只是挑选出一些比较有代表性的来简单介绍一下。\n希望能够对你们有帮助！整理不易，希望大家能够多多帮忙扩散转发支持一下。大白在这里谢过了！\n国内一线大厂 作为一线城市，绝大部分大厂即使总部不再这里，也会选择在这里设立分部，吸引当地的人才。\n腾讯 腾讯总部在深圳，在广州、上海、北京、成都、武汉、香港等地都有办公室。\n腾讯把长三角作为重要业务布局区域，2002 年进入上海，2008 年落户徐汇。腾讯华东总部预计在 2021 年正式迁入徐汇滨江的总部大厦。\n腾讯上海分部主要发展人工智能、游戏、腾讯云等业务。\n招聘这块的话，上海腾讯主要招聘 C++、安卓开发、测试、游戏工程师、后端开发等岗位。\n腾讯的各种福利非常不错的，各种福利补助，上班也不需要打卡。\n校招的话，一般会先让你做一个笔试。笔试考察的内容比较全面，既有计算机基础又有编程题。实习的话，一般是先进行一波电话面试，主要问你一些比较编程基础相关的问题。\n不过，腾讯的 KPI 面试比较严重，你的简历指不定被哪个部门捞起来。\n字节跳动 字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。\n字节跳动 2014 年在上海设立分部，上海的员工总数 6000+，其中设计师、研发工程师、信息技术科学家等专业技术人才的人数已经超过 2000+。\n字节跳动预计在未来 2 年之内，将上海员工的人数增加至 2 万，重点扩张张音乐、游戏、电商团队。并且，抖音电商业务相关的所有团队有预计会整合到上海。\n招聘这块的话，上海腾讯主要招聘数据分析、Java 后端、前端、 C++、安卓开发、iOS、测试等岗位。\n面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。\n字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。\n阿里巴巴 阿里巴巴总部在杭州，在北京、上海、广州、成都等地都有办公室。\n阿里巴巴三个总部和三个中心落户上海，其中三总部是支付宝总部、盒马总部、本地生活总部，三中心是阿里上海研发中心、阿里新零售中心、蚂蚁科技中心。\n加班的问题比较严重，受不了 996 的小伙伴慎重考虑。\n招聘这块的话，上海阿里巴巴主要招聘 Java 后端开发、产品经理、算法工程师等岗位。\n阿里进入面试后就很少问代码题了，但是对原理性的问题问的比较深，经常会问一些你对技术的思考，比如，你觉得Sring好在哪？如果答的比较浅的话，通常不能让面试官满意。\n美团 美团总部本身是位于北京，由于旗下产品大众点评起源于上海，因此，美团在北京和上海设立双总部。\n除了北京上海之外，美团还在厦门、成都，深圳等地有办公室。\n美团旗下产品有美团、大众点评、美团外卖、美团优选以及美团买菜。\n招聘这块的话，上海美团主要招聘 Java 后端、前端、测试、安卓等岗位。\n面试这块的话，一般也会有手撕算法环节，总体难度一般。美团几乎没有部门直招，都是先把简历投在池子里，然后由部门从池子里进行打捞。内推可以定向推事业群，但是感觉内推作用不太大。美团的面试是五道代码题（我记得应该是，这记忆有些模糊）。做出三道就稳进面试了，做出两道也有可能进面试。\n美团的技术面有时候两轮，有时候三轮。不过美团只进行两轮技术面就给你 offer，有可能也是 sp，因为我就是~\n拼多多 拼多多还是挺厉害的，创建于 2015 年 4 月，现在应成为中国第二大电商平台。\n拼多多的研发部门主要在上海，其他地方虽然也有办公室，不过基本不招技术人员。\n招聘这块的话，上海拼多多主要招聘 Java 后端、前端、数据分析等岗位。\n拼多多秋招会有很多轮，拼越计划、提前批、正式批。我当时投的是拼越计划。面试也是常规面试。我当时一面通过，二面代码题写的有点问题，思路有了但是代码一直有个 bug 。面试官就把我调客户端了，又加了一轮面试。对了，客户端这两年各大厂都急缺，面试也相对容易。面 java 的完全可以没有客户端经验，然后转到客户端岗位面试，客户端考核计算机网络会比较多。\n拼多多客户端技术面完以后迎来的是 HR 面，但是不知道怎么回事 HR 面没过。这也是我唯一的一场 HR 面没过。另外给大家说明下，拼多多开出的 offer 的薪资几乎是业界最高，但是拼多多是真的累，常态化的一周六天上班时间大部分人是顶不住的。\nPDD 工资非常高，不过，据说办公环境非常一般，工作强度也非常大（一周 6 天，上午 11 点到晚上 11 点）。\n其他 除了上面介绍到的这些一线大厂之外，上海还有哔哩哔哩、携程、快手、百度、京东、网易等不错的互联网公司。\n金融相关 平安 平安诞生于深圳，旗下包括平安寿险、平安产险、平安养老险、平安健康险、平安银行等涵盖金融业各个领域的 30 多家子公司，像比较出名的金融科技公司陆金所就是平安旗下的。\n招聘这块的话，上海平安主要招聘 Java 后端、前端、测试、数据分析、算法等岗位。\n面试这块的话，一般会有两轮技术面，一轮 HR 面。技术面试的提问内容主要根据你的项目经历来问。\n东方财富 东方财富主要做金融相关的服务，包括证券、基金销售、金融数据、公募基金、私募基金等等业务。\n招聘这块的话，上海东方财富主要招聘 Java 后端、测试、.Net、C++、前端等岗位。\n面试这块的话，加上笔试一般技术面试有两轮。第一轮笔试通常会有上级测试，上机的编程题难度一般。第二轮技术面试会根据你的项目经历来针对性提问。\n浦发银行 招聘这块的话，上海浦发银行主要招聘 Java 后端、前端、算法等岗位。\n面试这块的话，总体难度比较简单，通过率非常高！\n招商银行 招聘这块的话，上海招商银行主要招聘 Java 后端、前端、算法等岗位。\n因为很多项目都外包出去了，所以，招的技术人员实际不多。\n面试这块的话，总体难度比较简单，通过率非常高！\n其他 除了上面介绍到的这些公司之外，上海还有汇添富、众安在线等和金融相关的公司。\n外企 如果想追求 Work and Life Balance 的话，下面这些外企会是非常适合你的选择。\nMicrosoft(微软) 国内的话，微软在北京、上海、苏州、深圳都有办公室，业务涉及 Office365、Azure、Bing、Cortana 等微软自家的产品。\n虽然薪资比不上国内的一线大厂，但是相对来说还是薪资和福利还是很不错的！性价比非常高！\n除了每天免费的水果饮料零食咖啡这种基本福利，公司还有自己健身房，平时还会组织很多活动。并且，上班是完全不需要打卡的，可以相对更自由的安排自己的工作时间。\n微软提供的硬件环境非常可以，一般入职的时候就有 Dell 双屏幕、 MacBook 或 Surface Book 等提高生产效率的工具。\n暑期实习生除了有导师指导做项目外，也有多姿多彩的业余活动比如 Hackathon 大赛可以参加。\n招聘这块的话， 上海微软主要招聘 Web 前端、全栈、算法、设计、C/C++、Java。\n总的来说，如果你想在国内找一份相对轻松、不加班的工作的话，微软会是一个非常好的选择。\nCisco(思科) 思科于 1994 年进入中国市场，目前在中国拥有员工超过 4000 人。\n思科最早在上海成立了一个研发中心，到现在，已经在上海、北京、杭州、苏州、合肥、深圳等地有办公室。\n招聘这块的话， 上海思科主要招聘测试、软件研发工程师、C++。\n面试这块的话，一般会有三轮。第一面和第二面的时候就是问一些计算机基础知识以及你面试的岗位需要的技术知识，可能会有英文能力的考察，比如让你使用英文介绍你的项目。第三面的话，就是聊聊自己的过往经历、兴趣爱好、职业规划这些东西。\nThougtWorks(思特沃克) 国内的话，ThougtWorks 在北京、上海、成都、武汉、西安、香港等地都有分部。\n据我一位朋友说，在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。\n招聘这块的话，上海 Thoughtworks 主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、.NET、C/C++。\n面试这块的话，一般会先给你一个作业让你做，时间是 3 天左右。一定要注意代码质量以及代码的可扩展性！作业通过之后，会进行下一步的面试。面试官通常会让你在作业的基础上做一些功能的增加或者修改，并且，还会问你一些和简历相关的技术性问题。\nThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。\nPayPal(贝宝) PayPal 这家公司大家应该也知道，主要做移动支付的，主要是海外市场。\n国内的话，PayPal 在上海、北京有办公室，主要做支付方向的业务。\nPayPal 提供的硬件环境也很不错，一般入职的时候就有 2 台 MBP、34 寸显示器等提高生产效率的工具。\n招聘这块的话，PayPal 主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、NodeJS、Python。\n面试这块的话，PayPal 通常是三轮技术面+主管面。第一面和第二面的时候主要问一些计算机基础知识以及你面试的岗位需要的技术知识，第三面的可能会让你做算法题。\n其他 除了上面介绍到的这些外企之外，上海还有 Intel（英特尔）、SAP（思爱普）、Amazon（亚马逊）、Booking 等不错的外企。\n生活 我们再来看看生活环境和生活成本。\n房价 上海的房价就不需要多说了，一个字：“贵”！\n一般人奋斗一辈子都买不起，如果你的收入比较高的话，还是有可能在上海拥有一套属于自己的房子。\n以下房价数据来源于安居客，可以作为参考。\n教育 上海的教育资源还是非常不错的！目前上海共有 10 所 211 大学（含 985），其中有 4 所 985 院校，分别是复旦大学、上海交通大学、同济大学、华东师范大学； 6 所 211 院校，分别是中国人民解放军海军军医大学、华东理工大学、东华大学、上海财经大学、上海大学、上海外国语大学。\n虽然上海的教育资源比不上北京，但是对比教育资源比较好的二线城市比如武汉和长沙还是有很大优势的。\n湖北省省会武汉有 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。湖南省省会长沙有 4 所 985/211 高校，分别是国防科大、中南大学、湖南大学、湖南师范大学。\n医疗 2020 年的一份报道显示：每千人口拥有医师数最多的三个地区为依次是北京（4.63 人）、浙江（3.33 人）和上海（2.95 人），已经可以与高福利的欧洲国家比肩。 不过，上海的每千人均医疗机构床位数排名中等，深圳垫底。\n另外，上海的三甲医院数量一共有 66 座，仅次于北京。\n交通 截至 2021 年，上海地铁已开通运营 19 条线路、是世界上客运规模第二大的城市地铁系统，仅次于北京地铁。\n郊区的话，地跌一般还没有覆盖到，可以乘坐公交。\n堵车情况的话总体还好，一般就是上下班高峰那会，核心路段可能会堵车。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/shanghai/","summary":"上海 大家中午好啊！我是大白。 程序员视角观城市系列已经更新有 6 期了，我们一起看了西安、长沙、天津、广州、青岛。除了广州之外，其余的都是二线城市","title":""},{"content":"苏州 大家好呀，我是大白，许多读者想让我写一下苏州，我们今天就来看下苏州的互联网环境。\n有句话叫做上有天堂，下有苏杭，不过有一说一，互联网环境方面苏州和杭州可是差了一大截。但是我个人还是很看好苏州的，而且从 18 年左右开始，苏州的互联网环境开始有了明显的改善。生活方面无论是苏州的地理位置，还是人文环境，都是十分适合居住生活的。\n老规矩，下面我们还是按照程序员的工作机会和生活环境来介绍苏州。\n因为苏州目前可供程序员选择的好的就业机会还是不像北上广深等地那么多，我就不把苏州的工作机会分互联网、国企、外企等介绍了。我把比较不错的工作机会直接混在一起详细介绍下，然后其它我知道的工作机会就在最后列一下了。\n工作机会 微软 微软可以说是程序员在苏州最好的工作机会了。微软近些年也一直扩大在苏州的投资力度，目前微软苏州研究院的研发团队已经有 2000 人左右了，并且还在近一步扩建。2022 年微软将启动微软苏州三期新大楼的建设，建成后预计微软在苏州的研发团队会达到5000人。所以，目前想拿微软苏州的 offer 的难度，相比于拿北京上海等其它几个工作地 offer 的难度会低一些，大家抓紧呀。\n许多人对微软的印象就是养生，但是我问了一些微软的职工后发现还是要看组，在微软天天干到 9 点多才能下班的组也是有的，不过大部分组养生起来是真养生，支持居家办公这种工作方式是真的爽。\n微软的薪资相对于国内的互联网大厂来说会低一些。苏州微软今年校招开出的 offer 是白菜价年薪 29 万左右（26万 base + 10%的年终奖），Special offer 年薪是 31万左右（28万 base + 10% 年终奖）。额外签字费加搬家费一次性发放 6 万元，4.5 万元的股票分 4 年发放。在校招薪水上也看到一个 2 年经验的老哥爆料自己拿到的苏州微软 61 级 offer 薪资，年薪 35 万左右（32万 base + 10%的年终奖），额外签字费加搬家费一次性发放 5 万元，8万美元的股票分4年发放，还有每年7200元的餐补，健身补贴每年 1800 元。\n我有点按捺不住想给苏州微软投简历了。微软校招面试对于手撕代码的考察是很严格的，如果想要去微软的一定要多刷代码题。如果你走社招进微软的话，不止是要刷好题，还要多准备系统设计的相关知识，这个也是可以针对性准备的，可以看我这篇文章\u0026ndash;大型系统设计方案，另外如果想准备面试常问八股文，也可以看这里-八股文合集\nZOOM 在苏州，Zoom是除微软外的另一个好选择。Zoom 曾经被评为全球最佳雇主。根据 zoom 员工的说法，zoom的技术水平大概和国内二三线厂的水平差不多。薪资方面，比国内互联网也要低一些，看到一个校招薪资的爆料，一个做前端的硕士在苏州zoom的薪资是17k * 14。额外有 7 万美元的股票，分 4 年发完。虽然 base 薪资方面相对低一些，但是 zoom 工作是真的爽呀，没有 996，没有 kpi，办公环境好，无限零食和水果供应，这还要啥自行车。\n华为 华为在苏州的研究院设立时间不长。华为的苏研院的加班在各地所有的研发中心中是排的上号的。华为各地研发中心的忙碌程度差不多是成都 》= 西安 》= 苏州 \u0026gt; 武汉 \u0026gt; 东莞 \u0026gt; 杭州 \u0026gt; 南京 \u0026gt; 深圳 \u0026gt; 北京 \u0026gt; 上海（整体感觉是这样，每个研发中心各部门的加班情况也不同）。不过华为有一个好处就是你挣的钱能和你的付出成正比，所以想快速挣钱的还是建议去。\n360 360 来苏州时间不长，2018年才逐渐开始在苏州设立开发部门。目前 360 苏州包含了未来安全研究、360政企、安全等部门。目前 360苏州的薪资水平是北京上海薪资水平的 8 折，看到 21 年毕业的一个应届硕士爆料月薪是 16k，工资有点少，不过感觉在苏州也不错呀。\nMomenta !\n一开始我对 Momenta 还真没什么了解，直到我有一天突然在校招薪水上搜了下 Momenta，然后我不由得直呼卧槽，这特么是给应届生的薪资？认真的？\n然后我详细的了解了下这家公司，这是一家做自动驾驶的公司，创立时间也不长，2016年创立的。不过据说这家公司加班特别猛，有的组 10 10 5，有的组 996，有的组比 996 还要累。Momenta 现在能给的起这么高的工资，实力还是有的，不过对于发展的前景来说，领域这么垂直的公司风险性是比较大的。\n企查查 跟上面的公司相比，企查查算是一个小而美的公司。企查查是苏州的本地企业，目前来说口碑还是很不错的。目前企查查的业务很赚钱，自己的大楼也差不多修好了。没有强制加班，全额社保和公积金。我没有查到企查查的校招薪资，看 boss 上的社招薪资水平不算太高，只能算还可以了。\n收钱吧 这个公司大家应该都听说过，每次你用支付宝或者微信给商家付钱时都能听到“收钱吧到账xx元”。收钱吧的技术不错，加班也比较少，收钱吧的风评不错。不过就是工资相对给的少点，月薪 17k 左右（在苏州也还行了），每年14 个月的月薪。\n中国移动苏州研究院 中国移动苏州研究院又叫苏小研，其实犹豫了很久要不要把他放在推荐里。苏小妍在知乎上的争议很大，有说待遇福利很好的，也有狂喷的。苏小研肯定有国企的通病，这个我确认，但具体怎么样就靠大家自己判断了，贴两张知乎上对苏小研的评价，好坏要大家自己去具体确认了。这两张图评价完全是两个极端呀。\n上面是我认为苏州的比较不错的程序员就业机会，其它的一些苏州比较成规模的提供程序员就业机会的公司就列在下面，并且快速的简单介绍一下。\n同程艺龙：之前算是苏州最大的互联网公司，但是目前员工对公司的吐槽比较多，详情可以在知乎和脉脉上搜下。\n京东工品汇：工品汇是之前苏州的企业，被京东收购了，据说目前算是京东比较边缘的业务部门。\n科大讯飞：科大讯飞在苏州是有岗位的，不过岗位很少。\n思必驰：和科大讯飞一样做语音的，不过现在网上对思必驰的负面评价孩挺多\n建信金科、中银金科：看名字就可以看出，这两公司属于银行的子公司，也可以说是外包。大家要把这些公司和银行的软件开发中心区分开来。其实银行的子公司给人的感觉有点尴尬，就是它们既没有互联网公司的高薪，也没有银行软件开发中心直属总行的稳定。当然这也就是相对于大互联网公司来说，如果手上没有一二线互联网公司的 offer，也可以考虑去的。\n锐捷：许多同学应该听说过锐捷，专门做校园网的，比较偏底层，对 Linux 内核感兴趣的可以看看呀。薪资相对较低，校招开出的薪资在13~15k 这个区间。\n金蝶：国内 ERP 巨头，在苏州貌似岗位不多。\n科沃斯：主要做智能硬件的，公司很强，市值都一千多亿了。也有很多编程的岗位。。\n生活 许多人想在苏州定居，也主要是觉得在苏州生活很惬意。下面还是分教育、房价、交通、娱乐等方面介绍下。\n教育 高等教育方面。其实就苏州本身而言，高校并不多，只有苏州大学一所 211（苏大的自然语言处理挺强的）。但是前些年许多地理位置偏北的高校为了打造自己在南方的影响力，提高生源质量，都会选择在南方办学。其中一部分选择了深圳，另一部分选择了苏州。西交大、中科大、中国人民大学、东南大学、西工大等院校都在苏州设有校区。所以虽然苏州本地院校不多，但是苏州计算机软件相关的高校毕业生并不少。不过这种现象随着西工大太仓校区刚修好，异地办学就被叫停了，我瓜实惨~\n中小学教育方面，苏州的教育质量肯定是不错的，不过江苏的高考压力可不小。有些人定居苏州也会担心下一代的高考问题。\n房价 相比于苏州的工资水平，其实苏州的房价也不低了，看网站上的新房均价大约两万五一平。但是和旁边的城市一比，那苏州的房价就比较香了。在苏州咬咬牙还是能考虑买房的。\n娱乐\u0026amp;交通\u0026amp;美食 娱乐方面苏州好玩的地方很多，传统的苏州园林风格和苏州现代风格都让人十分留恋。周末在苏州园林逛一逛真的很惬意。\n交通方面堵车是肯定会堵的，还没见过哪个二线以上城市不堵车的。但是苏州的交通相比于其它同量级的城市还是要好很多。另外苏州地理位置上靠近上海南京，出去玩也很方便。\n美食方面，苏帮菜貌似在全国并不多见，口味偏甜。这就不知道大多数北方人能不能吃得惯了~\n好了，就介绍这么多，我感觉我还真有点想给苏州微软投简历去工作生活一段时间~\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/suzhou/","summary":"苏州 大家好呀，我是大白，许多读者想让我写一下苏州，我们今天就来看下苏州的互联网环境。 有句话叫做上有天堂，下有苏杭，不过有一说一，互联网环境方","title":""},{"content":"天津 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越来越全面了，但相同公司不同部门不同组的情况也差别很大，这里只能介绍一个总体情况，如果大家有更多的信息，欢迎联系我补充呀。\n白师傅，你嘛时候成为津门第一呀？不是不是，你嘛时候介绍天津呀？来了来了，天津是肯定要安排的。我和天津的故事起源于上大四的时候，学院直接把我们打包到外面的培训机构培训（学校把我们的学费给培训班一部分让他们培训我们，解决我们就业），当时有天津、北京、苏州、上海等地我们可以选择（话说我的经历还真的是丰富 ~ 自学过编程，也在学校安排的培训机构培训过！考过研也找过工作！搞过开发也做过算法！）。因为我当时想着准备考研（我们专业的考研党和天津的培训机构商量好先让我们准备考研，等我们考完研再给我们培训），有点不习惯南方的气候，北京又物价太贵，就选择去天津培训。当我第一次坐着飞机在傍晚时分的天津上空盘旋，感觉天津的夜景真的是太美了。\n好了，情感从天津这么美的夜景中收回来，收！天津的互联网环境是真的不怎么好，当准备下笔时我竟想不出一个在天津设点的互联网大厂。我在天津时曾经问在天津的朋友，为嘛天津的互联网环境介么差呢？朋友说因为这些大厂都在北京已经设点了，离这么近再设点不划算。当时我觉得挺有道理，但是我过了一会又问朋友，那为嘛杭州苏州离上海那么近互联网产业还发展那么好呢？朋友叹了口气没有说话~\n不过在天津的话眼光就不要仅局限于互联网了。感觉去一些国企和研究所也可以呀。下面的数据仅代表我的调查结果，如果大家有要补充的直接在评论区留言呀。\n读者补充：天津有个补充公积金挺吸引人的，有的单位的补充公积金能到工资的一半，有意去天津生活的大家可以详细去了解一下呀。\n互联网 我在写天津的互联网公司的时候的经历是这样的，首先我想到了我的一个同学，我记得他在天津的神州优车做的还不错，于是我给他打通了电话。喂，老哥，最近在神州优车干的怎么样？啊？天津神州优车没了？你现在在哪呢？哦，在家呢，行，改天出来一块吃饭哈，我先写文章了。于是我又想到一个曾经有印象的，华为海洋应该还行吧，我去查查。嗯？卖了？这\u0026hellip;再看看别的，这家是个外企，应该不错，我去了解了解去，这咋最近还大幅裁员呢？这都啥嘛\u0026hellip;我不写了。\n我把现在还存在的互联网公司列在这，大家想了解自己去了解吧。话说现在天津的互联网公司是真的没几个像样的。\n紫光云、捷信、科大讯飞、云账户、卓郎科技、联想云、浪潮云、中交智运。\n大家如果知道有不错的互联网公司，快点告诉我呀。\n国有控股 中兴\n中兴天津在空港经济区，那边去了你就知道了，是真的人少，不过环境倒是不错，离机场也很近。硕士能给到每月 17k。感觉还可以吧。\n麒麟软件\n本科每月 10 k，硕士我查是 15 k，不过我问一个老哥，看他的表情好像不一定能到？年终奖 1-3 个月的工资，加班狠。不过还好有人才公寓包住。\n南大通用\n南大通用在天津算是不错的公司了，做国产数据库的。不过听说公司情况有点复杂。\n中科曙光\n在天津来说还是不错的，中科曙光的实力还是有的，不过加班严重。去年校招硕士给的价钱是月薪 13k 左右。\n联想\n刚在天津设立部门，最近招聘量很大。因为刚成立，所以目前的待遇情况和加班情况都未知，但感觉在天津的话去联想是不错的选择呀，大家如果想去赶紧投简历呀。\n银行软件开发中心 感觉程序员在天津工作的话，银行的软件开发中心是不错的选择了。工资水平不错，工作稳定，而且加班还比较少。\n农行软开\n农行软开天津基本是程序员在天津工作的最好的几个选择之一了。属于总行编制，薪资水平和西安持平，转正以后每月到手 12 k，很香了。加不加班看部门，有的部门加班多，有的部门加班少，你在哪个部门应该是统一分配，看运气喽。\n渤海银行\n感觉渤海银行特别香，给应届硕士的年薪总包 20 w，还有补充公积金。网上的评价比较好一些。\n渣打银行\n渣打银行是个国际银行，本科每月税前 12 k，硕士每月税前 14 k，年终奖是按年薪的 15% 发放。我调查过程中感觉这里的网上评价不太好。大家如果想去自己要详细了解下呀。\n另外感觉去四大行的天津分行也是一个不错的选择，不过薪资水平我就不太清楚了，大家有意向自己再去了解。\n研究所 天津的研究所是真不少，考虑在天津定居的话，去研究所感觉性价比还是相对高一些的。不过学历要求都是硕士起步呀。所以提升学历也是有必要的，可以让你选择面多一些。有想考计算机相关专业研究生的同学也可以来找我聊聊。\n中航工业602所\n602所是主要做直升机的，在景德镇和在天津都有。硕士年薪 15w 左右，另外有 3w 的安家费。博士 28w 左右，给 20w 的安家费。\n航天科技集团研究所\n天津有航天科技 518 所、8357 所、8358 所。具体待遇不太清楚。不过根据我的了解，航空航天类型的研究所目前是所有研究所中效益最好的了，福利待遇应该相对于其它类型的研究所会好些。不过这些年中国航空航天方面的研究所加班也越来越多了，几个在航空航天研究所的朋友都挺累的。\n国家超级计算天津中心\n应届硕士应该是一年到手 10-12w，嗯，这样算那税前年包差不多就是 15w 嘛，看来天津这几家研究所的价钱都差不多呀。新职工有宿舍。\n中国电子科技集团\n中电 18 所、46 所、53 所都在天津，硕士的起薪差不多是 15w 左右。\n中国船舶集团\n中船舶 707 所，718 所在天津都有。薪资水平只能大家自己去打听了，研究所的薪资水平都不是太透明，我是没打听到。\n生活 房价\n话说天津的房价和天津的工资水平是真的不匹配，地段好一点的区新房均价基本都 3 万以上了，咱们来看下天津的各区房价统计。按照在天津的工资水平想在比较好的几个区买房是真的不容易。\n教育\n天津的教育还是不错的。大学有天大和南开两所 985 实力强劲，211 院校只有一个，就是河北工业大学（河北人民有点惨）。像天津理工大学、天津科技大学、天津师范大学、中国民航大学等也不错。天津的高中也非常不错，天津的耀华中学、南开中学、天津一中、实验一中、静海一中等都非常好。天津的高考也相对容易，孩子们的竞争压力相对小一点。感觉这是天津比较吸引人的地方。\n读者补充：天津医科大学也是211。\n医疗\n天津的医疗水平也是排在全国前列的，天津的肿瘤医院、血液病医院在全国来看也能排到前三。环湖医院、泰达心脑血管医院等部分科室水平也处于全国前列。天津的医疗条件完全能够满足本地的需求了，基本上看病不用出津。\n交通\u0026amp;气候\u0026amp;娱乐\u0026amp;美食\n天津的交通最值得称道的地方就是他半个小时到北京的高铁了，车次基本平均每 5 分钟就有一趟，所以好多人在北京上班在天津住 ~ 感觉天津的房价就是这样起来的\u0026hellip; 最近一段时间天津修地铁修的很猛，一直在传来新线路开通的消息。堵车嘛，目前还没哪个二线城市不堵车的，我知道的也就太原堵车相对没那么严重。\n天津因为沿海，夏天比较潮湿，到了冬天风非常的大，我在天津的那年冬天还把我脸吹伤了。春天的气候比较舒服。\n天津的夜景一直是我非常喜欢的，周末的晚上在五大道、滨江道吃个饭，沿着海河两岸转一转，或者去民园跑跑步都是十分惬意的。\n美食方面的话我感觉天津人是真的不怎么吃狗不理包子 ~ 天津到处是卖煎饼果子，还有麻花的。\n以上就是介绍天津的全部内容了，爱之深责之切，我是真的希望天津的互联网环境能再发展的好一点，让程序员有更多的工作机会。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/tianjin/","summary":"天津 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。目前的信息已经越","title":""},{"content":"武汉 国内一二线大厂 字节跳动  基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。字节跳动 2018 年来到武汉，近几年的招聘规模非常大，研发人员的数目也越来越多！ 业务方向 ：效率工程（Efficiency Engineering）、飞书、aPaaS（对标业内顶级 PaaS 和 SaaS 平台产品）、抖音电商。 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况：六险一金(12%)、包三餐、免费下午茶+零食、免费健身房、Top 薪酬、住房补贴 招聘情况：主要招聘后端（Java、Go）、前端、测试等岗位。 面试 ： 面试这块的话，主要是问计算机基础知识，一般先会让你做一道算法题，算法题的难度还是比较大的。字节的面试有个好处是可以对你反复进行打捞，就是说你面挂一个部门以后，可以马上再转投另一个部门，并且好多部门是不用笔试直接进面试的。我前前后后面了字节三个部门，并且都是第二面，或者三面挂\u0026hellip;我有种感觉就是整个 九月 都在跟字节面试官聊天。但最终也没通过字节面试。  华为  基本情况 ：华为不属于传统意义上的互联网公司，不过算得上是大厂。华为在武汉有一个研究所，规模还是挺大的！ 业务方向 ：传接、光产品、消费者（平板、笔记本电脑、音箱等）。 工作地点 ：武汉未来科技城，目前已自建办公园区基地。 福利情况：员工股权激励、薪资非常有竞争力。华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。 招聘情况：主要招聘软件开发（Java、C++）、嵌入式开发、测试等岗位。 面试 ： 面试的话，难度一般，主要看学历。 补充 : 华为加班比较多，压力可能会比较大。不过，薪资收入在武汉绝对是 Top 级别。  腾讯  基本情况 ：腾讯目前在武汉有腾讯武汉研发中心和腾讯云计算（武汉）有限责任公司，前者是分部后者是全资子公司。 业务方向 ：腾讯云主要负责腾讯云后台开发维护及智慧产业相关产品的研发，旗下有腾讯会议、智慧校园、数字政府等产品。 福利情况：全额公积金 （12%）+饭补+带薪年假 招聘情况：主要招聘前端开发、后台开发、数据库工程、云储存技术专家、云原生架构师等岗位。 面试 ： 面试的话，难度较大。校招的话，一般会先让你做一个笔试。笔试考察的内容比较全面，既有计算机基础又有编程题。实习的话，一般是先进行一波电话面试，主要问你一些比较编程基础相关的问题。 补充 : 全资子公司和腾讯本部还是不一样的，加入之前请慎重考虑。不过，即使是全资子公司的待遇在武汉也是属于非常不错的了。  小米  基本情况 ：雷总是武大的毕业，把小米总部也设立在了武汉。小米在武汉的发展还挺迅速，目前，小米在武汉员工已经超过 2000 人。小米在北京、深圳、上海、武汉、南京都有办公室。 业务方向 ：新零售、国际化、人工智能、互联网金融 工作地点 ：武汉东湖高新九峰一路小米武汉研发中心（自建） 福利情况：待遇不错，公积金 12%全额缴纳。 招聘情况：主要招聘 Java、Go、前端、服务端、测试等岗位。 面试 ： 面试的话，难上中等偏上。过程一般是：网申 → 简历初筛 → 测评 → 笔试 → 简历复筛 → 面试 →offer。 补充 : 小米在武汉确实是一个非常不错的选择！  金山软件   基本情况 ：金山软件（以下简称金山）是国内最早的互联网软件企业之一，2017 年来到武汉，未来将武汉作为重要的研发基地和人才培养基地。\n  业务方向 ：涉及金山办公（WPS Office）、西山居（美术中心为主，也有游戏研发）、金山云（云服商）3 条业务线。\n  工作地点 ：光谷 APP 广场\n  福利情况：待遇不错，公积金 12%全额缴纳。\n  招聘情况：主要招聘前端开发、后端开发、移动开发、算法等岗位。\n  面试 ：面试难度中等偏上，面试前记得好好吃透简历上写的技能。\n  补充 : 部分项目组可能会存在加班情况。\n  有赞  基本情况 ：有赞是 2021 年才来武汉成立研发中心。 业务方向 ：SaaS 服务（帮助商家网上开店、社交营销\u0026hellip;\u0026hellip;）、PaaS 云服务。 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况：全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘后端、前端、移动开发等岗位。 面试 ：面试难度中等偏上。一般由 3 轮面试，前 2 面是技术面，最后 1 面是 HR 面。 补充 : 公司技术不错！  神策数据  基本情况 ：神策数据是国内专业的大数据分析和营销科技服务提供商，为企业提供神策营销云、神策分析云、神策数据根基平台三大产品方案。公司总部在北京，2019 年 4 月 ，神策武汉研发中心正式成立。 业务方向 ：互联网、品牌零售、金融、融合媒体、企业服务、高科技、汽车、互联网+ 工作地点 ：洪山区关山大道光谷新发展国际中心 福利情况：七险一金、定期体检、带薪年假、不限量零食、下午茶、节日礼品、生日礼物、团建等 招聘情况：主要招聘后端、前端、机器学习、大数据。 面试 ：面试难度中等偏上。一般由 4 轮面试，前 3 面是技术面，最后 1 面是 HR 面。 补充 : 公司发展比较快，技术氛围不错。  其他 除了上面介绍到的这些一二线大厂之外，武汉还有下面这些不错的公司：\n 木仓科技 ： 专注于汽车生态的一家公司，驾考宝典和买车宝典就是他们的产品之一。成立于北京，目前在北京/武汉/上海/广州拥有办公地点，近 500 名员工。 青云 ：云计算服务提供商。成立于北京，目前在北京/武汉/成都拥有办公地点。 科大讯飞 ：智能语音及语言技术、人工智能技术研究和软、硬件产品应用开发。 京东武汉京喜事业部 ：京东 2021 年成立了京喜事业群，京喜通事业部就是其中一员。 旷视科技 ：人工智能产品和解决方案，Face++云平台就是他们家的产品。 多益网络 ：游戏相关，神武系列、梦想世界就是他们家的游戏。 \u0026hellip;\u0026hellip;  国企 远光软件  基本情况 ：2011 年远光武汉研发中心成立，2015 年创建全资子公司远光软件（武汉）有限公司。 业务方向 ：集团管理、智慧能源、智能物联、社会互联。 工作地点 ：东湖高新技术开发区光谷大道 77 号光谷金融港 B3 栋 。 福利情况：有通勤车和食堂，整体待遇不错。 招聘情况：主要招聘 Java、Go、前端、人工智能、测试等岗位。 面试 ：面试难度一般，基础考得多。 补充 : 部分项目组可能会存在加班情况。  烽火通信科技  基本情况 ：烽火通信成立于 1999 年，前身是通讯业内闻明显著的武汉邮电科学研究院，1976 年成功制作出国内第一根光纤。不过，目前的发展情况不行，前景堪忧。 业务方向 ：通信系统设备、光纤及线缆、数据网络产品。 工作地点 ：东湖开发区高新四路 6 号 福利情况：待遇一般，五险一金，免费班车，餐补。 招聘情况：主要招聘 Java、.Net、人工智能、算法等岗位。 面试 ：面试难度一般。 补充 : 武汉本土国企，不过，据说内部的情况比较坑，不太适于追求技术发展的朋友。  金融相关 众邦银行  基本情况 ：专注于服务个人小微的互联网交易银行。 业务方向 ：互联网金融 工作地点 ：汉口北国际商品交易中心 D2 区 福利情况： 六险二金、节假日福利、带薪年假、生日福利 招聘情况：主要招聘大数据、前端、后端、运维、测试等岗位。 面试 ：面试难度一般，面试氛围一般。  微众银行  基本情况 ：科技驱动的国内首家民营银行、互联网银行。 业务方向 ：微众银行武汉研发中心主要负责承担微众各类业务系统设计、开发、运维等工作，与相关科技部门充分协作，为业务提供高质量且成本可控的系统功能交付，以支持银行业务整体可持续发展。 工作地点 ：中建·光谷之星科技产业园 福利情况： 年底双薪，年终奖，节日京东卡，日常团建、公司旅游，生日 party，下午茶，12%的公积金，员工险，年度体检，周末双休.etc 招聘情况：主要招聘前端、后端、运维、测试等岗位。 面试 ：面试难度中等。一般由 4 轮面试，第 1 面是技术面，2，3 面试领导面，最后 1 面是 HR 面。  长江证券  基本情况 ：武汉本土，总部就设在武汉、业务网络覆盖全国的一家综合类上市证券公司。 业务方向 ：互联网金融 工作地点 ：新华路特 8 号长江证券大厦 福利情况： 五险一金，餐补，交通补贴，通讯补贴 招聘情况：主要招聘 Java、前端、运维、算法等岗位。 面试 ：面试难度中等，问的问题比较细，框架，项目经历等等。  其他 除了上面介绍到的这些银行之外，武汉还有农业银行武汉研发中心、建设银行武汉研发中心、浦发银行武汉研发中心等不错的银行研发中心可供选择。\n证券类公司，除了长江证券，还有中信证券、国泰君安证券等证券公司。不过，这些公司大多不招聘技术人员。\n本地互联网公司 斗鱼  基本情况 ：斗鱼是武汉比较大的一家本土互联网公司，直播行业的龙头，武汉市第一家“独角兽”级互联网创业公司。目前的话，虎牙和斗鱼已经合并。2019 年 7 月 17 日，斗鱼在美国纳斯达克交易所上市，成为湖北首家海外上市的本土互联网公司。斗鱼的办公环境不错，据说伙食也还可以，最重要的是你还有机会见到一些知名主播。 业务方向 ：直播 工作地点 ：洪山区光谷软件园 福利情况： 全额五险一金，公积金 12%+饭补+话费补助 招聘情况：主要招聘 Java、前端、运维、算法等岗位。 面试 ：难度中等偏上。校招一般主要问计算机基础，会附带问一些你要面试的岗位所涉及到的技术问题以及根据你的项目经历来提问。社招主要就是针对你的项目经历来提问。  微派网络  基本情况 ：武汉微派网络科技有限公司（WePie Team）成立于 2013 年 8 月，主要致力于移动互联网休闲游戏和社交产品的研发和运营，旗下产品有贪吃蛇大作战、会玩、微派桌游助手、青藤之恋。 业务方向 ：泛娱乐 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况： 武汉 TOP 薪酬+丰厚绩效年终奖（普遍 15 薪+）+节日福利+租房优惠 招聘情况：主要招聘 Go 开发工程师、测试、运维和移动端开发等岗位。 面试 ：难度中等，通常会有两轮技术面试。  盛天网络  基本情况 ：盛天网络早期是靠网吧系统发家的，易乐游就是它家的网吧管理系统，目前已经上市！ 业务方向 ： 工作地点 ：武汉东湖高新技术区光谷金融港 B7 栋 福利情况： 全额公积金，住房补贴，团建活动 招聘情况：主要招聘 Java 后台开发和运维等岗位。 面试 ：难度中等，通常会先让你做一个笔试，技术面比较重视基础。  其他 除了上面介绍到的这些武汉本地互联网公司之外，武汉还有下面这些不错的本地互联网公司：\n 石墨文档 ： 核心产品就是石墨文档。 常相伴 ：互动娱乐和社交产品，伴伴实时场景社交就是他们家的产品。 \u0026hellip;\u0026hellip;  外企 武汉这边的外企好像就只有一个 ThougtWorks。\nThougtWorks(思特沃克)  基本情况 ：国内的话，ThougtWorks 在北京、上海、成都、武汉、西安、香港等地都有分部。武汉是 ThougtWorks 在国内的研发总部。据我一位朋友说，在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。 业务方向 ：咨询服务、软件外包 工作地点 ：洪山区关山大道保利广场保利国际中心 福利情况： 全额公积金，住房补贴，团建活动 招聘情况：主要招聘 Web 前端、全栈、Java（后端开发这块 Java 招聘偏多一些）、.NET、C/C++。 面试 ：一般会先给你一个作业让你做，时间是 3 天左右。一定要注意代码质量以及代码的可扩展性！作业通过之后，会进行下一步的面试。面试官通常会让你在作业的基础上做一些功能的增加或者修改，并且，还会问你一些和简历相关的技术性问题。 补充 ：ThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。  生活 我们再来看看生活环境和生活成本。\n房价 武汉的房价相对全国来说还是比较有性价比的，泡沫相对也小一些。\n不过，武汉的工资收入相对一线城市来说也要低很多。\n以下房价数据来源于安居客，可以作为参考。\n教育 武汉的教育资源那是相当可以！不然，大学生也不会全球数量第一。\n作为湖北省省会，武汉有 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。\n去武汉大学看看樱花是多少情侣的愿望啊！\n医疗 武汉的医疗资源还是非常不错的！\n根据《2018 年武汉市卫生健康事业发展简报》，截至当年末，武汉市有三级医院 61 个，其中三级甲等医院 27 个。\n交通 武汉的交通还是非常便利的，地铁线路非常多！\n不过，武汉人也多，路上的车也多，上下班堵车是常有的事。\n武汉算的上是“交通枢纽”的存在，你从武汉出发坐高铁，你去国内大部分地方都非常方便。\n美食 武汉的包容性比较强，你想吃的在这边基本都能找到，种类非常多。\n早饭可以一个月不重样，各种火锅烤肉、川菜粤菜什么的随处可见。\n生活 本地人不排外，还算比较热情。\n武汉这边天气状况不好的原因？感觉武汉人脾气差，容易发火，尤其是汉口那边的本土居民。\n光谷这边其实还好，因为光谷这边还是年轻人巨多，很多都是在这边工作的大学生。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/wuhan/","summary":"武汉 国内一二线大厂 字节跳动 基本情况 ：字节总部在北京，在上海、深圳、杭州、广州、成都等地都有办公室。字节跳动 2018 年来到武汉，近几年的招聘规模非常","title":""},{"content":"西安 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我把我最近收集到的信息以及读者的补充添加到了文章中。\n另外我想说明下的是，虽然我这些数据都是经过实际调查，并且有很多在下面公司上班的读者补充，已经尽可能的接近客观。但依然只能反应一个公司的总体情况，同一公司的不同部门，不同组可能也会有较大的差距。\n最近越来越多的人关注到西安这座城市。作为一个刚在西安完成三年研究生学业的打工人，我就在这篇文章中替大家以程序员的视角看一看西安。我会从程序员在西安的工作机会、在西安的生活环境以及生活成本两个角度进行分析，给大家讲述一个程序员在西安生活的利弊。\n工作机会 其实西安在前些年，还被称为互联网荒漠，程序员生存的空间很小。\n在 18 年我刚到西安上研究生的时候，我们专业的学长学姐想留在西安，可选择的也只有华为、中兴以及几个研究所。但也正好是我读研的这几年，不断的有大企业在西安设点，并且将研发部门搬到西安。目前西安的互联网环境已经初具规模，对于计算机相关专业的学生，毕业留在西安也是一个不错的选择。同时这些年西安的互联网环境也在持续向好，不断有大公司在西安设立研发中心。\n同时，西安的互联网环境还处在一个开拓期，几乎所有的大企业都在西安设立研发中心不久，所以除了有限的几个公司和部门比较轻松外，其它加班都比较严重，并且有限的几个公司和部门的情况也在变化中。\n下面就分私企、国企、银行软件开发中心、研究所几大类来介绍西安招计算机相关专业的公司。各个公司的信息是根据我的了解以及和留在西安各个公司的同学打听所收集的，并且收集了部分网上信息。由于社招薪资水平根据每个人的情况相差较大，所以在介绍的时候比较多的提到的是校招的薪资，大家可以参考西安和其它城市的校招薪资来评估西安社招的薪资水平。\n互联网 华为\n如果想在西安快速挣钱的话，华为几乎是最好的选择了，按照华为的工资水平在西安买房根本没有压力。华为在西安的建制很齐全，消费者、CloudBu、云核心等事业群以及华为海思，2012 实验室都有。但是因为去年美国对华为的打压，消费者、华为海思以及 2012 实验室这些之前很香的事业群目前日子都不太好过。\n西安华为校招根据面试评分给应届生进行评级，本科生和硕士生的评级在 13 级 和 15 级 之间，每一级又分为 A、B、C 三个档。根据评级进行工资的评定，13 级 和 14 级 的税前工资在每月 13-19k 之间，每年 14 薪。15 级 需要特别优秀的硕士才能拿到，工资年包基本在税前 30 万 - 40 万之间。华为在西安的校招薪资水平还是很高的，几乎和北京持平了。\n华为在西安的社招我不是特别清楚，只是知道华为社招大部分给的是 OD ，社招想拿正式 offer 基本都需要 16 级以上的评级。\n在华为上班是压力比较大，也比较累的。据我了解，西安华为的 CloudBu 这个事业群下的部门还相对轻松。这个事业部下的部门基本上半年轻松半年忙。在项目不忙的时候，一般工作的节奏是早上 9 点，周二和周四常态化加班到晚 9 点，周一三五 6 点 以后就可以走。每个月的最后一个周，周六要常态化加班。华为产品线的部门是相当忙的，加班到几点就说不好了。不过华为的加班费是给的相当到位的，不会让你白加班的。另外外界对华为员工的技术认可度是比较高的，从华为跳出来去西安的任何一家技术公司都没太大压力。\n读者补充：华为现在除非是应届生，否则基本是OD（Outsourcing Dispacth，也是一种外包，和FESCO签合同，但直系领导都是华为的人，而不是在乙方公司的团队里给甲方华为干活），不能拿股票。如果你想赚钱，可以放弃一切顶住压力，去华为还不错，但也要注意部门，无线网，核心网，还有现在的车联网还不错，但是不建议考虑现在的终端了。\n阿里巴巴\n阿里巴巴还没大范围的在西安招人，情况目前还不太清楚。我问过阿里巴巴的员工，只知道目前在西安设点的部门是阿里云，需要半年在杭州上班，半年在西安上班，工资水平和杭州一致。不过目前招的量比较小，基本都是招高p，主要是做售前的业务架构设计，只有很少的校招名额。\n京东\n京东把京东物流的团队设在了西安航天城，目测团队规模在几百人，工资水平大约是京东在北京工资的 80%。大家可以参考一下，京东去年在北京的部门，校招普通 offer 是年包 28 万，sp 是年包 32.9 万。\n一位在西安京东的读者补充：上班早9点晚7点，周六没有培训不用来。\n腾讯云\n腾讯云是腾讯的全资子公司，目前对这里褒贬不一。校招薪资水平本科和硕士生大概是月薪 13-16k，每年 16 薪，大家可以参考一下，腾讯 21 届校招的薪资是 17-21.5k ，每年 18 薪。社招我看一个本科毕业四年经验的老哥拿到的年包是 33 万。腾讯云的职级和腾讯不是对齐的，并且业务比较边缘，这也是网上被喷的一个主要原因。目前西安腾讯云创立时间不久，加班强度是比较大的。\n字节跳动、小米、ViVO、OPPO\n小米已经确定在西安设立研发中心了，但具体是哪些部门还不太清楚。字节跳动之前在西安的部门是审核相关的岗位，目前也有较为确定的消息会在西安设立研发中心，大家感兴趣的话持续关注。今年vivo在线高新环普也设立研发部门了，听说待遇不错。OPPO在西安也是刚设立研发部门不久，招人比较疯狂，听说加班也很疯狂。\n广联达\n广联达西安的部门在针对 21 届毕业生的校招中开出的薪资是很有诚意的。给应届硕士的 sp 是 19k x 15，普通 offer 是 17k x 15，本科生每月基本都在 13-17k 之间。广联达工作制度基本是 965 或者 975，每个月还有一天的带薪病假。这还要啥自行车？不过广联达曾经也有过黑料，大家自行上网了解。\n浙江大华、海康威视\n海康威视其实是国企，但是海康威视和大华工作强度和待遇方面特别一致，就放一块说了。大华和海康威视在西安都有设立研发基地的，并且招人很多。这哥俩目前在网上被喷的比较狠，据说工作强度很大，但工资水平又很低，并且涨薪缓慢。大家如果想去进一步了解可以去找这两个厂子的员工哈。\n360\n360 在西安只有一个几十人的团队。没听说过这里有校招，社招的话 3 年以上经验的差不多能每月给到 20k 。有说在这里待的舒服的，也有喷的。\n奇安信\n奇安信在校招的工资和中兴差不多，年薪 20 万 左右，工作制度是 1085。在西安招的人还是挺多的。\n科大讯飞\n科大讯飞西安丝路总部主要是算法岗，不过我看网上喷的比较多。据说是活多钱少。\n大疆\n在西安的岗位只有相机嵌入式和测试岗位，工资比华为还要略高。\nOPPO\n21 年年初刚在西安成立，最近疯狂招人。加班严重。\n绿盟\n绿盟算是中型企业里比较香的，绿盟在安全领域还是比较强的。工资比较低，硕士校招才能给到 14k x 14，但是这家公司几乎不加班，员工的离职率也一直很低，我同学有违约中兴三方去绿盟的。\n读者补充：最近在绿盟科技实习测试，深切体会到养老型公司。不加班。\n当当网\n早 9 晚 8 点半，周末双休。组内氛围还不错\n交叉信息核心技术研究院\n主要做人工智能。背景很强大。大佬姚期智带队，有 30 位清华交叉信息研究院的教授参与运营。招人的要求很高。\n寒武纪\n寒武纪是做智能芯片的公司，背后站着中科院计算所。2019 年落户的西咸新区，相关信息比较少。我知道的是加班比较多，不过薪资也高。\n其他\n其它的中型私企我就不一个个点评了，我把在西安设立研发部门的公司名字列在这里，大家感兴趣自己去了解。\n诺瓦科技（西电的老师开的）、优信二手车、美林数据、交大捷普、交大长天、西电捷通、葡萄城、全时云、神策数据。\n国企 感觉西安几家国企的性价比略低，工资不高，且大部分加班严重。校招应届硕士工资税前年薪基本都在 15w-20w 之间，本科生的年薪比硕士少 3w 左右。国企相较于私企涨薪会慢很多，不过相对稳定一些。\n中兴\n中兴校招的蓝剑计划还是给的挺多的，去年蓝剑计划给出的薪资包是 40 万以上，不过名额很少，一个大部门就一两个名额。除蓝剑计划外，其它等级的 offer 月薪在 10-15k 之间，每年 14 薪或 15 薪。\n移动\n移动西安研究院和移动雄安研究院都在西安，对，你没听错，雄安研究院也在西安设点了。硕士总包大约 16-19 万，移动的工资一部分会在年底按年终奖的形式发，平常每月发的工资比较少。\n联通\n西安联通软件研究院，应届硕士的总包和移动差不多，大约 16-19 万。不过联通比较清闲，大部分部门都能下午六点就下班。目前在网上的评价相对好一些。\n大唐\n大唐的加班挺严重的，周内需要有三天加班到九点。周末需要加够 8 个小时的班。\n烽火星空\n当时来学校校招时，说工资会在 10-20k 之间，根据面试表现进行工资评定。最近在听说加班比较严重。\n太极集团\n最初 12306 主要就是太极开发的 ，刚搬来西安不久，硕士工资水平是到手 7-8k 每月，每年 13 薪。工作稳定。出差多，加上出差补助的话每个月收入还可以。\n荣耀\n荣耀目前的招人需求是很大的，工作强度未知，薪资水平目前是完全对标华为的。\n南瑞\n南瑞是国家电网的技术型研究院，目前的项目也基本都是围绕电力行业的。南瑞的校招工资会在基础上根据学历来价钱。西安的校招工资年薪也在 15-20w 这个范围内。大部分部门出差比较多。\n润联科技\n工作稳定、薪资还可以。不过润联科技深圳那边相对好一点。\n银行软件开发中心 除了银行软件开发中心，各省分行的科技部门大家也可以去考虑，这里就不展开介绍了。银行的软件开发中心待遇水平是不错的，且基本都属于总行编制，生活稳定。目前对于准备留在西安的同学来说，去银行的软件开发中心是一个不错的选择。但近年来有一股银行软件开发中心子公司化的浪潮，今后的稳定性未知。\n农行软开\n农行软开目前是在西安工作的最好的几个选择之一，硕士每月到手 12k，本科生少几百块钱，年终奖 2-4 个月。大部分部门都能晚上 7 点以前下班，并且周末双休。目前农行软开有子公司化软件开发中心的计划，听消息说可以选择去子公司，也可以留在软开。目前西安的农行软开也越来越卷，大部分的 offer 都给了西电、西交、西工大这三个学校了，另外这三个学校的学生现在也不是想去农行就能去了。农行软开有个硬性规定是必须通过六级才能报。\n工行软开\n西安的工行软开属于总行序列。本科生和硕士生进入工行后职级都是助理经理，年薪总包 20 万左右，本科生每月工资就比硕士生少几百块钱。工行软开每月发的工资会少一些，然后年终会一下发好几万的年终奖。本科生需要两年才能升经理一，硕士需要一年就可以升 经理一。升到 经理一 后表现好一年就可以升 经理二，不过从助理经理到经理二的薪资涨幅不大。从毕业到升职成为经理三（相当于组长）最快需要五年，经理三的年薪还是很可观的。\n读者补充：西安工行周一、周二、周四需要加班\n中行软开\n西安的中国银行软件开发中心给应届硕士的报价是年薪 13 万，大家可以参考一下。\n中行软开的技术面试一般问的技术问题比较少，都是最基本的问题，比较简单。\n浙商银行\n浙商银行在银行软开中给的工资算多的，西安硕士的年薪包是 25-28 万，本科生的年包是 19-23 万。也算一个还不错的选择了。\n浦发银行\n浦发银行在西安的软件开发中心被子公司化了。工资本科是（5-7k）*24，硕士是 7.5k *24。这个工资是什么意思呢，就是每个月给你 5-7k，然后年底再一下子给你发 12 个月的工资当成年终奖。\n邮政银行\n邮储银行软件开发中心在西安刚成立，还不太确定。目前宣传是年包 28 万以上，工作强度目测比较大。\n中信建投\n中信建投刚落在西安不久，今年已经开始校招了。中信建投目前在西安算是性价比最高的几个好去处之一，工资水平较高，每年发18个月的工资，而且大部分部门加班不怎么严重。中信建投YYDS。不过目前中信建投学历卡的比较严，要求硕士985，同时本科还要求211，偶尔会放宽松一点本科的条件。\n外企 一般情况下，外企的工作强度会更小一点，基本都是 955 和 965 的样子。\n三星\n大部分应届生都是（11-14)k *13.5k。965 工作制。几乎都是芯片、运维相关岗位。\n有读者补充：三星工作制度是855，16薪。可以参考。\nSAP\nSAP 是一家做企业软件的德企，技术十分强大。硕士年薪 20 万左右，本科生年薪 15 万左右。\n不过，我有一个同学去 SAP 面试之后回来说面试体验非常差。\n读者补充：西安现在的SAP是原来的SyBase西安分公司，由于后者整体被前者收购了，所以后者在西安的分公司自然而然的变成了前者的分公司，和北京SAP分公司，上海、成都的研究员的文化都不太一样。\nThougtworks\n在 Thoughtworks 工作是很舒服的，开放式办公、扁平化管理、技术氛围浓厚。工资本硕都是 13k x 14。\nThougtWorks 的新人培养机制还是很赞的！对于应届生入职 ThougtWorks 的话，在你正式上手做项目之前会有 1 个月左右的培训时间。社招的话，整个流程一般会比较简单点，相关人员带你了解了公司的基本情况后，后面可能就会让你开始上手做项目了。\n其他\n听说汇丰和爱立信在西安也有软件开发中心，大家感兴趣可以自行去了解。\n读者补充：爱立信在西安的不是研发中心（其研发在上海、成都，北京也有但是小，硬件研发在南京），而是运维和交付中心。\n读者补充：汇丰在西安的不是汇丰总公司的软开，而是收购的的一家子公司，也是家银行的软开，但是待遇也不差，有在招开发和测试。\n研究所 西安航空航天类的研究所特别多，我知道的招计算机方面的研究所有航天 504 所、771 所，航空 631 所、618 所、603 所，中电 20 所、39 所，兵器工业 203 所、204 所、205 所。\n这些研究所中，待遇最好的是航天 504 所，但是招人的要求很高，目前校招进去的大部分是博士，双 985 硕士（就是本科和研究生都毕业于 985 高校）想进都很难。其次 618 所和兵器工业的研究所待遇还不错，这几个研究所招聘有一个隐形的要求就是双 985 硕士。其它所的性价比就比较差了。631 所曾经被誉为西北第一神所，但目前的效益也不行了，现在的待遇是年薪 10 万，第一年额外会给 5 万的安家费。\n外包 西安有的几家比较大的是中软国际、软通动力和文思海辉。中软国际和软通动力主要是在给华为做外包，工作强度几乎和华为基本一样。外包的性价比不太高哈。\n生活 陕西的资源基本都集中在西安，从人口上也能看出西安的资源有多集中。整个陕西三千多万人，在西安就有一千多万。并且这些年中央对西安的扶植力度越来越大。\n房价 西安的房价从 18 年到现在翻了一倍，但就目前的房价相较于其它同类型城市算是比较友好的。现在西安的房价最贵的在曲江、第二贵是高新区。其它地方的房价差不多一万六左右吧，不过今年的全运会过后可能会长一波。按照程序员的工资来说，在西安买房的问题不算很大，这也是程序员待在西安比较舒服的地方。对于程序员来说，租房的压力相对较小，我同学有在农行软开工作的，在附近租了一个一居室的开间四十平左右，一个月一千五，上班步行用不了十分钟。高新那边租房贵一些，你愿意合租的话压力也不大。\n西安住建前段时间出了二手房交易参考价格，我贴在下面大家可以参考下，不过这个价格感觉低于市场价了。我感觉这直接打了个八折~西安住建发布二手房交易参考价格的链接在这里 https://mp.weixin.qq.com/s/Gis7kIJklWygTseztydDaw\n教育资源 西安的教育资源很好。高中教育资源方面，西安的名校众多。西工大附中、西安铁一中、高新一中、交大附中、陕师大附中这些学校在全国都是很有名的，另外还有一批在陕西省很有名的高中也很不错。大学教育资源方面，整个陕西有三所 985，西工大和西安交大都在西安，西北农林科技大学就在离西安不远的杨凌。\n另外，还有像西安电子科技大学、西北大学、陕西师范大学、长安大学、第四军医大学这些不错的 211，还有像西安邮电、西安理工、西安科技大学、西安工业大学等等这些不错的双非院校。西安每年产出的人才的数量是很庞大的。这是很值得西安自豪的一点，但是这也造成了一个问题，西安就业十分的内卷。有一个现象是陕西人都愿意在西安，不愿意出来，计算去外面上学的陕西人毕业也大部分都回到了西安，另外在西安上过学的也大部分留在了西安。西安的几个效益比较好的研究所、银行软开的应聘难度比在北京的同级别单位都难很多。内卷不仅表现在计算机，计算机算好的，我了解到目前好多西安的小学老师都敢只要 211 以上毕业的硕士生。\n医疗资源 医疗资源方面西安也很给力，交大一附院、交大二附院、唐都医院、西京医院、红会医院都是放在全国都很强的，另外其他一批省内比较有名的医院也很不错。\n交通 西安的交通方面不敢恭维，堵车那是一绝，我的感觉是西安比北京都要堵。西安的地铁 21 年初新开了 3 条线路，目前共有 8 条线路才勉强够的上需求。每逢法定节假日，旅游的人都会把西安挤炸。说到旅游，近年来西安对游客的吸引力是越来越大，一方面西安在弘扬大唐文化，另一方面西安的美食也叫一个美滴很。\n另外，大唐不夜城这里的人是真的多，尤其是夏天，晚上的时候基本打不到车！\n气候 气候方面，西安从 5 月初开始就开启高温模式，一直延续到 10 月中旬。我第一次去西安时是 8 月份，坐着动车，每个从动车下来的人都会情不自禁的喊一声妈呀。西安的热不止是白天热，晚上也很热，每年七八月份不开空调是别想睡觉的。\n不过，西安的天气相比于武汉来说要好很多。我之前也去过武汉，又热有潮湿，天气还多变，真的顶不住！\n做个总结 综上所述，西安目前正处在高速上升的阶段，互联网行业相对北上广深杭还有一定的差距，相比与成都也还稍差一点。但是西安绝对是有潜力的，并且目前西安的房价还是比较友好的。大家如果能选择在西安发展，生活幸福感会比较高。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/xian/","summary":"西安 大家好呀，这篇文章首发在我的微信公众号CS指南上，发出来以后受到了许多读者的支持，也有大量读者对信息进行了补充，信息已经越来越全面了。我","title":""},{"content":"郑州 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。\n由于我本人对郑州不是很了解，于是我咨询了很多在郑州工作和上学的朋友之后才把郑州的给安排了！\n以下分享的仅仅代表我个人的调研结果，如有有误或者需要完善的地方，欢迎在评论区指出！\n首先我们来看工作机会！\n一位读者的评论我觉得特别的好，我贴到这里给大家看下：\n网名\u0026quot;咔嚓\u0026quot;：作为在郑州工作的前端，表示遇见好厂的话，生活节奏还是很爽的，房租不贵，直接住公司旁边，通勤5分钟，不加班的话，每天晚上6点下班，双休。确实郑州互联网不强，但是，我们也不应该忘了生活本该有的样子啊。\n工作机会 郑州的互联网资源还是比较匮乏的，究其原因，我觉得和教育资源的匮乏有非常大的关系。\n教育资源极度匮乏导致好的企业不来，好的企业不来又导致人才外流，恶性循环。\n数字郑州 这个是阿里和郑州的政府合作的，目前评价大家对数字郑州的评价很不错呀，薪资也挺给力的，大家可以看下 Boss 上数字郑州的招聘岗位以及薪资报价呀。\n中原银行 中原银行的工资比较高，在郑州生活的话去中原银行是很不错的选择，不过想进中原银行的话，不是校招想进去有点难。薪资水平可以看下 Boss 上的招聘薪资水平。\n浪潮 浪潮在郑州的研发中心法定节假日加班是有加班费的，但平时加班就没有加班费了，每月要求加够50个小时的班。薪资水平大家也可以参考下 Boss 上放出的招聘薪资水平。\n新华三 新华三大部分情况下能双休，周末加班也有加班费，不过涨薪很缓慢。在网上看到一个帖子，有人问 offer 选西安中兴还算郑州新华三，中兴和华三的职工都在互相劝退，说这是一个送命题。薪资水平大家还是参考下Boss上的招聘薪资水平吧。\nUU 跑腿 UU 跑腿主要提供同城送件服务，是郑州本土最大的互联网公司，隶属于郑州时空隧道信息技术有限公司，地址位于郑州市金水区。\nUU 跑腿的工作环境以及各种福利都还算不错！\n面试的话，总体体验还不错，技术面试一般问的还比较全面。拿 Java 后端开发来说，像 SQL 优化、分布式、缓存这些一般都会问到。\n薪资的话，看准网上的平均薪资是 10k 附近，其中后端开发的薪资在 14k 附近，前端开发的薪资在 10k 附近，软件测试的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n中原消费金融 河南中原消费金融股份有限公司是一家全国性非银行金融机构，地址位于郑州市郑东新区。\n中原消费金融的办公环境非常不错，薪资福利相对也还不错。\n整体面试体验不错，效率也非常高，像技术面试的话一般是三轮或者四轮。不过，中原消费金融比较看重学历，985/211 上岸的几率比较大。\n薪资的话，看准网上的平均薪资是 16k 附近，其中后端开发的薪资在 17k 附近，前端开发的薪资在 16k 附近，软件测试的薪资在 14k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入，应该到不了这么高)。\n注意：大家注意一个情况，中原消费的软件研发岗位大部分都搬迁到上海了，目前在郑州的大部分是行政岗位，只有少部分研发岗位。\n刀锋互娱 刀锋互娱是一家专注游戏服务市场的互联网公司，2019 年完成 A+轮融资，平台注册用户量突破千万。\n旗下比较出名的产品有租号玩、一派陪玩，都是和游戏领域相关的产品。相信比较喜欢玩游戏的小伙伴应该对这个两个产品有了解。\n整体面试不是很难，薪资相对来说也还可以。\n薪资的话，看准网上的平均薪资是 16k 附近，其中后端开发（C++）的薪资在 20k 附近，前端开发的薪资在 8.5k 附近，软件测试的薪资在 9.5k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n新开普 新开普也是郑州的一家本土互联网公司，成立于郑州高新技术产业开发区，主要做 NFC 近场移动支付、金融 IC 卡等业务。\n新开普是目前国内一卡通行业唯一一家上市公司，已经为全国千所高校，千万名大学生提供服务。\n技术面试的话，一般第一面是笔试，笔试之后会再问你一些相关的技术问题。\n薪资的话，看准网上的平均薪资是 7.6k 附近，其中后端开发（Java）的薪资在 9k 附近，前端开发的薪资在 9k 附近，软件测试的薪资在 5.5k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n中移在线 中国移动旗下的一家“互联网”公司，实际不像是“互联网”公司。\n对于技术开发来说，去中移在线一是对技术没有提升或者挑战，二是工资是真的低（看准网上的 Java 开发薪资在 8k 附近）。\n真心不太建议去，除非你没有其他更好的选择。\n我能想到唯一的优势可能是公司相对来说能提供给你的一个相对稳定的工作。\n爱云校 爱云校常见于 2014 年，主要做的是在校教育这块，致力于通过 AI 建一所云上的学校。\n单看公司所做的业务方向来说，发展相对来说还是不错的。不过，据说公司的管理真的是渣到了一定程度。\n另外，根据大部分面试求职者的反馈来看，这家公司的整体面试体验比较差。\n薪资的话，看准网上的平均薪资是 12k 附近，其中后端开发（Java）的薪资在 14k 附近，前端开发的薪资在 8k 附近，软件测试的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n妙优车 妙优车主要做的是汽车方面的业务，涵盖整车销售、汽车金融、汽车保险、汽车用品、汽车美容等方面。\n公司发展一般，网上也有一些黑历史(可以自己查一下)。\n不过，根据大部分面试求职者的反馈来看，这家公司的整体面试体验还是可以的。\n薪资这块的一般偏上，看准网上的平均薪资是 11k 附近，其中后端开发（Java）的薪资在 12k 附近，前端开发的薪资在 10k 附近(薪资水平仅供参考，实际情况因人和岗位或许会有一些出入)。\n腾河 腾讯是河南腾河网络科技有限公司的最大股东，第二大股东是河南日报。\n主要做的业务方向是河南城市生活第一网。\n工资比较低，另外，后端这块好像只招 PHP。\n真二网 不得不说，这个名字有点东西！\n真二网创立于 2014 年，也是郑州本土的一家互联网公司，主要做 C2C 模式的 0 中介费真实二手房交易平台。\n工资比较低，另外，后端这块好像只招 PHP。\n硕诺科技 硕诺科技创立于 2014 年，总部位于上海，主要做物流软件系统高端定制的软件开发。\n网上可以查到的消息比较少，感兴趣的小伙伴可以自己去查一下相关信息啊！\n另外，如果有小伙伴对这家公司比较了解，也可以在评论区说一下啊！\n科大讯飞 科大讯飞在郑州金水区有一个小分部，大部分招聘的都是和技术无关的岗位，不过也有一个 Java 开发岗。\n字节跳动 郑州也有字节跳动分部，不过都是和市场拓展与运营相关的岗位，像技术开发岗是没有的。\n类似的还有美团、华为、阿里巴巴等大厂，这些公司在郑州招聘的基本也都是非技术岗位。\n其他 其他还有像郑州点读电子科技有限公司（旗下产品有咿啦看书）、羲和网络（河南唯一一家游戏上市企业）、米宅（中国知名的楼市自媒体，新三板上市企业）等互联网公司，感兴趣的小伙伴可以自行查阅相关信息呀！\n读者补充：海康威视、APUS、云鸟、亚信科技、牧原食品、小鱼易联、神州信息、云智慧都在郑州招开发工程师。\n生活环境\u0026amp;生活成本 我们再来看看生活环境和生活成本。\n房价 郑州的房价对于其发展来说还是比较贵的。当然了，相比于一线城市肯定还是要便宜很多的！\n以下房价数据来源于安居客，可以作为参考。\n教育 郑州的教育资源极度匮乏！据统计郑州一共有 65 所高校，其中，本科 26 所，专科 39 所。\n不过，211 院校仅有一所——郑州大学。\n是的！作为偌大的河南省的省会，国家历史文化名城，也就只有一所 211！\n我们来对比一下湖北省省会武汉，武汉 7 所 985/211 高校，分别是武汉大学、华中科技大学、中国地质大学、武汉理工大学、华中师范大学、华中农业大学、中南财经政法大学。\n再来对比一下湖南省省会长沙，长沙有 4 所 985/211 高校，分别是国防科大、中南大学、湖南大学、湖南师范大学。\n医疗 郑州的每万人床位数排名比较靠前。\n另外，郑州市的优质医疗资源，在金水区、中原区、管城区比较集中；\n本地居民 网上有很多“河南黑”，让很多人对河南的影响不好！\n实际情况可能并不是这样的！郑州本地居民不排外，绝大部分都特别老实，本本分分。\n我去过很多城市，郑州人的友善程度我觉得是可以排在 Top 级别的！\n另外，郑州这边的居民还是比较恋家的。有很多在北上广混的还不错的人，最后也还是选择回来！\n交通 作为一个北方内陆城市，郑州可以说是一个“交通枢纽”。从郑州出发坐高铁，你去国内大部分地方都非常方便。\n下图中的部分高铁线路正在修建，比如郑万高铁全线大概是 2021 年中旬通车。\n郑州的地铁规划情况如下图所示。\n目前的话，郑州地铁有 1 号线、2 号线、3 号线、4 号线、城郊线、5 号线、14 号线一期 7 条地铁线。\n美食 郑州的各种商业设施还是比较齐全的，有很多大型的商场，商场里面基本是样样俱全。\n郑州好吃的还挺多的！去了郑州之后，一定要去喝胡辣汤，真的不要太好喝！\n本地的美食还有烩面、焖饼、烧鸡等等都非常不错。\n巩义那边有一家花雕醉鸡真心不错，价格便宜，2 个人不到 100 元就能吃的很好！最关键的是味道真的好！！！\n像浙菜、豫菜、火锅串串这边都能找到比较好吃的店子，可以满足绝大部分小伙伴的味蕾。\n公众号 我是大白，毕业于某 985 院校，2020 年校招拿到了绝大部分大厂的 offer。这个账号主要编程必备基础知识、数据结构和算法、操作系统、计算机网络、计算机组成原理。欢迎大家关注！\n","permalink":"https://coderrenxy.github.io/posts/read/zhengzhou/","summary":"郑州 大家好，我是大白。这篇文章首发在我的公众号【CS指南】上，发出后受到了很大读者的支持，也有许多读者对文章信息进行了补充。 由于我本人对郑州","title":""},{"content":"\r小任同学\u0026#39;s Blog\r小任同学的博客\r\r\r\r\rBanTanger\r这是半糖先生的博客\r\r\r\r\r小林coding\r这是林佬的网站\r\r\r\r\r添加\r期待加入...\r\r\r\r👉友链格式 名称： 小任同学 网址： https://coderrenxy.github.io/ 图标： https://coderrenxy.github.io/img/icon-512.png 描述： 小任同学的博客\n👉友链申请要求\n-秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://coderrenxy.github.io/links/","summary":"小任同学\u0026#39;s Blog 小任同学的博客 BanTanger 这是半糖先生的博客 小林coding 这是林佬的网站 添加 期待加入... 👉友链格式 名称： 小任同学 网址： https://coderrenxy.github.io/ 图标","title":"🤝友链"}]